[2024-23-08 11:00:46 INFO] **[Preprocessing]**

**ChatDev Starts** (20240823110046)

**Timestamp**: 20240823110046

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}


**project_name**: RealWorld_BA_66_BorrowerOperations

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_66_BorrowerOperations_RealWord_20240823110046.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-23-08 11:00:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:00:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:00:47 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-23-08 11:00:52 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:00:52 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27378
completion_tokens: 1
total_tokens: 27379
cost: $-1.000000


[2024-23-08 11:00:53 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Let's

[2024-23-08 11:00:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n    // --- Connected contract declarations ---\n    ITroveManager internal troveManager;\n    address internal stabilityPoolAddress;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n    IYUSDToken internal yusdToken;\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n    / --- Variable container structs  ---\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n    // --- Dependency setters ---\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n        deploymentTime = block.timestamp;\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n        _renounceOwnership();\n    }\n    // --- Borrower Trove Operations ---\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n        vars.isRecoveryMode = _checkRecoveryMode();\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n        vars.netDebt = _YUSDAmount;\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n        _adjustTrove(params);\n    }\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n        _adjustTrove(params);\n    }\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n        bool isRecoveryMode = _checkRecoveryMode();\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n        _adjustTrove(params);\n    }\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n    // --- Helper functions ---\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n        return (_newVC, newDebt);\n    }\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n    // --- \'Require\' wrapper functions ---\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n    // --- ICR and TCR getters ---\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n /\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n    // --- Connected contract declarations ---\n    ITroveManager internal troveManager;\n    address internal stabilityPoolAddress;\n    address internal gasPoolAddress;\n    ICollSurplusPool internal collSurplusPool;\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n    IYUSDToken internal yusdToken;\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n    / --- Variable container structs  ---\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n    // --- Dependency setters ---\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n        deploymentTime = block.timestamp;\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n        _renounceOwnership();\n    }\n    // --- Borrower Trove Operations ---\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n        vars.isRecoveryMode = _checkRecoveryMode();\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n        vars.netDebt = _YUSDAmount;\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n        _adjustTrove(params);\n    }\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n        _adjustTrove(params);\n    }\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n        bool isRecoveryMode = _checkRecoveryMode();\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n        _adjustTrove(params);\n    }\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     /\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     */\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n    // --- Helper functions ---\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n        return (_newVC, newDebt);\n    }\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n    // --- \'Require\' wrapper functions ---\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         /\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n    // --- ICR and TCR getters ---\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:00:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:00:53 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";
/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */
 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */
contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";
    // --- Connected contract declarations ---
    ITroveManager internal troveManager;
    address internal stabilityPoolAddress;
    address internal gasPoolAddress;
    ICollSurplusPool internal collSurplusPool;
    ISYETI internal sYETI;
    address internal sYETIAddress;
    IYUSDToken internal yusdToken;
    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;
    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;
    struct CollateralData {
        address collateral;
        uint256 amount;
    }
    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }
    /* --- Variable container structs  ---
    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }
    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }
    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }
    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }
    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }
    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);
    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);
    // --- Dependency setters ---
    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");
        deploymentTime = block.timestamp;
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);
        _renounceOwnership();
    }
    // --- Borrower Trove Operations ---
    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls
        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }
    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }
    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);
        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage
        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;
        vars.isRecoveryMode = _checkRecoveryMode();
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);
        vars.netDebt = _YUSDAmount;
        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);
        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }
        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );
        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee
        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }
        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);
        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);
        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);
        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);
        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);
        contractsCache.activePool.receiveCollateral(_colls, _amounts);
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );
        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );
        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }

    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself
        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }

    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;
        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }
    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself
        _adjustTrove(params);
    }
    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }
    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }
    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);
        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);
        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );
        _adjustTrove(params);
    }
    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;
        bool isRecoveryMode = _checkRecoveryMode();
        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }
        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;
        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);
        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }
        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);
        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);
        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }
        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);
        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }
        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);
        vars.debt = vars.debt.add(vars.variableYUSDFee); 
        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );
        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );
        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }
        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }
        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );
        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);
        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);
        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);
        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);
            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );
            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );
            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }
    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell
        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }
    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);
        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;
        _adjustTrove(params);
    }
    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }
    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }
    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();
        contractsCache.troveManager.applyPendingRewards(msg.sender);
        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);
        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }
        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);
        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);
        address[] memory finalColls;
        uint256[] memory finalAmounts;
        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);
        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);
        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }
    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }
    // --- Helper functions ---
    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);
            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );
            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);
            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }
    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }
    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }
    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }
    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }
    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }
        return (_newVC, newDebt);
    }
    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);
        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );
        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }
    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }
    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }
    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }
    // --- 'Require' wrapper functions ---
    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }
    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }
    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }
    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }
    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }
    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }
    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }
    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }
    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }
    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }
    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }
    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }
    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }
    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }
    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }
    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }
    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }
    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }
    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }
    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }
    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }
    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }
    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }
    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }

    // --- ICR and TCR getters ---
    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);
        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }
    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();
        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);
        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }
    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";
/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */
 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */
contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";
    // --- Connected contract declarations ---
    ITroveManager internal troveManager;
    address internal stabilityPoolAddress;
    address internal gasPoolAddress;
    ICollSurplusPool internal collSurplusPool;
    ISYETI internal sYETI;
    address internal sYETIAddress;
    IYUSDToken internal yusdToken;
    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;
    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;
    struct CollateralData {
        address collateral;
        uint256 amount;
    }
    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }
    /* --- Variable container structs  ---
    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }
    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }
    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }
    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }
    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }
    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);
    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);
    // --- Dependency setters ---
    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");
        deploymentTime = block.timestamp;
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);
        _renounceOwnership();
    }
    // --- Borrower Trove Operations ---
    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls
        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }
    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }
    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);
        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage
        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;
        vars.isRecoveryMode = _checkRecoveryMode();
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);
        vars.netDebt = _YUSDAmount;
        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);
        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }
        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );
        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee
        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }
        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);
        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);
        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);
        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);
        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);
        contractsCache.activePool.receiveCollateral(_colls, _amounts);
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );
        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );
        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }

    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself
        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }

    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;
        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }
    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself
        _adjustTrove(params);
    }
    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }
    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }
    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);
        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);
        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );
        _adjustTrove(params);
    }
    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;
        bool isRecoveryMode = _checkRecoveryMode();
        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }
        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;
        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);
        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }
        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);
        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);
        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }
        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);
        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }
        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);
        vars.debt = vars.debt.add(vars.variableYUSDFee); 
        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );
        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );
        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }
        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }
        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );
        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);
        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);
        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);
        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);
            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );
            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );
            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }
    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell
        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }
    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);
        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;
        _adjustTrove(params);
    }
    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }
    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }
    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();
        contractsCache.troveManager.applyPendingRewards(msg.sender);
        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);
        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }
        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);
        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);
        address[] memory finalColls;
        uint256[] memory finalAmounts;
        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);
        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);
        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }
    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }
    // --- Helper functions ---
    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);
            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );
            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);
            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }
    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }
    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }
    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }
    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }
    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }
        return (_newVC, newDebt);
    }
    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);
        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );
        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }
    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }
    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }
    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }
    // --- 'Require' wrapper functions ---
    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }
    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }
    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }
    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }
    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }
    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }
    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }
    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }
    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }
    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }
    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }
    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }
    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }
    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }
    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }
    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }
    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }
    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }
    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }
    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }
    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }
    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }
    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }
    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }

    // --- ICR and TCR getters ---
    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);
        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }
    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();
        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);
        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }
    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-23-08 11:00:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:00:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 41108
completion_tokens: 1
total_tokens: 41109
cost: $-1.000000


[2024-23-08 11:00:58 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Security

[2024-23-08 11:00:58 INFO] **[Seminar Conclusion]**:

 Security

[2024-23-08 11:00:58 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-23-08 11:00:58 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 11:00:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:00:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:00:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:01:02 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:02 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27369
completion_tokens: 1
total_tokens: 27370
cost: $-1.000000


[2024-23-08 11:01:02 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

###

[2024-23-08 11:01:02 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:01:02 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 11:01:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:02 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:01:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13744
completion_tokens: 884
total_tokens: 14628
cost: $-1.000000


[2024-23-08 11:01:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Based on the provided Solidity smart contract code for the `BorrowerOperations` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., transferring tokens, interacting with routers) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - Functions that handle user input, such as `_adjustTrove`, `_openTroveInternal`, and others, may not sufficiently validate the input parameters. This could lead to unexpected behavior or exploitation if invalid data is passed.

3. **Arithmetic Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to overflow or underflow if `SafeMath` is not consistently applied or if Solidity versions change in the future.

4. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., transferring multiple collaterals) could run into gas limit issues if the number of iterations is too high. This could lead to failed transactions.

5. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical contract addresses. If the owners address is compromised, an attacker could redirect funds or manipulate contract behavior.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve significant financial transactions (e.g., opening or adjusting troves).

7. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which could hinder tracking of contract activity and make it difficult to audit or monitor the contract's behavior.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `MIN_NET_DEBT`) that could be problematic if they need to be updated in the future. This could lead to inflexibility or require redeployment.

9. **Potential for Unchecked External Calls**:
   - There are several external calls to other contracts (e.g., routers, token transfers) that do not check for success or failure. This could lead to unexpected behavior if the called contract fails.

### Comprehensive Analysis Report:

The `BorrowerOperations` contract is a complex piece of code that handles various financial operations related to collateralized borrowing. While it implements several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The use of external calls poses a risk of reentrancy attacks. It is crucial to ensure that all state changes are completed before making external calls.

2. **Input Validation**: Insufficient validation of user inputs can lead to unexpected behavior. Implementing stricter checks and validations is necessary to prevent exploitation.

3. **Arithmetic Safety**: Although `SafeMath` is used, the reliance on it should be consistent throughout the contract to prevent potential overflow or underflow issues.

4. **Gas Limit Concerns**: Functions that involve loops should be optimized to avoid exceeding gas limits, which could lead to transaction failures.

5. **Access Control**: The owners privileges should be carefully managed, and additional access control mechanisms could enhance security.

6. **Front-Running Prevention**: Implementing measures to mitigate front-running risks is essential for protecting users' funds during high-value transactions.

7. **Event Emission**: Ensuring that all state-changing functions emit appropriate events will improve transparency and facilitate better monitoring of contract activity.

8. **Hardcoded Values**: Consider using configurable parameters instead of hardcoded values to enhance flexibility and adaptability.

9. **External Call Checks**: Implement checks for the success of external calls to ensure that the contract behaves as expected and to prevent silent failures.

In conclusion, while the `BorrowerOperations` contract has a solid foundation, addressing the identified vulnerabilities is critical for ensuring the security and reliability of the contract. A thorough review and testing process, including audits and potential updates to the code, should be undertaken to mitigate these risks effectively.

[2024-23-08 11:01:15 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `BorrowerOperations` contract, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., transferring tokens, interacting with routers) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Lack of Input Validation**:
   - Functions that handle user input, such as `_adjustTrove`, `_openTroveInternal`, and others, may not sufficiently validate the input parameters. This could lead to unexpected behavior or exploitation if invalid data is passed.

3. **Arithmetic Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to overflow or underflow if `SafeMath` is not consistently applied or if Solidity versions change in the future.

4. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., transferring multiple collaterals) could run into gas limit issues if the number of iterations is too high. This could lead to failed transactions.

5. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical contract addresses. If the owners address is compromised, an attacker could redirect funds or manipulate contract behavior.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve significant financial transactions (e.g., opening or adjusting troves).

7. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which could hinder tracking of contract activity and make it difficult to audit or monitor the contract's behavior.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `MIN_NET_DEBT`) that could be problematic if they need to be updated in the future. This could lead to inflexibility or require redeployment.

9. **Potential for Unchecked External Calls**:
   - There are several external calls to other contracts (e.g., routers, token transfers) that do not check for success or failure. This could lead to unexpected behavior if the called contract fails.

### Comprehensive Analysis Report:

The `BorrowerOperations` contract is a complex piece of code that handles various financial operations related to collateralized borrowing. While it implements several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The use of external calls poses a risk of reentrancy attacks. It is crucial to ensure that all state changes are completed before making external calls.

2. **Input Validation**: Insufficient validation of user inputs can lead to unexpected behavior. Implementing stricter checks and validations is necessary to prevent exploitation.

3. **Arithmetic Safety**: Although `SafeMath` is used, the reliance on it should be consistent throughout the contract to prevent potential overflow or underflow issues.

4. **Gas Limit Concerns**: Functions that involve loops should be optimized to avoid exceeding gas limits, which could lead to transaction failures.

5. **Access Control**: The owners privileges should be carefully managed, and additional access control mechanisms could enhance security.

6. **Front-Running Prevention**: Implementing measures to mitigate front-running risks is essential for protecting users' funds during high-value transactions.

7. **Event Emission**: Ensuring that all state-changing functions emit appropriate events will improve transparency and facilitate better monitoring of contract activity.

8. **Hardcoded Values**: Consider using configurable parameters instead of hardcoded values to enhance flexibility and adaptability.

9. **External Call Checks**: Implement checks for the success of external calls to ensure that the contract behaves as expected and to prevent silent failures.

In conclusion, while the `BorrowerOperations` contract has a solid foundation, addressing the identified vulnerabilities is critical for ensuring the security and reliability of the contract. A thorough review and testing process, including audits and potential updates to the code, should be undertaken to mitigate these risks effectively.

[2024-23-08 11:01:15 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 11:01:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:15 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:01:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27369
completion_tokens: 1
total_tokens: 27370
cost: $-1.000000


[2024-23-08 11:01:18 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

###

[2024-23-08 11:01:18 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:01:18 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 11:01:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:18 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:01:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13744
completion_tokens: 799
total_tokens: 14543
cost: $-1.000000


[2024-23-08 11:01:31 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Based on the provided Solidity smart contract code for the `BorrowerOperations` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - Although the contract uses the `ReentrancyGuard` modifier, there are several functions that involve external calls (e.g., transferring tokens, interacting with routers) which could potentially be exploited if not properly protected. Care should be taken to ensure that state changes occur before external calls.

2. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., `_transferCollateralsIntoActivePool`, `_adjustTrove`) could run into gas limit issues if the input arrays are large. This could lead to failed transactions and denial of service.

3. **Arithmetic Vulnerabilities**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly validated, especially in functions that calculate fees or adjust debts.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that amounts are non-zero or that the arrays are of equal length. This could lead to unexpected behavior or errors during execution.

5. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical contract addresses. If the owners account is compromised, it could lead to a complete takeover of the contract. Consider implementing multi-signature wallets or time-lock mechanisms for sensitive operations.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to protect against front-running attacks, particularly in functions that involve financial transactions (e.g., opening or adjusting troves). This could allow malicious actors to exploit the timing of transactions.

7. **Insufficient Error Messages**:
   - The error messages provided in the require statements are not always descriptive enough to help identify the source of the issue. More informative messages would aid in debugging and understanding failures.

8. **Handling of Collateral and Debt**:
   - The logic for managing collateral and debt adjustments could lead to inconsistencies if not handled correctly, especially during concurrent operations. This could result in users being unable to withdraw their collateral or repay their debts as expected.

### Comprehensive Analysis Report

The `BorrowerOperations` contract is a complex financial instrument that interacts with multiple external contracts and manages user funds. While it incorporates several best practices, including the use of `SafeMath` and a reentrancy guard, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but the contract must ensure that all state changes occur before any external calls to mitigate potential reentrancy attacks.

2. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, which could lead to transaction failures. Consider implementing pagination or limiting the number of inputs.

3. **Input Validation**: Strengthening input validation across all functions will help prevent unexpected behavior and ensure that only valid data is processed.

4. **Access Control**: The reliance on a single owner for critical operations poses a risk. Implementing multi-signature wallets or time-locks for sensitive functions could enhance security.

5. **Front-Running Mitigation**: Introducing mechanisms to protect against front-running, such as commit-reveal schemes or transaction ordering, would help secure financial operations.

6. **Error Handling**: Improving error messages will aid in debugging and provide better insights into failures, enhancing the overall user experience.

In conclusion, while the `BorrowerOperations` contract demonstrates a solid foundation for managing borrower operations, it requires further enhancements in security practices, input validation, and error handling to ensure robustness against potential attacks and operational failures. A thorough audit and testing phase is recommended before deployment to mitigate these vulnerabilities effectively.

[2024-23-08 11:01:31 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `BorrowerOperations` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - Although the contract uses the `ReentrancyGuard` modifier, there are several functions that involve external calls (e.g., transferring tokens, interacting with routers) which could potentially be exploited if not properly protected. Care should be taken to ensure that state changes occur before external calls.

2. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., `_transferCollateralsIntoActivePool`, `_adjustTrove`) could run into gas limit issues if the input arrays are large. This could lead to failed transactions and denial of service.

3. **Arithmetic Vulnerabilities**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly validated, especially in functions that calculate fees or adjust debts.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that amounts are non-zero or that the arrays are of equal length. This could lead to unexpected behavior or errors during execution.

5. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical contract addresses. If the owners account is compromised, it could lead to a complete takeover of the contract. Consider implementing multi-signature wallets or time-lock mechanisms for sensitive operations.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to protect against front-running attacks, particularly in functions that involve financial transactions (e.g., opening or adjusting troves). This could allow malicious actors to exploit the timing of transactions.

7. **Insufficient Error Messages**:
   - The error messages provided in the require statements are not always descriptive enough to help identify the source of the issue. More informative messages would aid in debugging and understanding failures.

8. **Handling of Collateral and Debt**:
   - The logic for managing collateral and debt adjustments could lead to inconsistencies if not handled correctly, especially during concurrent operations. This could result in users being unable to withdraw their collateral or repay their debts as expected.

### Comprehensive Analysis Report

The `BorrowerOperations` contract is a complex financial instrument that interacts with multiple external contracts and manages user funds. While it incorporates several best practices, including the use of `SafeMath` and a reentrancy guard, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but the contract must ensure that all state changes occur before any external calls to mitigate potential reentrancy attacks.

2. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, which could lead to transaction failures. Consider implementing pagination or limiting the number of inputs.

3. **Input Validation**: Strengthening input validation across all functions will help prevent unexpected behavior and ensure that only valid data is processed.

4. **Access Control**: The reliance on a single owner for critical operations poses a risk. Implementing multi-signature wallets or time-locks for sensitive functions could enhance security.

5. **Front-Running Mitigation**: Introducing mechanisms to protect against front-running, such as commit-reveal schemes or transaction ordering, would help secure financial operations.

6. **Error Handling**: Improving error messages will aid in debugging and provide better insights into failures, enhancing the overall user experience.

In conclusion, while the `BorrowerOperations` contract demonstrates a solid foundation for managing borrower operations, it requires further enhancements in security practices, input validation, and error handling to ensure robustness against potential attacks and operational failures. A thorough audit and testing phase is recommended before deployment to mitigate these vulnerabilities effectively.

[2024-23-08 11:01:31 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 11:01:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:31 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:01:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27369
completion_tokens: 1
total_tokens: 27370
cost: $-1.000000


[2024-23-08 11:01:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

###

[2024-23-08 11:01:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:01:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 11:01:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:01:47 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:47 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13744
completion_tokens: 733
total_tokens: 14477
cost: $-1.000000


[2024-23-08 11:01:47 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

### Summary of Security Vulnerabilities in the BorrowerOperations Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks; however, it is crucial to ensure that all external calls (especially those involving token transfers) are made after state changes to avoid potential vulnerabilities.

2. **Integer Overflow/Underflow**:
   - Although the contract uses the `SafeMath` library, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in critical calculations involving debt and collateral.

3. **Improper Input Validation**:
   - The contract has several functions that require input validation (e.g., `_requireValidDepositCollateral`, `_requireNoDuplicateColls`, etc.). If these checks are not comprehensive, they could allow for invalid states or unexpected behavior.

4. **Gas Limit Issues**:
   - Functions that involve loops (e.g., transferring multiple collaterals) could run into gas limit issues if the input arrays are too large. This could lead to failed transactions.

5. **Lack of Access Control**:
   - While the contract uses the `onlyOwner` modifier for certain functions, it is essential to ensure that all sensitive functions are adequately protected against unauthorized access.

6. **Potential for Front-Running**:
   - The design of the contract may expose it to front-running attacks, especially in functions that involve price-sensitive operations (e.g., collateral adjustments). Implementing measures to mitigate this risk is crucial.

7. **Unclear Error Messages**:
   - The error messages in require statements could be more descriptive to aid in debugging and understanding the failure reasons.

8. **Dependency on External Contracts**:
   - The contract relies on several external contracts (e.g., `IYUSDToken`, `ITroveManager`, etc.). If any of these contracts have vulnerabilities or are compromised, it could affect the security of the BorrowerOperations contract.

9. **Lack of Event Emissions**:
   - While some critical state changes emit events, it is essential to ensure that all significant actions (especially those affecting user balances or state) are logged for transparency and traceability.

### Comprehensive Analysis Report

The BorrowerOperations contract is a complex smart contract that facilitates various borrower operations within a decentralized finance (DeFi) ecosystem. While it incorporates several security measures, including the use of `SafeMath` and the `nonReentrant` modifier, there are still notable vulnerabilities that need to be addressed.

The presence of potential reentrancy vulnerabilities, despite the use of protective measures, highlights the importance of careful coding practices, especially when dealing with external calls. Additionally, the reliance on external contracts introduces an additional layer of risk, as any vulnerabilities in those contracts could compromise the BorrowerOperations contract.

Input validation is crucial, and while the contract has mechanisms in place, ensuring comprehensive checks is vital to prevent invalid states. The potential for gas limit issues in functions that involve loops should also be considered, as this could lead to transaction failures.

Front-running attacks remain a concern in the DeFi space, and the contract should implement strategies to mitigate this risk. Furthermore, improving error messages and ensuring that all significant actions are logged through event emissions will enhance the contract's usability and transparency.

In conclusion, while the BorrowerOperations contract has a solid foundation, addressing the identified vulnerabilities and enhancing security measures will be essential to ensure the safety and reliability of the contract in a live environment. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats in the DeFi landscape.

[2024-23-08 11:01:47 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the BorrowerOperations Contract

1. **Reentrancy Vulnerability**: 
   - The contract uses the `nonReentrant` modifier to prevent reentrancy attacks; however, it is crucial to ensure that all external calls (especially those involving token transfers) are made after state changes to avoid potential vulnerabilities.

2. **Integer Overflow/Underflow**:
   - Although the contract uses the `SafeMath` library, it is essential to ensure that all arithmetic operations are consistently protected against overflow and underflow, especially in critical calculations involving debt and collateral.

3. **Improper Input Validation**:
   - The contract has several functions that require input validation (e.g., `_requireValidDepositCollateral`, `_requireNoDuplicateColls`, etc.). If these checks are not comprehensive, they could allow for invalid states or unexpected behavior.

4. **Gas Limit Issues**:
   - Functions that involve loops (e.g., transferring multiple collaterals) could run into gas limit issues if the input arrays are too large. This could lead to failed transactions.

5. **Lack of Access Control**:
   - While the contract uses the `onlyOwner` modifier for certain functions, it is essential to ensure that all sensitive functions are adequately protected against unauthorized access.

6. **Potential for Front-Running**:
   - The design of the contract may expose it to front-running attacks, especially in functions that involve price-sensitive operations (e.g., collateral adjustments). Implementing measures to mitigate this risk is crucial.

7. **Unclear Error Messages**:
   - The error messages in require statements could be more descriptive to aid in debugging and understanding the failure reasons.

8. **Dependency on External Contracts**:
   - The contract relies on several external contracts (e.g., `IYUSDToken`, `ITroveManager`, etc.). If any of these contracts have vulnerabilities or are compromised, it could affect the security of the BorrowerOperations contract.

9. **Lack of Event Emissions**:
   - While some critical state changes emit events, it is essential to ensure that all significant actions (especially those affecting user balances or state) are logged for transparency and traceability.

### Comprehensive Analysis Report

The BorrowerOperations contract is a complex smart contract that facilitates various borrower operations within a decentralized finance (DeFi) ecosystem. While it incorporates several security measures, including the use of `SafeMath` and the `nonReentrant` modifier, there are still notable vulnerabilities that need to be addressed.

The presence of potential reentrancy vulnerabilities, despite the use of protective measures, highlights the importance of careful coding practices, especially when dealing with external calls. Additionally, the reliance on external contracts introduces an additional layer of risk, as any vulnerabilities in those contracts could compromise the BorrowerOperations contract.

Input validation is crucial, and while the contract has mechanisms in place, ensuring comprehensive checks is vital to prevent invalid states. The potential for gas limit issues in functions that involve loops should also be considered, as this could lead to transaction failures.

Front-running attacks remain a concern in the DeFi space, and the contract should implement strategies to mitigate this risk. Furthermore, improving error messages and ensuring that all significant actions are logged through event emissions will enhance the contract's usability and transparency.

In conclusion, while the BorrowerOperations contract has a solid foundation, addressing the identified vulnerabilities and enhancing security measures will be essential to ensure the safety and reliability of the contract in a live environment. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats in the DeFi landscape.

[2024-23-08 11:01:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IYetiRouter.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\nimport "./Interfaces/IWAsset.sol";\n\n/ \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  /\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = "BorrowerOperations";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    / --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    "CompilerError: Stack too deep". /\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol\'s\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage &gt; 1e18, "WrongLeverage");\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called after collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct\'s properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove\'s debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256;\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     \n     * Should be called after the collsIn has been sent to ActivePool\n     /\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC &gt; vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove\'s old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it\'s a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don\'t send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist\'s approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage &lt;= 1e18, "WrongSlippage");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and only pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    / \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user\'s balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /\n     * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     /\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    / \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     /\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral\'s Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");\n        }\n    }\n\n    /\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     /\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove\'s coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- \'Require\' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i &lt; collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");\n            require(_amounts[i] != 0, "BO:NoAmounts");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            "BO:0Adjust"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i &lt; arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won\'t overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, "BO:NoDebtChange");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i &lt; colls1Len; ++i) {\n            for (uint256 j; j &lt; colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            for (uint256 j = i.add(1); j &lt; collsLen; j++) {\n                require(_colls[i] != _colls[j], "BO:OverlapColls");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), "BO:InRecMode");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            "BO:InRecMode"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, "BOps:Len0");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, "BO:LenMismatch");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /\n         In Recovery Mode, only allow:\n         \n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).\n         \n         * In Normal Mode, ensure:\n         \n         * - The new ICR is above MCR\n         * - The adjustment won\'t pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR &gt;= MCR,\n            "BO:ReqICR&gt;MCR"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR &gt;= _oldICR,\n            "BO:RecMode:ICR= CCR,\n            "BO:ReqTCR&gt;CCR"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt &gt;= MIN_NET_DEBT,\n            "BO:netDebt&lt;2000"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            "BO:InvalidYUSDRepay"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,\n            "BO:InsuffYUSDBal"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {\n            revert("BO:InvalidMaxFee");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");\n    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");\n    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");\n    //     for (uint256 i; i &lt; _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i &lt; _indices.length - 1; ++i) {\n    //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-23-08 11:01:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IYetiRouter.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/ReentrancyGuard.sol"; import "./Interfaces/IWAsset.sol"; /*   * BorrowerOperations is the contract that handles most of external facing trove activities that   * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.  / /*    A summary of Lever Up:    Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and    buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.    So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for    token A by using some router strategy, returning a little under $2000 token A to put back in the    trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if    we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.   / contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {     using SafeMath for uint256;     string public constant NAME = "BorrowerOperations"; // --- Connected contract declarations ---  ITroveManager internal troveManager;  address internal stabilityPoolAddress;  address internal gasPoolAddress;  ICollSurplusPool internal collSurplusPool;  ISYETI internal sYETI; address internal sYETIAddress;  IYUSDToken internal yusdToken;  uint internal constant BOOTSTRAP_PERIOD = 14 days; uint deploymentTime;  // A doubly linked list of Troves, sorted by their collateral ratios ISortedTroves internal sortedTroves;  struct CollateralData {     address collateral;     uint256 amount; }  struct DepositFeeCalc {     uint256 collateralYUSDFee;     uint256 systemCollateralVC;     uint256 collateralInputVC;     uint256 systemTotalVC;     address token; }  /* --- Variable container structs  ---  Used to hold, return and assign variables inside a function, in order to avoid the error: "CompilerError: Stack too deep". */ struct AdjustTrove_Params {     address[] _collsIn;     uint256[] _amountsIn;     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     uint256 _YUSDChange;     uint256 _totalYUSDDebtFromLever;     bool _isDebtIncrease;     bool _isUnlever;     address _upperHint;     address _lowerHint;     uint256 _maxFeePercentage; }  struct LocalVariables_adjustTrove {     uint256 netDebtChange;     bool isCollIncrease;     uint256 collChange;     uint256 currVC;     uint256 newVC;     uint256 debt;     address[] currAssets;     uint256[] currAmounts;     address[] newAssets;     uint256[] newAmounts;     uint256 oldICR;     uint256 newICR;     uint256 newTCR;     uint256 YUSDFee;     uint256 variableYUSDFee;     uint256 newDebt;     uint256 VCin;     uint256 VCout;     uint256 maxFeePercentageFactor; }  struct LocalVariables_openTrove {     address[] collaterals;     uint256[] prices;     uint256 YUSDFee;     uint256 netDebt;     uint256 compositeDebt;     uint256 ICR;     uint256 arrayIndex;     address collAddress;     uint256 VC;     uint256 newTCR;     bool isRecoveryMode; }  struct CloseTrove_Params {     address[] _collsOut;     uint256[] _amountsOut;     uint256[] _maxSlippages;     bool _isUnlever; }  struct ContractsCache {     ITroveManager troveManager;     IActivePool activePool;     IYUSDToken yusdToken; }  enum BorrowerOperation {     openTrove,     closeTrove,     adjustTrove }  event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _activePoolAddress); event DefaultPoolAddressChanged(address _defaultPoolAddress); event StabilityPoolAddressChanged(address _stabilityPoolAddress); event GasPoolAddressChanged(address _gasPoolAddress); event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress); event PriceFeedAddressChanged(address _newPriceFeedAddress); event SortedTrovesAddressChanged(address _sortedTrovesAddress); event YUSDTokenAddressChanged(address _yusdTokenAddress); event SYETIAddressChanged(address _sYETIAddress);  event TroveCreated(address indexed _borrower, uint256 arrayIndex); event TroveUpdated(     address indexed _borrower,     uint256 _debt,     address[] _tokens,     uint256[] _amounts,     BorrowerOperation operation ); event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);  // --- Dependency setters ---  function setAddresses(     address _troveManagerAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _sortedTrovesAddress,     address _yusdTokenAddress,     address _sYETIAddress,     address _whitelistAddress ) external override onlyOwner {     // This makes impossible to open a trove with zero withdrawn YUSD     require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");      deploymentTime = block.timestamp;      checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yusdTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);      troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     stabilityPoolAddress = _stabilityPoolAddress;     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sYETIAddress = _sYETIAddress;      emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  // --- Borrower Trove Operations ---  function openTrove(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] calldata _colls,     uint256[] calldata _amounts ) external override nonReentrant {     _requireLengthNonzero(_amounts.length);     _requireValidDepositCollateral(_colls, _amounts);     _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls      // transfer collateral into ActivePool     _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         0,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount // of that token that would be at the specific collateralization ratio. Mints YUSD // according to the price of the token and the amount. Calls LeverUp.sol's // function to perform the swap through a router or our special staked tokens, depending // on the token. Then opens a trove with the new collateral from the swap, ensuring that // the amount is enough to cover the debt. There is no new debt taken out from the trove, // and the amount minted previously is attributed to this trove. Reverts if the swap was // not able to get the correct amount of collateral according to slippage passed in. // _leverage is like 11e18 for 11x.  function openTroveLeverUp(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts,      uint256[] memory _leverages,     uint256[] calldata _maxSlippages ) external override nonReentrant{     uint256 collsLen = _colls.length;     _requireLengthNonzero(collsLen);     _requireValidDepositCollateral(_colls, _amounts);     // Must check additional passed in arrays     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(_colls);     uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _colls[i],                 _amounts[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);             // additional token amount was set to the original amount * leverage.              _amounts[i] = additionalTokenAmount.add(_amounts[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);      _openTroveInternal(         msg.sender,         _maxFeePercentage,         _YUSDAmount,         totalYUSDDebtFromLever,         _upperHint,         _lowerHint,         _colls,         _amounts     ); }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleLeverUp(address _token,      uint256 _amount,      uint256 _leverage,      uint256 _maxSlippage)      internal     returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {     require(_leverage &gt; 1e18, "WrongLeverage");     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.     uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18);      _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);      // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage     // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)     // ICR = leverage / (leverage - 1)      // ICR = VC value of collateral / debt      // debt = VC value of collateral / ICR.     // debt = VC value of collateral * (leverage - 1) / leverage      uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);      yusdToken.mint(address(this), _additionalYUSDDebt);     yusdToken.approve(address(router), _additionalYUSDDebt);     // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and      // reward balance will be sent to the user if wrapped asset.      IERC20 erc20Token = IERC20(_token);     uint256 balanceBefore = erc20Token.balanceOf(address(activePool));     _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);     require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent"); }   // amounts should be a uint array giving the amount of each collateral // to be transferred in in order of the current whitelist // Should be called *after* collateral has been already sent to the active pool // Should confirm _colls, is valid collateral prior to calling this function _openTroveInternal(     address _troveOwner,     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     uint256 _totalYUSDDebtFromLever,     address _upperHint,     address _lowerHint,     address[] memory _colls,     uint256[] memory _amounts ) internal {     LocalVariables_openTrove memory vars;      vars.isRecoveryMode = _checkRecoveryMode();      ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);     _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);      vars.netDebt = _YUSDAmount;      // For every collateral type in, calculate the VC and get the variable fee     vars.VC = _getVC(_colls, _amounts);      if (!vars.isRecoveryMode) {         // when not in recovery mode, add in the 0.5% fee         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             _YUSDAmount,             vars.VC, // here it is just VC in, which is always larger than YUSD amount             _maxFeePercentage         );         _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));     }      // Add in variable fee. Always present, even in recovery mode.     vars.YUSDFee = vars.YUSDFee.add(         _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)     );      // Adds total fees to netDebt     vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee      _requireAtLeastMinNetDebt(vars.netDebt);     // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.     // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.     vars.compositeDebt = _getCompositeDebt(vars.netDebt);      vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);     if (vars.isRecoveryMode) {         _requireICRisAboveCCR(vars.ICR);     } else {         _requireICRisAboveMCR(vars.ICR);         vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase         _requireNewTCRisAboveCCR(vars.newTCR);     }      // Set the trove struct's properties     contractsCache.troveManager.setTroveStatus(_troveOwner, 1);      contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);     contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);      contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);      contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);      sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);     vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);     emit TroveCreated(_troveOwner, vars.arrayIndex);      contractsCache.activePool.receiveCollateral(_colls, _amounts);      _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         _troveOwner,         _YUSDAmount.sub(_totalYUSDDebtFromLever),         vars.netDebt     );      // Move the YUSD gas compensation to the Gas Pool     _withdrawYUSD(         contractsCache.activePool,         contractsCache.yusdToken,         gasPoolAddress,         YUSD_GAS_COMPENSATION,         YUSD_GAS_COMPENSATION     );      emit TroveUpdated(         _troveOwner,         vars.compositeDebt,         _colls,         _amounts,         BorrowerOperation.openTrove     );     emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee); }   // add collateral to trove. Calls _adjustTrove with correct params.  function addColl(     address[] calldata _collsIn,     uint256[] calldata _amountsIn,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, params._amountsIn);     _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);     _adjustTrove(params); }   // add collateral to trove. Calls _adjustTrove with correct params. function addCollLeverUp(     address[] memory _collsIn,     uint256[] memory _amountsIn,     uint256[] memory _leverages,     uint256[] memory _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint,      uint256 _maxFeePercentage ) external override nonReentrant {     AdjustTrove_Params memory params;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._maxFeePercentage = _maxFeePercentage;     uint256 collsLen = _collsIn.length;      // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     // Must check that other passed in arrays are correct length     _requireLengthsEqual(collsLen, _leverages.length);     _requireLengthsEqual(collsLen, _maxSlippages.length);     _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself      uint additionalTokenAmount;     uint additionalYUSDDebt;     uint totalYUSDDebtFromLever;     for (uint256 i; i &lt; collsLen; ++i) {         if (_leverages[i] != 0) {             (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(                 _collsIn[i],                 _amountsIn[i],                 _leverages[i],                 _maxSlippages[i]             );             // Transfer into active pool, non levered amount.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);             // additional token amount was set to the original amount * leverage.              _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);             totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);         } else {             // Otherwise skip and do normal transfer that amount into active pool.              _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);         }     }     _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);     params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;      params._YUSDChange = _YUSDAmount;     params._isDebtIncrease = true;      params._collsIn = _collsIn;     params._amountsIn = _amountsIn;     _adjustTrove(params); }  // Withdraw collateral from a trove. Calls _adjustTrove with correct params.  function withdrawColl(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;      // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(params._collsOut, params._amountsOut);     _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself      _adjustTrove(params); }  // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function withdrawYUSD(     uint256 _maxFeePercentage,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._maxFeePercentage = _maxFeePercentage;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = true;     _adjustTrove(params); }  // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly.  // Calls _adjustTrove with correct params.  function repayYUSD(     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint ) external override nonReentrant {     AdjustTrove_Params memory params;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isDebtIncrease = false;     _adjustTrove(params); }  // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params. function adjustTrove(     address[] calldata _collsIn,     uint256[] memory _amountsIn,     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256 _YUSDChange,     bool _isDebtIncrease,     address _upperHint,     address _lowerHint,     uint256 _maxFeePercentage ) external override nonReentrant {     // check that all _collsIn collateral types are in the whitelist     _requireValidDepositCollateral(_collsIn, _amountsIn);     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut     _requireNoDuplicateColls(_collsIn);     _requireNoDuplicateColls(_collsOut);      // pull in deposit collateral     _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);     uint256[] memory maxSlippages = new uint256[](0);      AdjustTrove_Params memory params = AdjustTrove_Params(         _collsIn,         _amountsIn,         _collsOut,         _amountsOut,         maxSlippages,         _YUSDChange,         0,         _isDebtIncrease,         false,         _upperHint,         _lowerHint,         _maxFeePercentage     );      _adjustTrove(params); }  /*  * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.  * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in  *  * Should be called after the collsIn has been sent to ActivePool  */ function _adjustTrove(AdjustTrove_Params memory params) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);     LocalVariables_adjustTrove memory vars;      bool isRecoveryMode = _checkRecoveryMode();      if (params._isDebtIncrease) {         _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);         _requireNonZeroDebtChange(params._YUSDChange);     }      // Checks that at least one array is non-empty, and also that at least one value is 1.      _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);     _requireTroveisActive(contractsCache.troveManager, msg.sender);      contractsCache.troveManager.applyPendingRewards(msg.sender);     vars.netDebtChange = params._YUSDChange;      vars.VCin = _getVC(params._collsIn, params._amountsIn);     vars.VCout = _getVC(params._collsOut, params._amountsOut);      if (params._isDebtIncrease) {         vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);     } else {         vars.maxFeePercentageFactor = vars.VCin;     }      // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee     if (params._isDebtIncrease &amp;&amp; !isRecoveryMode) {         vars.YUSDFee = _triggerBorrowingFee(             contractsCache.troveManager,             contractsCache.yusdToken,             params._YUSDChange,             vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.             params._maxFeePercentage         );         // passed in max fee minus actual fee percent applied so far         params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor));          vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee     }      // get current portfolio in trove     (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);     // current VC based on current portfolio and latest prices     vars.currVC = _getVC(vars.currAssets, vars.currAmounts);      // get new portfolio in trove after changes. Will error if invalid changes:     (vars.newAssets, vars.newAmounts) = _getNewPortfolio(         vars.currAssets,         vars.currAmounts,         params._collsIn,         params._amountsIn,         params._collsOut,         params._amountsOut     );     // new VC based on new portfolio and latest prices     vars.newVC = _getVC(vars.newAssets, vars.newAmounts);      vars.isCollIncrease = vars.newVC &gt; vars.currVC;     vars.collChange = 0;     if (vars.isCollIncrease) {         vars.collChange = (vars.newVC).sub(vars.currVC);     } else {         vars.collChange = (vars.currVC).sub(vars.newVC);     }      vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);      if (params._collsIn.length != 0) {         vars.variableYUSDFee = _getTotalVariableDepositFee(                 params._collsIn,                 params._amountsIn,                 vars.VCin,                 vars.VCout,                 vars.maxFeePercentageFactor,                 params._maxFeePercentage,                 contractsCache         );     }      // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment     vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);      vars.debt = vars.debt.add(vars.variableYUSDFee);      vars.newICR = _getNewICRFromTroveChange(vars.newVC,         vars.debt, // with variableYUSDFee already added.          vars.netDebtChange,         params._isDebtIncrease      );      // Check the adjustment satisfies all conditions for the current system mode     _requireValidAdjustmentInCurrentMode(         isRecoveryMode,         params._amountsOut,         params._isDebtIncrease,         vars     );      // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD     if (!params._isUnlever &amp;&amp; !params._isDebtIncrease &amp;&amp; params._YUSDChange != 0) {         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));         _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);     }      if (params._collsIn.length != 0) {         contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);     }      (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(         contractsCache.troveManager,         msg.sender,         vars.newAssets,         vars.newAmounts,         vars.newVC,         vars.netDebtChange,         params._isDebtIncrease,          vars.variableYUSDFee     );      contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);      // Re-insert trove in to the sorted list     sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);      emit TroveUpdated(         msg.sender,         vars.newDebt,         vars.newAssets,         vars.newAmounts,         BorrowerOperation.adjustTrove     );     emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);      // in case of unlever up     if (params._isUnlever) {         // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);          // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified.          // if not enough coll sold for YUSD, must cover from user balance         _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));         _requireValidYUSDRepayment(vars.debt, params._YUSDChange);         _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);         _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);     } else {         // Use the unmodified _YUSDChange here, as we don't send the fee to the user         _moveYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case             params._isDebtIncrease,             vars.netDebtChange         );          // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt         _withdrawYUSD(             contractsCache.activePool,             contractsCache.yusdToken,             msg.sender,             0,             vars.variableYUSDFee         );          // transfer withdrawn collateral to msg.sender from ActivePool         activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);     } }  // internal function for minting yusd at certain leverage and max slippage, and then performing  // swap with whitelist's approved router.  function _singleUnleverUp(address _token,      uint256 _amount,      uint256 _maxSlippage)      internal     returns (uint256 _finalYUSDAmount) {     require(_maxSlippage &lt;= 1e18, "WrongSlippage");     // if wrapped token, then does i t automatically transfer to active pool?     // It should actually transfer to the owner, who will have bOps pre approved     // cause of original approve     IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));     // then calculate value amount of expected YUSD output based on amount of token to sell      uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);     uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);     IERC20 yusdTokenCached = yusdToken;     require(IERC20(_token).approve(address(router), valueOfCollateral));     uint256 balanceBefore = yusdToken.balanceOf(address(this));     _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);     require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever"); }  // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract  // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user.  function _unleverColls(     IActivePool _activePool,      address[] memory _colls,      uint256[] memory _amounts,      uint256[] memory _maxSlippages ) internal {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         if (_maxSlippages[i] != 0) {             _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);             _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);         } else {             _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);         }     } }   // Withdraw collateral from a trove. Calls _adjustTrove with correct params. // Specifies amount of collateral to withdraw and how much debt to repay,  // Can withdraw coll and *only* pay back debt using this function. Will take  // the collateral given and send YUSD back to user. Then they will pay back debt // first transfers amount of collateral from active pool then sells.  // calls _singleUnleverUp() to perform the swaps using the wrappers.  // should have no fees.  function withdrawCollUnleverUp(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages,     uint256 _YUSDAmount,     address _upperHint,     address _lowerHint     ) external override nonReentrant {     // check that all _collsOut collateral types are in the whitelist     _requireValidDepositCollateral(_collsOut, _amountsOut);     _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself     _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);      AdjustTrove_Params memory params;      params._collsOut = _collsOut;     params._amountsOut = _amountsOut;     params._maxSlippages = _maxSlippages;     params._YUSDChange = _YUSDAmount;     params._upperHint = _upperHint;     params._lowerHint = _lowerHint;     params._isUnlever = true;      _adjustTrove(params); }  function closeTroveUnlever(     address[] calldata _collsOut,     uint256[] calldata _amountsOut,     uint256[] calldata _maxSlippages ) external override nonReentrant {     CloseTrove_Params memory params = CloseTrove_Params({         _collsOut: _collsOut,         _amountsOut: _amountsOut,         _maxSlippages: _maxSlippages,         _isUnlever: true         }     );     _closeTrove(params); }  function closeTrove() external override nonReentrant{     CloseTrove_Params memory params; // default false     _closeTrove(params); }  /**   * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the   * collateral to the owner, and repaying the debt.  * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last.   */ function _closeTrove(     CloseTrove_Params memory params     ) internal {     ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);      _requireTroveisActive(contractsCache.troveManager, msg.sender);     _requireNotInRecoveryMode();      contractsCache.troveManager.applyPendingRewards(msg.sender);      uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC     (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(         msg.sender     );     uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);      // if unlever, will do extra.     uint finalYUSDAmount;     uint YUSDAmount;     if (params._isUnlever) {         // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router.          _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);         // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.     }      // do check after unlever (if applies)     _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);     _requireNewTCRisAboveCCR(newTCR);      contractsCache.troveManager.removeStake(msg.sender);     contractsCache.troveManager.closeTrove(msg.sender);      address[] memory finalColls;     uint256[] memory finalAmounts;      emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);      // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));     _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);      // Send the collateral back to the user     // Also sends the rewards     if (!params._isUnlever) {         contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);     } }  /**  * Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode  * to do all necessary interactions. Can delete if this is the only way to reduce size.  */ function claimCollateral() external override {     // send collateral from CollSurplus Pool to owner     collSurplusPool.claimColl(msg.sender); }  // --- Helper functions ---  /**   * Gets the variable deposit fee from the whitelist calculation. Multiplies the   * fee by the vc of the collateral.  */ function _getTotalVariableDepositFee(     address[] memory _tokensIn,     uint256[] memory _amountsIn,     uint256 _VCin,     uint256 _VCout,     uint256 _maxFeePercentageFactor,      uint256 _maxFeePercentage,     ContractsCache memory _contractsCache ) internal returns (uint256 YUSDFee) {     if (_VCin == 0) {         return 0;     }     DepositFeeCalc memory vars;     // active pool total VC at current state.     vars.systemTotalVC = _contractsCache.activePool.getVC().add(         defaultPool.getVC()     );     // active pool total VC post adding and removing all collaterals     uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);     uint256 whitelistFee;     uint256 tokensLen = _tokensIn.length;     for (uint256 i; i &lt; tokensLen; ++i) {         vars.token = _tokensIn[i];         // VC value of collateral of this type inputted         vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);          // total value in VC of this collateral in active pool (post adding input)         vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(             defaultPool.getCollateralVC(vars.token)         );          // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)         whitelistFee =                  whitelist.getFeeAndUpdate(                     vars.token,                     vars.collateralInputVC,                     vars.systemCollateralVC,                     vars.systemTotalVC,                     activePoolVCPost                 );         if (_isBeforeFeeBootstrapPeriod()) {             whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%         }          vars.collateralYUSDFee = vars.collateralInputVC             .mul(whitelistFee).div(1e18);          YUSDFee = YUSDFee.add(vars.collateralYUSDFee);     }     _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);     _triggerDepositFee(_contractsCache.yusdToken, YUSDFee); }  // Transfer in collateral and send to ActivePool // (where collateral is held) function _transferCollateralsIntoActivePool(     address _from,     address[] memory _colls,     uint256[] memory _amounts ) internal {     uint256 amountsLen = _amounts.length;     for (uint256 i; i &lt; amountsLen; ++i) {         address collAddress = _colls[i];         uint256 amount = _amounts[i];         _singleTransferCollateralIntoActivePool(             _from,             collAddress,             amount         );     } }  // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly. function _singleTransferCollateralIntoActivePool(     address _from,     address _coll,     uint256 _amount ) internal {     if (whitelist.isWrapped(_coll)) {         // If wrapped asset then it wraps it and sends the wrapped version to the active pool,          // and updates reward balance to the new owner.          IWAsset(_coll).wrap(_amount, _from, address(activePool), _from);      } else {         require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");     } }  /**  * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.  */ function _triggerBorrowingFee(     ITroveManager _troveManager,     IYUSDToken _yusdToken,     uint256 _YUSDAmount,     uint256 _maxFeePercentageFactor,     uint256 _maxFeePercentage ) internal returns (uint256) {     _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable     uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);      _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);      // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, YUSDFee);     return YUSDFee; }  function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {     // Send fee to sYETI contract     _yusdToken.mint(sYETIAddress, _YUSDFee); }  // Update trove's coll and debt based on whether they increase or decrease function _updateTroveFromAdjustment(     ITroveManager _troveManager,     address _borrower,     address[] memory _finalColls,     uint256[] memory _finalAmounts,     uint256 _newVC,     uint256 _debtChange,     bool _isDebtIncrease,      uint256 _variableYUSDFee ) internal returns (uint256, uint256) {     uint256 newDebt;     _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);     if (_isDebtIncrease) { // if debt increase, increase by both amounts        newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));     } else {         if (_debtChange &gt; _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease              newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed         } else { // otherwise increase by opposite subtraction             newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed         }     }      return (_newVC, newDebt); }  // gets the finalColls and finalAmounts after all deposits and withdrawals have been made // this function will error if trying to deposit a collateral that is not in the whitelist // or trying to withdraw more collateral of any type that is not in the trove function _getNewPortfolio(     address[] memory _initialTokens,     uint256[] memory _initialAmounts,     address[] memory _tokensIn,     uint256[] memory _amountsIn,     address[] memory _tokensOut,     uint256[] memory _amountsOut ) internal view returns (address[] memory, uint256[] memory) {     _requireValidDepositCollateral(_tokensIn, _amountsIn);     _requireValidDepositCollateral(_tokensOut, _amountsOut);      // Initial Colls + Input Colls     newColls memory cumulativeIn = _sumColls(         _initialTokens,         _initialAmounts,         _tokensIn,         _amountsIn     );      newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);     return (newPortfolio.tokens, newPortfolio.amounts); }  // Moves the YUSD around based on whether it is an increase or decrease in debt. function _moveYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _borrower,     uint256 _YUSDChange,     bool _isDebtIncrease,     uint256 _netDebtChange ) internal {     if (_isDebtIncrease) {         _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);     } else {         _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);     } }  // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee) function _withdrawYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSDAmount,     uint256 _netDebtIncrease ) internal {     _activePool.increaseYUSDDebt(_netDebtIncrease);     _yusdToken.mint(_account, _YUSDAmount); }  // Burn the specified amount of YUSD from _account and decreases the total active debt function _repayYUSD(     IActivePool _activePool,     IYUSDToken _yusdToken,     address _account,     uint256 _YUSD ) internal {     _activePool.decreaseYUSDDebt(_YUSD);     _yusdToken.burn(_account, _YUSD); }  // --- 'Require' wrapper functions ---  function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {     uint256 collsLen = _colls.length;     _requireLengthsEqual(collsLen, _amounts.length);     for (uint256 i; i &lt; collsLen; ++i) {         require(whitelist.getIsActive(_colls[i]), "BO:BadColl");         require(_amounts[i] != 0, "BO:NoAmounts");     } }  function _requireNonZeroAdjustment(     uint256[] memory _amountsIn,     uint256[] memory _amountsOut,     uint256 _YUSDChange ) internal pure {     require(         _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,         "BO:0Adjust"     ); }  function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {     uint256 arrLen = arr.length;     for (uint256 i; i &lt; arrLen; ++i) {         if (arr[i] != 0) {             return true;         }     }     return false; }  function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {     return block.timestamp &lt; deploymentTime + BOOTSTRAP_PERIOD; // won't overflow }  function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {     require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive"); }  function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {     require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive"); }  function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {     require(_YUSDChange != 0, "BO:NoDebtChange"); }  function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)     internal     pure {     uint256 colls1Len = _colls1.length;     uint256 colls2Len = _colls2.length;     for (uint256 i; i &lt; colls1Len; ++i) {         for (uint256 j; j &lt; colls2Len; j++) {             require(_colls1[i] != _colls2[j], "BO:OverlapColls");         }     } }  function _requireNoDuplicateColls(address[] memory _colls) internal pure {     uint256 collsLen = _colls.length;     for (uint256 i; i &lt; collsLen; ++i) {         for (uint256 j = i.add(1); j &lt; collsLen; j++) {             require(_colls[i] != _colls[j], "BO:OverlapColls");         }     } }  function _requireNotInRecoveryMode() internal view {     require(!_checkRecoveryMode(), "BO:InRecMode"); }  function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {     require(         !_arrayIsNonzero(_amountOut),         "BO:InRecMode"     ); }  // Function require length nonzero, used to save contract size on revert strings.  function _requireLengthNonzero(uint256 length) internal pure {     require(length != 0, "BOps:Len0"); }  // Function require length equal, used to save contract size on revert strings. function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {     require(length1 == length2, "BO:LenMismatch"); }  function _requireValidAdjustmentInCurrentMode(     bool _isRecoveryMode,     uint256[] memory _collWithdrawal,     bool _isDebtIncrease,     LocalVariables_adjustTrove memory _vars ) internal view {     /*      *In Recovery Mode, only allow:      *      * - Pure collateral top-up      * - Pure debt repayment      * - Collateral top-up with debt repayment      * - A debt increase combined with a collateral top-up which makes the ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).      *      * In Normal Mode, ensure:      *      * - The new ICR is above MCR      * - The adjustment won't pull the TCR below CCR      */     if (_isRecoveryMode) {         _requireNoCollWithdrawal(_collWithdrawal);         if (_isDebtIncrease) {             _requireICRisAboveCCR(_vars.newICR);             _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);         }     } else {         // if Normal Mode         _requireICRisAboveMCR(_vars.newICR);         _vars.newTCR = _getNewTCRFromTroveChange(             _vars.collChange,             _vars.isCollIncrease,             _vars.netDebtChange,             _isDebtIncrease         );         _requireNewTCRisAboveCCR(_vars.newTCR);     } }  function _requireICRisAboveMCR(uint256 _newICR) internal pure {     require(         _newICR &gt;= MCR,         "BO:ReqICR&gt;MCR"     ); }  function _requireICRisAboveCCR(uint256 _newICR) internal pure {     require(_newICR &gt;= CCR, "BO:ReqICR&gt;CCR"); }  function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {     require(         _newICR &gt;= _oldICR,         "BO:RecMode:ICR&lt;oldICR"     ); }  function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {     require(         _newTCR &gt;= CCR,         "BO:ReqTCR&gt;CCR"     ); }  function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {     require(         _netDebt &gt;= MIN_NET_DEBT,         "BO:netDebt&lt;2000"     ); }  function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {     require(         _debtRepayment &lt;= _currentDebt.sub(YUSD_GAS_COMPENSATION),         "BO:InvalidYUSDRepay"     ); }  function _requireSufficientYUSDBalance(     IYUSDToken _yusdToken,     address _borrower,     uint256 _debtRepayment ) internal view {     require(         _yusdToken.balanceOf(_borrower) &gt;= _debtRepayment,         "BO:InsuffYUSDBal"     ); }  function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)     internal     pure {     // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%     if (_maxFeePercentage &gt; DECIMAL_PRECISION || (!_isRecoveryMode &amp;&amp; _maxFeePercentage &lt; BORROWING_FEE_FLOOR)) {         revert("BO:InvalidMaxFee");     } }  // checks lengths are all good and that all passed in routers are valid routers // function _requireValidRouterParams( //     address[] memory _finalRoutedColls, //     uint[] memory _amounts, //     uint[] memory _minSwapAmounts, //     IYetiRouter[] memory _routers) internal view { //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch"); //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch"); //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch"); //     for (uint256 i; i &lt; _routers.length; ++i) { //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router"); //     } // }  // // requires that avax indices are in order // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure { //     for (uint256 i; i &lt; _indices.length - 1; ++i) { //         require(_indices[i] &lt; _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order"); //     } // }   // --- ICR and TCR getters ---  // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards. function _getNewICRFromTroveChange(     uint256 _newVC,     uint256 _debt,     uint256 _debtChange,     bool _isDebtIncrease ) internal pure returns (uint256) {     uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);      uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);     return newICR; }  function _getNewTCRFromTroveChange(     uint256 _collChange,     bool _isCollIncrease,     uint256 _debtChange,     bool _isDebtIncrease ) internal view returns (uint256) {     uint256 totalColl = getEntireSystemColl();     uint256 totalDebt = getEntireSystemDebt();      totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);     totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);      uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);     return newTCR; }  function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {     return _getCompositeDebt(_debt); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IYetiRouter.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/ReentrancyGuard.sol";
import "./Interfaces/IWAsset.sol";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.
 */

 /**
   A summary of Lever Up:
   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and
   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.
   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for
   token A by using some router strategy, returning a little under $2000 token A to put back in the
   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if
   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.
  */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {
    using SafeMath for uint256;
    string public constant NAME = "BorrowerOperations";

    // --- Connected contract declarations ---

    ITroveManager internal troveManager;

    address internal stabilityPoolAddress;

    address internal gasPoolAddress;

    ICollSurplusPool internal collSurplusPool;

    ISYETI internal sYETI;
    address internal sYETIAddress;

    IYUSDToken internal yusdToken;

    uint internal constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves internal sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 systemCollateralVC;
        uint256 collateralInputVC;
        uint256 systemTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    "CompilerError: Stack too deep". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        uint256 _YUSDChange;
        uint256 _totalYUSDDebtFromLever;
        bool _isDebtIncrease;
        bool _isUnlever;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
        uint256 newTCR;
        bool isRecoveryMode;
    }

    struct CloseTrove_Params {
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256[] _maxSlippages;
        bool _isUnlever;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        require(MIN_NET_DEBT != 0, "BO:MIN_NET_DEBT==0");

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---

    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] calldata _colls,
        uint256[] calldata _amounts
    ) external override nonReentrant {
        _requireLengthNonzero(_amounts.length);
        _requireValidDepositCollateral(_colls, _amounts);
        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls

        // transfer collateral into ActivePool
        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            0,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount
    // of that token that would be at the specific collateralization ratio. Mints YUSD
    // according to the price of the token and the amount. Calls LeverUp.sol's
    // function to perform the swap through a router or our special staked tokens, depending
    // on the token. Then opens a trove with the new collateral from the swap, ensuring that
    // the amount is enough to cover the debt. There is no new debt taken out from the trove,
    // and the amount minted previously is attributed to this trove. Reverts if the swap was
    // not able to get the correct amount of collateral according to slippage passed in.
    // _leverage is like 11e18 for 11x. 
    function openTroveLeverUp(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts, 
        uint256[] memory _leverages,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant{
        uint256 collsLen = _colls.length;
        _requireLengthNonzero(collsLen);
        _requireValidDepositCollateral(_colls, _amounts);
        // Must check additional passed in arrays
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(_colls);
        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _colls[i],
                    _amounts[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
                // additional token amount was set to the original amount * leverage. 
                _amounts[i] = additionalTokenAmount.add(_amounts[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        
        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            totalYUSDDebtFromLever,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleLeverUp(address _token, 
        uint256 _amount, 
        uint256 _leverage, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {
        require(_leverage > 1e18, "WrongLeverage");
        require(_maxSlippage <= 1e18, "WrongSlippage");
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.
        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); 
        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);

        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage
        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)
        // ICR = leverage / (leverage - 1)
        
        // ICR = VC value of collateral / debt 
        // debt = VC value of collateral / ICR.
        // debt = VC value of collateral * (leverage - 1) / leverage

        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        
        yusdToken.mint(address(this), _additionalYUSDDebt);
        yusdToken.approve(address(router), _additionalYUSDDebt);
        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and 
        // reward balance will be sent to the user if wrapped asset. 
        IERC20 erc20Token = IERC20(_token);
        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));
        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);
        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), "BO:RouteLeverUpNotSent");
    }


    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called *after* collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        uint256 _totalYUSDDebtFromLever,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        vars.isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!vars.isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }

        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (vars.isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(vars.newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount.sub(_totalYUSDDebtFromLever),
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] calldata _collsIn,
        uint256[] calldata _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, params._amountsIn);
        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);
        _adjustTrove(params);
    }


    // add collateral to trove. Calls _adjustTrove with correct params.
    function addCollLeverUp(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        uint256[] memory _leverages,
        uint256[] memory _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;
        uint256 collsLen = _collsIn.length;

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        // Must check that other passed in arrays are correct length
        _requireLengthsEqual(collsLen, _leverages.length);
        _requireLengthsEqual(collsLen, _maxSlippages.length);
        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself

        uint additionalTokenAmount;
        uint additionalYUSDDebt;
        uint totalYUSDDebtFromLever;
        for (uint256 i; i < collsLen; ++i) {
            if (_leverages[i] != 0) {
                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(
                    _collsIn[i],
                    _amountsIn[i],
                    _leverages[i],
                    _maxSlippages[i]
                );
                // Transfer into active pool, non levered amount. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
                // additional token amount was set to the original amount * leverage. 
                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);
                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);
            } else {
                // Otherwise skip and do normal transfer that amount into active pool. 
                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);
            }
        }
        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);
        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;

        params._YUSDChange = _YUSDAmount;
        params._isDebtIncrease = true;

        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;

        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(params._collsOut, params._amountsOut);
        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself

        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override nonReentrant {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] calldata _collsIn,
        uint256[] memory _amountsIn,
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override nonReentrant {
        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn, _amountsIn);
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsIn);
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);
        uint256[] memory maxSlippages = new uint256[](0);

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            maxSlippages,
            _YUSDChange,
            0,
            _isDebtIncrease,
            false,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }

    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        // Checks that at least one array is non-empty, and also that at least one value is 1. 
        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        
        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }

        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        if (params._collsIn.length != 0) {
            vars.variableYUSDFee = _getTotalVariableDepositFee(
                    params._collsIn,
                    params._amountsIn,
                    vars.VCin,
                    vars.VCout,
                    vars.maxFeePercentageFactor,
                    params._maxFeePercentage,
                    contractsCache
            );
        }

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length != 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // in case of unlever up
        if (params._isUnlever) {
            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);

            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. 
            // if not enough coll sold for YUSD, must cover from user balance
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));
            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);
            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);
        } else {
            // Use the unmodified _YUSDChange here, as we don't send the fee to the user
            _moveYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case
                params._isDebtIncrease,
                vars.netDebtChange
            );

            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
            _withdrawYUSD(
                contractsCache.activePool,
                contractsCache.yusdToken,
                msg.sender,
                0,
                vars.variableYUSDFee
            );

            // transfer withdrawn collateral to msg.sender from ActivePool
            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);
        }
    }

    // internal function for minting yusd at certain leverage and max slippage, and then performing 
    // swap with whitelist's approved router. 
    function _singleUnleverUp(address _token, 
        uint256 _amount, 
        uint256 _maxSlippage) 
        internal
        returns (uint256 _finalYUSDAmount) {
        require(_maxSlippage <= 1e18, "WrongSlippage");
        // if wrapped token, then does i t automatically transfer to active pool?
        // It should actually transfer to the owner, who will have bOps pre approved
        // cause of original approve
        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));
        // then calculate value amount of expected YUSD output based on amount of token to sell

        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);
        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);
        IERC20 yusdTokenCached = yusdToken;
        require(IERC20(_token).approve(address(router), valueOfCollateral));
        uint256 balanceBefore = yusdToken.balanceOf(address(this));
        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);
        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), "BO:YUSDNotSentUnLever");
    }

    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract 
    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. 
    function _unleverColls(
        IActivePool _activePool, 
        address[] memory _colls, 
        uint256[] memory _amounts, 
        uint256[] memory _maxSlippages
    ) internal {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            if (_maxSlippages[i] != 0) {
                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);
                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);
            } else {
                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);
            }
        }
    }


    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.
    // Specifies amount of collateral to withdraw and how much debt to repay, 
    // Can withdraw coll and *only* pay back debt using this function. Will take 
    // the collateral given and send YUSD back to user. Then they will pay back debt
    // first transfers amount of collateral from active pool then sells. 
    // calls _singleUnleverUp() to perform the swaps using the wrappers. 
    // should have no fees. 
    function withdrawCollUnleverUp(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
        ) external override nonReentrant {
        // check that all _collsOut collateral types are in the whitelist
        _requireValidDepositCollateral(_collsOut, _amountsOut);
        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself
        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);

        AdjustTrove_Params memory params; 
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._maxSlippages = _maxSlippages;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isUnlever = true;

        _adjustTrove(params);
    }

    function closeTroveUnlever(
        address[] calldata _collsOut,
        uint256[] calldata _amountsOut,
        uint256[] calldata _maxSlippages
    ) external override nonReentrant {
        CloseTrove_Params memory params = CloseTrove_Params({
            _collsOut: _collsOut,
            _amountsOut: _amountsOut,
            _maxSlippages: _maxSlippages,
            _isUnlever: true
            }
        );
        _closeTrove(params);
    }

    function closeTrove() external override nonReentrant{
        CloseTrove_Params memory params; // default false
        _closeTrove(params);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. 
     */
    function _closeTrove(
        CloseTrove_Params memory params
        ) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireTroveisActive(contractsCache.troveManager, msg.sender);
        _requireNotInRecoveryMode();

        contractsCache.troveManager.applyPendingRewards(msg.sender);

        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(
            msg.sender
        );
        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        // if unlever, will do extra.
        uint finalYUSDAmount;
        uint YUSDAmount;
        if (params._isUnlever) {
            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. 
            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);
            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.
        }

        // do check after unlever (if applies)
        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        contractsCache.troveManager.removeStake(msg.sender);
        contractsCache.troveManager.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        if (!params._isUnlever) {
            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);
        }
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     * to do all necessary interactions. Can delete if this is the only way to reduce size.
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.systemTotalVC = _contractsCache.activePool.getVC().add(
            defaultPool.getVC()
        );
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;
        uint256 tokensLen = _tokensIn.length;
        for (uint256 i; i < tokensLen; ++i) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(
                defaultPool.getCollateralVC(vars.token)
            );

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.systemCollateralVC,
                        vars.systemTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        uint256 amountsLen = _amounts.length;
        for (uint256 i; i < amountsLen; ++i) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            _singleTransferCollateralIntoActivePool(
                _from,
                collAddress,
                amount
            );
        }
    }

    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.
    function _singleTransferCollateralIntoActivePool(
        address _from,
        address _coll,
        uint256 _amount
    ) internal {
        if (whitelist.isWrapped(_coll)) {
            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, 
            // and updates reward balance to the new owner. 
            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); 
        } else {
            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), "BO:TransferCollsFailed");
        }
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory, uint256[] memory) {
        _requireValidDepositCollateral(_tokensIn, _amountsIn);
        _requireValidDepositCollateral(_tokensOut, _amountsOut);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {
        uint256 collsLen = _colls.length;
        _requireLengthsEqual(collsLen, _amounts.length);
        for (uint256 i; i < collsLen; ++i) {
            require(whitelist.getIsActive(_colls[i]), "BO:BadColl");
            require(_amounts[i] != 0, "BO:NoAmounts");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            "BO:0Adjust"
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        uint256 arrLen = arr.length;
        for (uint256 i; i < arrLen; ++i) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        require(_troveManager.isTroveActive(_borrower), "BO:TroveInactive");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        require(!_troveManager.isTroveActive(_borrower), "BO:TroveActive");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange != 0, "BO:NoDebtChange");
    }

    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)
        internal
        pure
    {
        uint256 colls1Len = _colls1.length;
        uint256 colls2Len = _colls2.length;
        for (uint256 i; i < colls1Len; ++i) {
            for (uint256 j; j < colls2Len; j++) {
                require(_colls1[i] != _colls2[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        uint256 collsLen = _colls.length;
        for (uint256 i; i < collsLen; ++i) {
            for (uint256 j = i.add(1); j < collsLen; j++) {
                require(_colls[i] != _colls[j], "BO:OverlapColls");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), "BO:InRecMode");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            "BO:InRecMode"
        );
    }

    // Function require length nonzero, used to save contract size on revert strings. 
    function _requireLengthNonzero(uint256 length) internal pure {
        require(length != 0, "BOps:Len0");
    }

    // Function require length equal, used to save contract size on revert strings.
    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {
        require(length1 == length2, "BO:LenMismatch");
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            "BO:ReqICR>MCR"
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, "BO:ReqICR>CCR");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            "BO:RecMode:ICR<oldICR"
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            "BO:ReqTCR>CCR"
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            "BO:netDebt<2000"
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            "BO:InvalidYUSDRepay"
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            "BO:InsuffYUSDBal"
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%
        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {
            revert("BO:InvalidMaxFee");
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    // function _requireValidRouterParams(
    //     address[] memory _finalRoutedColls,
    //     uint[] memory _amounts,
    //     uint[] memory _minSwapAmounts,
    //     IYetiRouter[] memory _routers) internal view {
    //     require(_finalRoutedColls.length == _amounts.length,  "_requireValidRouterParams: _finalRoutedColls length mismatch");
    //     require(_amounts.length == _routers.length, "_requireValidRouterParams: _routers length mismatch");
    //     require(_amounts.length == _minSwapAmounts.length, "_minSwapAmounts: finalRoutedColls length mismatch");
    //     for (uint256 i; i < _routers.length; ++i) {
    //         require(whitelist.isValidRouter(address(_routers[i])), "_requireValidRouterParams: not a valid router");
    //     }
    // }

    // // requires that avax indices are in order
    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
    //     for (uint256 i; i < _indices.length - 1; ++i) {
    //         require(_indices[i] < _indices[i.add(1)], "_requireRouterAVAXIndicesInOrder: indices out of order");
    //     }
    // }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

