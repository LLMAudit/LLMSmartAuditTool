[2024-23-08 10:55:14 INFO] **[Preprocessing]**

**ChatDev Starts** (20240823105514)

**Timestamp**: 20240823105514

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}


**project_name**: RealWorld_BA_66_StabilityPool

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_66_StabilityPool_RealWord_20240823105514.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-23-08 10:55:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = "StabilityPool";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         */\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- \'require\' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:15 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-23-08 10:55:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24616
completion_tokens: 1
total_tokens: 24617
cost: $-1.000000


[2024-23-08 10:55:18 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Certainly

[2024-23-08 10:55:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n    string public constant NAME = "StabilityPool";\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n    // --- Data structures ---\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n    uint256 public constant SCALE_FACTOR = 1e9;\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n    // --- Events ---\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 newBalance);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n    // --- Contract setters ---\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n        _renounceOwnership();\n    }\n    // --- Getters for public variables. Required by IPool interface --- \n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n    // --- External Depositor Functions ---\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n        _triggerYETIIssuance(communityIssuanceCached);\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n        _triggerYETIIssuance(communityIssuanceCached);\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n    // --- YETI issuance functions ---\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n        return YETIPerUnitStaked;\n    }\n    // --- Liquidation functions ---\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n        _triggerYETIIssuance(communityIssuance);\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n    // --- Offset helper functions ---\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n    }\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n    // --- Reward calculator functions for depositor and front end ---\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        return _calculateGains(initialDeposit, snapshots);\n    }\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n        address frontEndTag = deposits[_depositor].frontEndTag;\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        return YETIGain;\n    }\n    // --- Compounded deposit and compounded front end stake ---\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         /\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n        return compoundedStake;\n    }\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n    // --- External Front End functions ---\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n    // --- Stability Pool Deposit Functionality ---\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n        address[] memory allColls = whitelist.getValidCollateral();\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n    // --- \'require\' functions ---\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n    string public constant NAME = "StabilityPool";\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n    // --- Data structures ---\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n    uint256 public constant SCALE_FACTOR = 1e9;\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n    // --- Events ---\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n    // --- Contract setters ---\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n        _renounceOwnership();\n    }\n    // --- Getters for public variables. Required by IPool interface --- \n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n    // --- External Depositor Functions ---\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n        _triggerYETIIssuance(communityIssuanceCached);\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n        _triggerYETIIssuance(communityIssuanceCached);\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n    // --- YETI issuance functions ---\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n        return YETIPerUnitStaked;\n    }\n    // --- Liquidation functions ---\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n        _triggerYETIIssuance(communityIssuance);\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n    // --- Offset helper functions ---\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n    }\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n    // --- Reward calculator functions for depositor and front end ---\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        return _calculateGains(initialDeposit, snapshots);\n    }\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n        address frontEndTag = deposits[_depositor].frontEndTag;\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        return YETIGain;\n    }\n    // --- Compounded deposit and compounded front end stake ---\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         /\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n        return compoundedStake;\n    }\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n    // --- External Front End functions ---\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n    // --- Stability Pool Deposit Functionality ---\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n        address[] memory allColls = whitelist.getValidCollateral();\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n    // --- \'require\' functions ---\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Certainly', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:20 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";

/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;
    string public constant NAME = "StabilityPool";
    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;
    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;
    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;
    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;
    // --- Data structures ---
    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }
    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }
    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }
    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct
    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct
    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct
    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;
    uint256 public constant SCALE_FACTOR = 1e9;
    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;
    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;
    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;
    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;
    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;
    // --- Events ---
    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);
    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);
    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);
    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);
    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );
    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);
    // --- Contract setters ---
    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;
        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);
        _renounceOwnership();
    }
    // --- Getters for public variables. Required by IPool interface --- 
    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }
    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }
    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }
    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }
    // --- External Depositor Functions ---
    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        ICommunityIssuance communityIssuanceCached = communityIssuance;
        _triggerYETIIssuance(communityIssuanceCached);
        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log
        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);
        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);
        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);
        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);
        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log
        _sendGainsToDepositor(msg.sender, assets, amounts);
    }
    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);
        ICommunityIssuance communityIssuanceCached = communityIssuance;
        _triggerYETIIssuance(communityIssuanceCached);
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log
        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);
        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);
        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);
        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);
        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log
        _sendGainsToDepositor(msg.sender, assets, amounts);
    }
    // --- YETI issuance functions ---
    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }
    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }
        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);
        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);
        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }
    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);
        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));
        return YETIPerUnitStaked;
    }
    // --- Liquidation functions ---
    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }
        _triggerYETIIssuance(communityIssuance);
        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);
        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }
    // --- Offset helper functions ---

    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;
        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }
        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }
        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }
        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }
    }
    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;
        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);
            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }
        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;
            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }
        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }
    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);
        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);
        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }
    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }
    // --- Reward calculator functions for depositor and front end ---
    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }
        Snapshots storage snapshots = depositSnapshots[_depositor];
        return _calculateGains(initialDeposit, snapshots);
    }
    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }
    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;
        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);
        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }
    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }
        address frontEndTag = deposits[_depositor].frontEndTag;
        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;
        Snapshots storage snapshots = depositSnapshots[_depositor];
        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }
    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }
        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);
        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];
        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }
    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;
        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );
        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        return YETIGain;
    }
    // --- Compounded deposit and compounded front end stake ---
    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }
        Snapshots storage snapshots = depositSnapshots[_depositor];
        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }
    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }
        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];
        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }
    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;
        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }
        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);
        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }
        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }
        return compoundedStake;
    }
    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---
    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }
    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }
    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }
        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }
    // --- External Front End functions ---
    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);
        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;
        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }
    // --- Stability Pool Deposit Functionality ---
    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }
    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;
        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;
        address[] memory allColls = whitelist.getValidCollateral();
        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];
        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;
        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }
    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;
        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;
        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];
        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;
        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }
    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }
        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }
    // --- 'require' functions ---
    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }
    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }
    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }
    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }
    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }
    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }
    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }
    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }
    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }
    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }
    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }
    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";

/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;
    string public constant NAME = "StabilityPool";
    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;
    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;
    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;
    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;
    // --- Data structures ---
    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }
    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }
    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }
    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct
    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct
    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct
    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;
    uint256 public constant SCALE_FACTOR = 1e9;
    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;
    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;
    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;
    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;
    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;
    // --- Events ---
    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);
    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);
    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);
    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);
    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );
    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);
    // --- Contract setters ---
    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;
        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);
        _renounceOwnership();
    }
    // --- Getters for public variables. Required by IPool interface --- 
    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }
    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }
    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }
    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }
    // --- External Depositor Functions ---
    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        ICommunityIssuance communityIssuanceCached = communityIssuance;
        _triggerYETIIssuance(communityIssuanceCached);
        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log
        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);
        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);
        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);
        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);
        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log
        _sendGainsToDepositor(msg.sender, assets, amounts);
    }
    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);
        ICommunityIssuance communityIssuanceCached = communityIssuance;
        _triggerYETIIssuance(communityIssuanceCached);
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log
        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);
        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);
        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);
        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);
        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log
        _sendGainsToDepositor(msg.sender, assets, amounts);
    }
    // --- YETI issuance functions ---
    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }
    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }
        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);
        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);
        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }
    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);
        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));
        return YETIPerUnitStaked;
    }
    // --- Liquidation functions ---
    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }
        _triggerYETIIssuance(communityIssuance);
        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);
        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }
    // --- Offset helper functions ---

    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;
        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }
        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }
        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }
        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }
    }
    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;
        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);
            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }
        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;
            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }
        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }
    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);
        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);
        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }
    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }
    // --- Reward calculator functions for depositor and front end ---
    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }
        Snapshots storage snapshots = depositSnapshots[_depositor];
        return _calculateGains(initialDeposit, snapshots);
    }
    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }
    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;
        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);
        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }
    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }
        address frontEndTag = deposits[_depositor].frontEndTag;
        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;
        Snapshots storage snapshots = depositSnapshots[_depositor];
        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }
    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }
        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);
        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];
        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }
    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;
        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );
        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        return YETIGain;
    }
    // --- Compounded deposit and compounded front end stake ---
    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }
        Snapshots storage snapshots = depositSnapshots[_depositor];
        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }
    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }
        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];
        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }
    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;
        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }
        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);
        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }
        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }
        return compoundedStake;
    }
    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---
    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }
    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }
    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }
        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }
    // --- External Front End functions ---
    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);
        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;
        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }
    // --- Stability Pool Deposit Functionality ---
    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }
    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;
        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;
        address[] memory allColls = whitelist.getValidCollateral();
        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];
        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;
        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }
    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;
        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;
        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];
        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;
        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }
    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }
        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }
    // --- 'require' functions ---
    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }
    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }
    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }
    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }
    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }
    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }
    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }
    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }
    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }
    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }
    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }
    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Certainly Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-23-08 10:55:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 36953
completion_tokens: 1
total_tokens: 36954
cost: $-1.000000


[2024-23-08 10:55:24 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Security

[2024-23-08 10:55:24 INFO] **[Seminar Conclusion]**:

 Security

[2024-23-08 10:55:24 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-23-08 10:55:24 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 10:55:25 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = "StabilityPool";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         */\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- \'require\' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:25 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:25 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:55:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24607
completion_tokens: 1
total_tokens: 24608
cost: $-1.000000


[2024-23-08 10:55:28 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

###

[2024-23-08 10:55:28 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:55:28 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 10:55:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:28 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:55:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12363
completion_tokens: 830
total_tokens: 13193
cost: $-1.000000


[2024-23-08 10:55:42 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Based on the provided Solidity smart contract code for the Stability Pool, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to transfer tokens and send gains to depositors. If a malicious contract is used as a front end or a depositor, it could exploit this by re-entering the contract during the execution of a function, potentially draining funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath and LiquitySafeMath128, there is still a risk of integer overflow or underflow in calculations if any arithmetic operations are performed without proper checks or if the SafeMath library is not used consistently.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the ownerâ€™s private key is compromised, an attacker could gain control over the contract and execute malicious actions.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `getAllCollateral`, `getDepositorGains`) could run into gas limit issues if the arrays grow too large. This could lead to denial of service if users cannot execute these functions due to exceeding gas limits.

5. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, the `provideToSP` and `withdrawFromSP` functions should ensure that the amounts being deposited or withdrawn are within acceptable limits and that the user has sufficient balance.

6. **Potential for Front Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions first to gain an advantage.

7. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and debugging. For example, functions that update internal states should emit corresponding events to maintain transparency.

8. **Error Handling**:
   - The contract uses require statements for error handling, which is good; however, it lacks custom error messages in some cases, making it difficult to debug issues when they arise.

### Comprehensive Analysis Report:

The Stability Pool contract is a complex implementation designed to manage deposits and collateral gains in a decentralized finance (DeFi) context. While it employs several best practices, such as using SafeMath for arithmetic operations and maintaining a clear structure for deposits and gains, there are notable security vulnerabilities that could be exploited by malicious actors.

The potential for reentrancy attacks is a significant concern, particularly given the reliance on external calls to transfer tokens. Implementing a reentrancy guard or using the Checks-Effects-Interactions pattern could mitigate this risk. Additionally, while the use of SafeMath reduces the risk of overflow and underflow, it is crucial to ensure that all arithmetic operations are consistently protected.

Access control is another area that requires attention. The reliance on a single owner for critical functions poses a risk if the owner's private key is compromised. Implementing a multi-signature wallet or a decentralized governance model could enhance security.

Gas limit issues could arise from functions that iterate over potentially large arrays, leading to denial of service. It is advisable to implement pagination or limit the size of arrays to prevent this.

Input validation is essential to ensure that users cannot exploit the contract by providing invalid or malicious inputs. Thorough checks should be implemented to validate amounts and user balances.

The absence of mechanisms to prevent front-running could expose the contract to significant financial losses. Implementing time-locks or commit-reveal schemes could help mitigate this risk.

Lastly, improving event emission and error handling would enhance the contract's transparency and maintainability. Ensuring that all state changes are logged and providing clear error messages will aid in debugging and monitoring contract activity.

In conclusion, while the Stability Pool contract has a solid foundation, addressing the identified vulnerabilities is crucial to ensure the security and reliability of the contract in a live environment. A thorough audit and testing phase, including simulations of potential attack vectors, should be conducted before deployment.

[2024-23-08 10:55:42 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the Stability Pool, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to transfer tokens and send gains to depositors. If a malicious contract is used as a front end or a depositor, it could exploit this by re-entering the contract during the execution of a function, potentially draining funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath and LiquitySafeMath128, there is still a risk of integer overflow or underflow in calculations if any arithmetic operations are performed without proper checks or if the SafeMath library is not used consistently.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the ownerâ€™s private key is compromised, an attacker could gain control over the contract and execute malicious actions.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `getAllCollateral`, `getDepositorGains`) could run into gas limit issues if the arrays grow too large. This could lead to denial of service if users cannot execute these functions due to exceeding gas limits.

5. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, the `provideToSP` and `withdrawFromSP` functions should ensure that the amounts being deposited or withdrawn are within acceptable limits and that the user has sufficient balance.

6. **Potential for Front Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions first to gain an advantage.

7. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and debugging. For example, functions that update internal states should emit corresponding events to maintain transparency.

8. **Error Handling**:
   - The contract uses require statements for error handling, which is good; however, it lacks custom error messages in some cases, making it difficult to debug issues when they arise.

### Comprehensive Analysis Report:

The Stability Pool contract is a complex implementation designed to manage deposits and collateral gains in a decentralized finance (DeFi) context. While it employs several best practices, such as using SafeMath for arithmetic operations and maintaining a clear structure for deposits and gains, there are notable security vulnerabilities that could be exploited by malicious actors.

The potential for reentrancy attacks is a significant concern, particularly given the reliance on external calls to transfer tokens. Implementing a reentrancy guard or using the Checks-Effects-Interactions pattern could mitigate this risk. Additionally, while the use of SafeMath reduces the risk of overflow and underflow, it is crucial to ensure that all arithmetic operations are consistently protected.

Access control is another area that requires attention. The reliance on a single owner for critical functions poses a risk if the owner's private key is compromised. Implementing a multi-signature wallet or a decentralized governance model could enhance security.

Gas limit issues could arise from functions that iterate over potentially large arrays, leading to denial of service. It is advisable to implement pagination or limit the size of arrays to prevent this.

Input validation is essential to ensure that users cannot exploit the contract by providing invalid or malicious inputs. Thorough checks should be implemented to validate amounts and user balances.

The absence of mechanisms to prevent front-running could expose the contract to significant financial losses. Implementing time-locks or commit-reveal schemes could help mitigate this risk.

Lastly, improving event emission and error handling would enhance the contract's transparency and maintainability. Ensuring that all state changes are logged and providing clear error messages will aid in debugging and monitoring contract activity.

In conclusion, while the Stability Pool contract has a solid foundation, addressing the identified vulnerabilities is crucial to ensure the security and reliability of the contract in a live environment. A thorough audit and testing phase, including simulations of potential attack vectors, should be conducted before deployment.

[2024-23-08 10:55:42 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 10:55:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = "StabilityPool";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         */\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- \'require\' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:55:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24607
completion_tokens: 1
total_tokens: 24608
cost: $-1.000000


[2024-23-08 10:55:45 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

###

[2024-23-08 10:55:45 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:55:45 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 10:55:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:46 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:55:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:55:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12363
completion_tokens: 752
total_tokens: 13115
cost: $-1.000000


[2024-23-08 10:55:56 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Based on the provided Solidity smart contract code for the `StabilityPool`, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls to other contracts (e.g., `_sendGainsToDepositor`, `_sendYUSDToDepositor`) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract's state during the external call.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` and `LiquitySafeMath128`, there could still be potential for overflow or underflow in calculations if not properly handled, especially in areas where state variables are manipulated without checks.

3. **Access Control Issues**:
   - Functions that modify critical state variables (like `setAddresses`) are only restricted to the owner. If the ownerâ€™s account is compromised, an attacker could change critical addresses leading to potential loss of funds or manipulation of the contract.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that the amounts being transferred or manipulated are within expected ranges. This could lead to unexpected behaviors or exploitation.

5. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `getDepositorGains`, `_calculateGains`) could run into gas limit issues if the arrays grow too large. This could lead to denial of service if a user tries to access their gains when the array size exceeds the gas limit.

6. **Event Emission**:
   - While the contract emits events for state changes, there may be instances where events are not emitted for critical state changes, which could hinder transparency and tracking of contract activity.

7. **Potential for Front Running**:
   - The contract does not implement any measures to prevent front-running attacks, where an attacker could observe pending transactions and execute their own transactions to gain an advantage.

8. **Error Handling**:
   - The contract relies heavily on require statements for error handling. If any of these require statements fail, it could lead to loss of gas fees for users without providing a clear understanding of the failure.

### Comprehensive Analysis Report

The `StabilityPool` contract is a complex implementation that manages deposits and rewards in a decentralized finance (DeFi) context. While it incorporates several best practices, such as using `SafeMath` for arithmetic operations and emitting events for state changes, it is not without vulnerabilities.

The most pressing concern is the potential for reentrancy attacks, which could be exploited by malicious actors to drain funds from the contract. This is compounded by the fact that the contract allows external calls before updating its state, which is a common pitfall in Solidity contracts.

Additionally, access control mechanisms are limited to the owner, which poses a risk if the owner's private key is compromised. Input validation is another area that requires attention, as inadequate checks could lead to unexpected behaviors or exploitation.

The contract's reliance on require statements for error handling could also be improved, as it may not provide sufficient feedback to users regarding transaction failures. Furthermore, the potential for front-running attacks and gas limit issues due to looping through large arrays should be addressed to enhance the contract's robustness.

In conclusion, while the `StabilityPool` contract demonstrates a solid foundation for managing stability pool operations, it requires further enhancements in security practices, particularly in reentrancy protection, access control, input validation, and error handling, to ensure the safety and integrity of user funds. Regular audits and updates should be conducted to mitigate these vulnerabilities and adapt to evolving security standards in the DeFi space.

[2024-23-08 10:55:56 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `StabilityPool`, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls to other contracts (e.g., `_sendGainsToDepositor`, `_sendYUSDToDepositor`) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract's state during the external call.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath` and `LiquitySafeMath128`, there could still be potential for overflow or underflow in calculations if not properly handled, especially in areas where state variables are manipulated without checks.

3. **Access Control Issues**:
   - Functions that modify critical state variables (like `setAddresses`) are only restricted to the owner. If the ownerâ€™s account is compromised, an attacker could change critical addresses leading to potential loss of funds or manipulation of the contract.

4. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that the amounts being transferred or manipulated are within expected ranges. This could lead to unexpected behaviors or exploitation.

5. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `getDepositorGains`, `_calculateGains`) could run into gas limit issues if the arrays grow too large. This could lead to denial of service if a user tries to access their gains when the array size exceeds the gas limit.

6. **Event Emission**:
   - While the contract emits events for state changes, there may be instances where events are not emitted for critical state changes, which could hinder transparency and tracking of contract activity.

7. **Potential for Front Running**:
   - The contract does not implement any measures to prevent front-running attacks, where an attacker could observe pending transactions and execute their own transactions to gain an advantage.

8. **Error Handling**:
   - The contract relies heavily on require statements for error handling. If any of these require statements fail, it could lead to loss of gas fees for users without providing a clear understanding of the failure.

### Comprehensive Analysis Report

The `StabilityPool` contract is a complex implementation that manages deposits and rewards in a decentralized finance (DeFi) context. While it incorporates several best practices, such as using `SafeMath` for arithmetic operations and emitting events for state changes, it is not without vulnerabilities.

The most pressing concern is the potential for reentrancy attacks, which could be exploited by malicious actors to drain funds from the contract. This is compounded by the fact that the contract allows external calls before updating its state, which is a common pitfall in Solidity contracts.

Additionally, access control mechanisms are limited to the owner, which poses a risk if the owner's private key is compromised. Input validation is another area that requires attention, as inadequate checks could lead to unexpected behaviors or exploitation.

The contract's reliance on require statements for error handling could also be improved, as it may not provide sufficient feedback to users regarding transaction failures. Furthermore, the potential for front-running attacks and gas limit issues due to looping through large arrays should be addressed to enhance the contract's robustness.

In conclusion, while the `StabilityPool` contract demonstrates a solid foundation for managing stability pool operations, it requires further enhancements in security practices, particularly in reentrancy protection, access control, input validation, and error handling, to ensure the safety and integrity of user funds. Regular audits and updates should be conducted to mitigate these vulnerabilities and adapt to evolving security standards in the DeFi space.

[2024-23-08 10:55:56 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 10:55:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = "StabilityPool";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         */\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- \'require\' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:55:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:55:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:56:00 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:56:00 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24607
completion_tokens: 1
total_tokens: 24608
cost: $-1.000000


[2024-23-08 10:56:00 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

###

[2024-23-08 10:56:00 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:56:00 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 10:56:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:56:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:56:00 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:56:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:56:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12363
completion_tokens: 769
total_tokens: 13132
cost: $-1.000000


[2024-23-08 10:56:11 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Based on the provided Solidity smart contract code for the `StabilityPool`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls to other contracts (e.g., transferring tokens) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract by calling back into it before the state is updated.

2. **Integer Overflow/Underflow**: 
   - Although the contract uses `SafeMath` and `LiquitySafeMath128`, there may still be areas where arithmetic operations could lead to overflow or underflow if not properly handled, especially in custom calculations.

3. **Access Control Issues**: 
   - Functions that modify critical state variables (like `setAddresses`) are only protected by the `onlyOwner` modifier. If the ownerâ€™s private key is compromised, an attacker could gain full control over the contract.

4. **Gas Limit and Loops**: 
   - Functions that iterate over arrays (e.g., `getDepositorGains`, `_calculateGains`, etc.) could run into gas limit issues if the arrays grow large. This could lead to denial of service (DoS) attacks.

5. **Lack of Input Validation**: 
   - Some functions do not validate inputs thoroughly. For instance, the `provideToSP` function does not check if the `_amount` is greater than the balance of the user, which could lead to unexpected behavior.

6. **Potential for Front Running**: 
   - The contract does not implement any measures to prevent front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage.

7. **Event Emission**: 
   - Certain critical state changes do not emit events, which could hinder transparency and make it difficult to track changes in the contract state.

8. **Inadequate Error Handling**: 
   - The contract relies heavily on require statements for error handling. While this is a common practice, it may not provide sufficient feedback in all scenarios, especially for complex operations.

9. **Uncontrolled External Calls**: 
   - The contract makes calls to external contracts (e.g., `yusdToken.sendToPool`). If these contracts are malicious or have vulnerabilities, they could compromise the security of the `StabilityPool`.

### Comprehensive Analysis Report:

The `StabilityPool` contract implements a complex system for managing deposits and collateral in a decentralized finance (DeFi) context. While it employs several best practices, including the use of SafeMath and structured data management, it is not without vulnerabilities.

The most pressing concern is the potential for reentrancy attacks, which could be exploited by malicious actors to drain funds from the contract. This is compounded by the fact that external calls are made before state updates, which is a common pitfall in Solidity contracts.

Additionally, while the contract uses access control mechanisms, the reliance on a single owner introduces a single point of failure. If the owner's private key is compromised, the entire contract could be at risk. Furthermore, the lack of thorough input validation and potential gas limit issues could lead to unexpected behaviors or denial of service.

The absence of measures to prevent front-running attacks also poses a risk, particularly in a competitive DeFi environment where transaction timing can be exploited.

In conclusion, while the `StabilityPool` contract has a solid foundation, it requires careful attention to security practices. Implementing reentrancy guards, enhancing input validation, and ensuring comprehensive event emissions are crucial steps toward fortifying the contract against potential attacks. Regular audits and updates, along with community engagement, will be essential in maintaining the contract's integrity and security in the evolving DeFi landscape.

[2024-23-08 10:56:11 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `StabilityPool`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - The contract allows external calls to other contracts (e.g., transferring tokens) before updating the state variables. This could lead to reentrancy attacks where an attacker could exploit the contract by calling back into it before the state is updated.

2. **Integer Overflow/Underflow**: 
   - Although the contract uses `SafeMath` and `LiquitySafeMath128`, there may still be areas where arithmetic operations could lead to overflow or underflow if not properly handled, especially in custom calculations.

3. **Access Control Issues**: 
   - Functions that modify critical state variables (like `setAddresses`) are only protected by the `onlyOwner` modifier. If the ownerâ€™s private key is compromised, an attacker could gain full control over the contract.

4. **Gas Limit and Loops**: 
   - Functions that iterate over arrays (e.g., `getDepositorGains`, `_calculateGains`, etc.) could run into gas limit issues if the arrays grow large. This could lead to denial of service (DoS) attacks.

5. **Lack of Input Validation**: 
   - Some functions do not validate inputs thoroughly. For instance, the `provideToSP` function does not check if the `_amount` is greater than the balance of the user, which could lead to unexpected behavior.

6. **Potential for Front Running**: 
   - The contract does not implement any measures to prevent front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage.

7. **Event Emission**: 
   - Certain critical state changes do not emit events, which could hinder transparency and make it difficult to track changes in the contract state.

8. **Inadequate Error Handling**: 
   - The contract relies heavily on require statements for error handling. While this is a common practice, it may not provide sufficient feedback in all scenarios, especially for complex operations.

9. **Uncontrolled External Calls**: 
   - The contract makes calls to external contracts (e.g., `yusdToken.sendToPool`). If these contracts are malicious or have vulnerabilities, they could compromise the security of the `StabilityPool`.

### Comprehensive Analysis Report:

The `StabilityPool` contract implements a complex system for managing deposits and collateral in a decentralized finance (DeFi) context. While it employs several best practices, including the use of SafeMath and structured data management, it is not without vulnerabilities.

The most pressing concern is the potential for reentrancy attacks, which could be exploited by malicious actors to drain funds from the contract. This is compounded by the fact that external calls are made before state updates, which is a common pitfall in Solidity contracts.

Additionally, while the contract uses access control mechanisms, the reliance on a single owner introduces a single point of failure. If the owner's private key is compromised, the entire contract could be at risk. Furthermore, the lack of thorough input validation and potential gas limit issues could lead to unexpected behaviors or denial of service.

The absence of measures to prevent front-running attacks also poses a risk, particularly in a competitive DeFi environment where transaction timing can be exploited.

In conclusion, while the `StabilityPool` contract has a solid foundation, it requires careful attention to security practices. Implementing reentrancy guards, enhancing input validation, and ensuring comprehensive event emissions are crucial steps toward fortifying the contract against potential attacks. Regular audits and updates, along with community engagement, will be essential in maintaining the contract's integrity and security in the evolving DeFi landscape.

[2024-23-08 10:56:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/IBorrowerOperations.sol";\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/ICommunityIssuance.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/LiquityBase.sol";\nimport "./Dependencies/SafeMath.sol";\nimport "./Dependencies/LiquitySafeMath128.sol";\nimport "./Dependencies/Ownable.sol";\nimport "./Dependencies/CheckContract.sol";\nimport "./Dependencies/SafeERC20.sol";\n\n\n/\n * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.\n \n * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with\n * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.\n \n * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.\n * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,\n * in the same proportion.\n \n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\n * of the total YUSD in the Stability Pool, depletes 40% of each deposit.\n \n * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,\n * multiplying it by some factor in range ]0,1[\n \n \n * --- IMPLEMENTATION ---\n \n * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.\n \n * When a liquidation occurs, rather than updating each depositor\'s deposit and Collateral gain, we simply update two state variables:\n * a product P, and a sum S. These are kept track for each type of collateral.\n \n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors\' compounded deposits\n * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\n \n * The formula for a depositor\'s accumulated Collateral amount gain is derived here:\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\n \n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\n * and the term d_t * (S - S_t)/P_t gives us the deposit\'s total accumulated Collateral amount gain.\n \n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain\n * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.\n \n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\n * Essentially, they make a fresh deposit that overwrites the old one.\n \n \n * --- SCALE FACTOR ---\n \n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\n \n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn\'t been emptied: this would break deposit tracking.\n \n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\n \n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\n * order of 1e-9.\n \n * --- EPOCHS ---\n \n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\n * forever, and break all future reward calculations.\n \n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\n \n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\n \n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\n \n * When calculating a compounded deposit, we compare the current epoch to the deposit\'s epoch snapshot. If the current epoch is newer,\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\n \n * Otherwise, we then compare the current scale to the deposit\'s scale snapshot. If they\'re equal, the compounded deposit is given by d_t * P/P_t.\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\n * as 0, since it is now less than 1e-9\'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).\n \n \n *  --- TRACKING DEPOSITOR\'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---\n \n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.\n \n * This allows us to calculate a deposit\'s accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.\n \n * We calculate the depositor\'s accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:\n * e_1 = d_t * (S - S_t) / P_t\n \n * and also for scale after, taking care to divide the latter by a factor of 1e9:\n * e_2 = d_t * S / (P_t * 1e9)\n \n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\n * The deposit therefore was present for reward events from the beginning of that second scale.\n \n *        S_i-S_t + S_{i+1}\n *      .&lt;--------.------------&gt;\n *      .         .\n *      . S_i     .   S_{i+1}\n *   &lt;--.--------&gt;.&lt;-----------&gt;\n *   S_t.         .\n *   &lt;-&gt;.         .\n *      t         .\n *  |---+---------|-------------|-----...\n *         i            i+1\n \n * The sum of (e_1 + e_2) captures the depositor\'s total accumulated Collateral amount gain, handling the case where their\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\n * deposit is defined as being 0 once it has spanned more than one scale change.\n \n \n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\n \n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\n \n \n * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---\n \n * An YETI issuance event occurs at every deposit operation, and every liquidation.\n \n * Each deposit is tagged with the address of the front end through which it was made.\n \n * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end\'s kickbackRate.\n \n * Please see the system Readme for an overview:\n * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers\n \n * We use the same mathematical product-sum approach to track YETI gains for depositors, where \'G\' is the sum corresponding to YETI gains.\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit\'s depletion due to liquidations.\n \n /\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\n    using LiquitySafeMath128 for uint128;\n    using SafeERC20 for IERC20;\n\n    string public constant NAME = "StabilityPool";\n\n    address internal troveManagerLiquidationsAddress;\n    address internal whitelistAddress;\n\n    IBorrowerOperations internal borrowerOperations;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdToken;\n    ICommunityIssuance internal communityIssuance;\n    // Needed to check if there are pending liquidations\n    ISortedTroves internal sortedTroves;\n\n    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n    uint256 internal totalYUSDDeposits;\n\n    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length\n    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist\n    // both lists are lengthened\n    newColls internal totalColl;\n\n    // --- Data structures ---\n\n    struct FrontEnd {\n        uint256 kickbackRate;\n        bool registered;\n    }\n\n    struct Deposit {\n        uint256 initialValue;\n        address frontEndTag;\n    }\n\n    struct Snapshots {\n        mapping(address =&gt; uint256) S;\n        uint256 P;\n        uint256 G;\n        uint128 scale;\n        uint128 epoch;\n    }\n\n    mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct\n\n    / depositSnapshots maintains an entry for each depositor\n     * that tracks P, S, G, scale, and epoch.\n     * depositor\'s snapshot is updated only when they\n     * deposit or withdraw from stability pool\n     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount\n     * and to calculate how much Collateral amount the depositor is entitled to\n     /\n    mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct\n\n    mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct\n    mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end\n    mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct\n\n    /  Product \'P\': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\n     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.\n     \n     * During its lifetime, a deposit\'s value evolves from d_t to d_t * P / P_t , where P_t\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\n     /\n    uint256 public P = DECIMAL_PRECISION;\n\n    uint256 public constant SCALE_FACTOR = 1e9;\n\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\n    uint128 public currentScale;\n\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\n    uint128 public currentEpoch;\n\n    / Collateral amount Gain sum \'S\': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,\n     * where S_t is the depositor\'s snapshot of S taken at the time t when the deposit was made.\n     \n     * The \'S\' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):\n     \n     * - The inner mapping records the sum S at different scales\n     * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.\n     * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings\n     /\n    mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;\n\n    /\n     * Similarly, the sum \'G\' is used to calculate YETI gains. During it\'s lifetime, each deposit d_t earns a YETI gain of\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor\'s snapshot of G taken at time t when  the deposit was made.\n     \n     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\n     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.\n     /\n    mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;\n\n    // Error tracker for the error correction in the YETI issuance calculation\n    uint256 public lastYETIError;\n    // Error trackers for the error correction in the offset calculation\n    uint256[] public lastAssetError_Offset;\n    uint256 public lastYUSDLossError_Offset;\n\n    // --- Events ---\n\n    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);\n    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint256 _P);\n    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);\n    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\n    event FrontEndStakeChanged(\n        address indexed _frontEnd,\n        uint256 _newFrontEndStake,\n        address _depositor\n    );\n\n    event GainsWithdrawn(\n        address indexed _depositor,\n        address[] collaterals,\n        uint256[] _amounts,\n        uint256 _YUSDLoss\n    );\n    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);\n    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);\n    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _communityIssuanceAddress,\n        address _whitelistAddress,\n        address _troveManagerLiquidationsAddress\n    ) external override onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_communityIssuanceAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        whitelistAddress = _whitelistAddress;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Getters for public variables. Required by IPool interface --- \n\n    // total VC of collateral in Stability Pool\n    function getVC() external view override returns (uint256) {\n        return _getVCColls(totalColl);\n    }\n\n    function getCollateral(address _collateral) external view override returns (uint256) {\n        uint256 collateralIndex = whitelist.getIndex(_collateral);\n        return totalColl.amounts[collateralIndex];\n    }\n\n    /\n     * Returns all collateral balances in state. Not necessarily the contract\'s actual balances.\n     /\n    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {\n        return (totalColl.tokens, totalColl.amounts);\n    }\n\n    function getTotalYUSDDeposits() external view override returns (uint256) {\n        return totalYUSDDeposits;\n    }\n\n    // --- External Depositor Functions ---\n\n    /  provideToSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it\'s a new deposit\n     * - Sends depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Increases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     /\n    function provideToSP(uint256 _amount, address _frontEndTag) external override {\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireNonZeroAmount(_amount);\n\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        if (initialDeposit == 0) {\n            _setFrontEndTag(msg.sender, _frontEndTag);\n        }\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake:\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool\n        // and throws an event\n        _sendYUSDtoStabilityPool(msg.sender, _amount);\n\n        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    /  withdrawFromSP():\n     \n     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between all depositors and front ends\n     * - Removes the deposit\'s front end tag if it is a full withdrawal\n     * - Sends all depositor\'s accumulated gains (YETI, collateral assets) to depositor\n     * - Sends the tagged front end\'s accumulated YETI gains to the tagged front end\n     * - Decreases deposit and tagged front end\'s stake, and takes new snapshots for each.\n     \n     * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.\n     /\n    function withdrawFromSP(uint256 _amount) external override {\n        if (_amount != 0) {\n            _requireNoUnderCollateralizedTroves();\n        }\n        uint256 initialDeposit = deposits[msg.sender].initialValue;\n        _requireUserHasDeposit(initialDeposit);\n\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\n\n        _triggerYETIIssuance(communityIssuanceCached);\n\n        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);\n\n        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);\n\n        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);\n        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log\n\n        // First pay out any YETI gains\n        address frontEnd = deposits[msg.sender].frontEndTag;\n        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);\n\n        // Update front end stake\n        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\n        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\n\n        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);\n\n        // Update deposit\n        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\n        emit UserDepositChanged(msg.sender, newDeposit);\n\n        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log\n\n        _sendGainsToDepositor(msg.sender, assets, amounts);\n    }\n\n    // --- YETI issuance functions ---\n\n    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {\n        uint256 YETIIssuance = _communityIssuance.issueYETI();\n        _updateG(YETIIssuance);\n    }\n\n    function _updateG(uint256 _YETIIssuance) internal {\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        /\n         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\n         \n         /\n        if (totalYUSD == 0 || _YETIIssuance == 0) {\n            return;\n        }\n\n        uint256 YETIPerUnitStaked;\n        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);\n\n        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\n            .add(marginalYETIGain);\n\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\n    }\n\n    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)\n        internal\n        returns (uint256)\n    {\n        /\n         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the\n         * cumulative error low in the running total G:\n         \n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\n         * function was called.\n         * 2) Calculate "per-unit-staked" ratio.\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\n         * 4) Store this error for use in the next correction when this function is called.\n         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n         /\n        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);\n\n        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);\n        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));\n\n        return YETIPerUnitStaked;\n    }\n\n    // --- Liquidation functions ---\n\n    /\n     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove\'s collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     /\n    function offset(\n        uint256 _debtToOffset,\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded\n    ) external override {\n        _requireCallerIsTML();\n        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD\n        if (totalYUSD == 0 || _debtToOffset == 0) {\n            return;\n        }\n\n        _triggerYETIIssuance(communityIssuance);\n\n        (\n            uint256[] memory AssetGainPerUnitStaked,\n            uint256 YUSDLossPerUnitStaked\n        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);\n\n        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P\n        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);\n    }\n\n    // --- Offset helper functions ---\n\n\n    /\n    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep\n    * the cumulative error in the P and S state variables low:\n    \n    * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n    * function was called.\n    * 2) Calculate "per-unit-staked" ratios.\n    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n    * 4) Store these errors for use in the next correction when this function is called.\n    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n    /\n    function _computeRewardsPerUnitStaked(\n        address[] memory _tokens,\n        uint256[] memory _amountsAdded,\n        uint256 _debtToOffset,\n        uint256 _totalYUSDDeposits\n    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {\n        uint256 amountsLen = _amountsAdded.length;\n        uint256[] memory CollateralNumerators = new uint256;\n        uint256 currentP = P;\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(\n                lastAssetError_Offset[tokenIDX]\n            );\n        }\n\n        require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");\n        if (_debtToOffset == _totalYUSDDeposits) {\n            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\n            lastYUSDLossError_Offset = 0;\n        } else {\n            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\n                lastYUSDLossError_Offset\n            );\n            /\n             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,\n             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.\n             /\n            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);\n            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(\n                YUSDLossNumerator\n            );\n        }\n\n        AssetGainPerUnitStaked = new uint256;\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);\n        }\n\n        for (uint256 i; i &lt; amountsLen; ++i) {\n            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);\n            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(\n                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)\n            );\n        }\n\n    }\n\n    // Update the Stability Pool reward sum S and product P\n    function _updateRewardSumAndProduct(\n        address[] memory _assets,\n        uint256[] memory _AssetGainPerUnitStaked,\n        uint256 _YUSDLossPerUnitStaked\n    ) internal {\n        uint256 currentP = P;\n        uint256 newP;\n\n        require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");\n        /\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)\n         /\n        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n\n        /\n         * Calculate the new S first, before we update P.\n         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\n         \n         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.\n         /\n        uint256 assetsLen = _assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address asset = _assets[i];\n            \n            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.\n            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];\n            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);\n\n            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;\n            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);\n        }\n\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\n        if (newProductFactor == 0) {\n            currentEpoch = currentEpochCached.add(1);\n            emit EpochUpdated(currentEpoch);\n            currentScale = 0;\n            emit ScaleUpdated(currentScale);\n            newP = DECIMAL_PRECISION;\n\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\n            currentScale = currentScaleCached.add(1);\n            emit ScaleUpdated(currentScale);\n        } else {\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\n        }\n\n        require(newP != 0, "SP: P = 0");\n        P = newP;\n        emit P_Updated(newP);\n    }\n\n    // Internal function to move offset collateral and debt between pools. \n    function _moveOffsetCollAndDebt(\n        address[] memory _collsToAdd,\n        uint256[] memory _amountsToAdd,\n        uint256 _debtToOffset\n    ) internal {\n        IActivePool activePoolCached = activePool;\n        // Cancel the liquidated YUSD debt with the YUSD in the stability pool\n        activePoolCached.decreaseYUSDDebt(_debtToOffset);\n        _decreaseYUSD(_debtToOffset);\n\n        // Burn the debt that was successfully offset\n        yusdToken.burn(address(this), _debtToOffset);\n\n        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);\n    }\n\n    // Decreases YUSD Stability pool balance. \n    function _decreaseYUSD(uint256 _amount) internal {\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    // --- Reward calculator functions for depositor and front end ---\n\n    / Calculates the gains earned by the deposit since its last snapshots were taken.\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\n     * where S(0) and P(0) are the depositor\'s snapshots of the sum S and product P, respectively.\n     * d0 is the last recorded deposit value.\n     * returns assets, amounts\n     /\n    function getDepositorGains(address _depositor)\n        public\n        view\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n\n        if (initialDeposit == 0) {\n            address[] memory emptyAddress = new address;\n            uint256[] memory emptyUint = new uint256;\n            return (emptyAddress, emptyUint);\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        return _calculateGains(initialDeposit, snapshots);\n    }\n\n    // get gains on each possible asset by looping through\n    // assets with _getGainFromSnapshots function\n    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)\n        internal\n        view\n        returns (address[] memory assets, uint256[] memory amounts)\n    {\n        assets = whitelist.getValidCollateral();\n        uint256 assetsLen = assets.length;\n        amounts = new uint256;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);\n        }\n    }\n\n    // gets the gain in S for a given asset\n    // for a user who deposited initialDeposit\n    function _getGainFromSnapshots(\n        uint256 initialDeposit,\n        Snapshots storage snapshots,\n        address asset\n    ) internal view returns (uint256) {\n        /\n         * Grab the sum \'S\' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.\n         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint256 S_Snapshot = snapshots.S[asset];\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(\n            S_Snapshot\n        );        \n        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]\n            .div(SCALE_FACTOR);\n\n        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n        \n        return assetGain;\n    }\n\n    /\n     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.\n     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     * d0 is the last recorded deposit value.\n     /\n    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        address frontEndTag = deposits[_depositor].frontEndTag;\n\n        /\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n         * Otherwise, their cut of the deposit\'s earnings is equal to the kickbackRate, set by the front end through\n         * which they made their deposit.\n         /\n        uint256 kickbackRate = frontEndTag == address(0)\n            ? DECIMAL_PRECISION\n            : frontEnds[frontEndTag].kickbackRate;\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 YETIGain = kickbackRate\n            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))\n            .div(DECIMAL_PRECISION);\n\n        return YETIGain;\n    }\n\n    /\n     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\n     * where G(0) and P(0) are the depositor\'s snapshots of the sum G and product P, respectively.\n     \n     * D0 is the last recorded value of the front end\'s total tagged deposits.\n     /\n    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;\n        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 YETIGain = frontEndShare\n            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))\n            .div(DECIMAL_PRECISION);\n        return YETIGain;\n    }\n\n    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        /\n         * Grab the sum \'G\' from the epoch at which the stake was made. The YETI gain may span up to one scale change.\n         * If it does, the second portion of the YETI gain is scaled by 1e9.\n         * If the gain spans no scale change, the second portion will be 0.\n         /\n        uint128 epochSnapshot = snapshots.epoch;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint256 G_Snapshot = snapshots.G;\n        uint256 P_Snapshot = snapshots.P;\n\n        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\n        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(\n            SCALE_FACTOR\n        );\n\n        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\n            DECIMAL_PRECISION\n        );\n\n        return YETIGain;\n    }\n\n    // --- Compounded deposit and compounded front end stake ---\n\n    /\n     * Return the user\'s compounded deposit. Given by the formula:  d = d0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken when they last updated their deposit.\n     /\n    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {\n        uint256 initialDeposit = deposits[_depositor].initialValue;\n        if (initialDeposit == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = depositSnapshots[_depositor];\n\n        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\n        return compoundedDeposit;\n    }\n\n    /\n     * Return the front end\'s compounded stake. Given by the formula:  D = D0 * P/P(0)\n     * where P(0) is the depositor\'s snapshot of the product P, taken at the last time\n     * when one of the front end\'s tagged deposits updated their deposit.\n     \n     * The front end\'s compounded stake is equal to the sum of its depositors\' compounded deposits.\n     /\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {\n        uint256 frontEndStake = frontEndStakes[_frontEnd];\n        if (frontEndStake == 0) {\n            return 0;\n        }\n\n        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];\n\n        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\n        return compoundedFrontEndStake;\n    }\n\n    // Internal function, used to calculate compounded deposits and compounded front end stakes.\n    // returns 0 if the snapshots were taken prior to a a pool-emptying event\n    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or\n    // If the scaleDiff is 0 or 1,\n    // then adjust for changes in P and scale changes to calculate a compoundedStake.\n    // IF the final compoundedStake isn\'t less than a billionth of the initial stake, return it.this\n    // otherwise, just return 0.\n    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshot_P = snapshots.P;\n        uint128 scaleSnapshot = snapshots.scale;\n        uint128 epochSnapshot = snapshots.epoch;\n\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\n        if (epochSnapshot &lt; currentEpoch) {\n            return 0;\n        }\n\n        uint256 compoundedStake;\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\n\n        / Compute the compounded stake. If a scale change in P was made during the stake\'s lifetime,\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\n         * at least 1e-9 -- so return 0.\n         /\n        if (scaleDiff == 0) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\n        } else if (scaleDiff == 1) {\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\n        } else {\n            // if scaleDiff &gt;= 2\n            compoundedStake = 0;\n        }\n\n        /\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\n         \n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\n         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less\n         * than it\'s theoretical value.\n         \n         * Thus it\'s unclear whether this line is still really needed.\n         */\n        if (compoundedStake &lt; initialStake.div(1e9)) {\n            return 0;\n        }\n\n        return compoundedStake;\n    }\n\n    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---\n\n    // Transfer the YUSD tokens from the user to the Stability Pool\'s address, and update its recorded YUSD\n    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {\n        yusdToken.sendToPool(_address, address(this), _amount);\n        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);\n        totalYUSDDeposits = newTotalYUSDDeposits;\n        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);\n    }\n\n    function _sendGainsToDepositor(\n        address _to,\n        address[] memory assets,\n        uint256[] memory amounts\n    ) internal {\n        uint256 assetsLen = assets.length;\n        require(assetsLen == amounts.length, "SP:Length mismatch");\n        uint256 thisAmounts;\n        address thisAsset;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            thisAmounts = amounts[i];\n            thisAsset = assets[i];\n            if (whitelist.isWrapped(thisAsset)) {\n                // In this case update the rewards from the treasury to the caller \n                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);\n                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. \n                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);\n            } else {\n                IERC20(thisAsset).safeTransfer(_to, thisAmounts);\n            }\n        }\n        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);\n    }\n\n    // Send YUSD to user and decrease YUSD in Pool\n    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {\n        if (YUSDWithdrawal == 0) {\n            return;\n        }\n\n        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);\n        _decreaseYUSD(YUSDWithdrawal);\n    }\n\n    // --- External Front End functions ---\n\n    // Front end makes a one-time selection of kickback rate upon registering\n    function registerFrontEnd(uint256 _kickbackRate) external override {\n        _requireFrontEndNotRegistered(msg.sender);\n        _requireUserHasNoDeposit(msg.sender);\n        _requireValidKickbackRate(_kickbackRate);\n\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\n        frontEnds[msg.sender].registered = true;\n\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\n    }\n\n    // --- Stability Pool Deposit Functionality ---\n\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\n        deposits[_depositor].frontEndTag = _frontEndTag;\n        emit FrontEndTagSet(_depositor, _frontEndTag);\n    }\n\n    // if _newValue is zero, delete snapshot for given _depositor and emit event\n    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots\n    // with current values for P, S, G, scale and epoch and then emit event.\n    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {\n        deposits[_depositor].initialValue = _newValue;\n\n        if (_newValue == 0) {\n            delete deposits[_depositor].frontEndTag;\n            address[] memory colls = whitelist.getValidCollateral();\n            uint256 collsLen = colls.length;\n            for (uint256 i; i &lt; collsLen; ++i) {\n                depositSnapshots[_depositor].S[colls[i]] = 0;\n            }\n            depositSnapshots[_depositor].P = 0;\n            depositSnapshots[_depositor].G = 0;\n            depositSnapshots[_depositor].epoch = 0;\n            depositSnapshots[_depositor].scale = 0;\n            emit DepositSnapshotUpdated(_depositor, 0, 0);\n            return;\n        }\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        // Get S and G for the current epoch and current scale\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address token = allColls[i];\n            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][\n                currentScaleCached\n            ];\n            depositSnapshots[_depositor].S[token] = currentSForToken;\n        }\n\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\n        depositSnapshots[_depositor].P = currentP;\n        depositSnapshots[_depositor].G = currentG;\n        depositSnapshots[_depositor].scale = currentScaleCached;\n        depositSnapshots[_depositor].epoch = currentEpochCached;\n\n        emit DepositSnapshotUpdated(_depositor, currentP, currentG);\n    }\n\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {\n        frontEndStakes[_frontEnd] = _newValue;\n\n        if (_newValue == 0) {\n            delete frontEndSnapshots[_frontEnd];\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\n            return;\n        }\n\n        uint128 currentScaleCached = currentScale;\n        uint128 currentEpochCached = currentEpoch;\n        uint256 currentP = P;\n\n        // Get G for the current epoch and current scale\n        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\n\n        // Record new snapshots of the latest running product P and sum G for the front end\n        frontEndSnapshots[_frontEnd].P = currentP;\n        frontEndSnapshots[_frontEnd].G = currentG;\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\n\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\n    }\n\n    function _payOutYETIGains(\n        ICommunityIssuance _communityIssuance,\n        address _depositor,\n        address _frontEnd\n    ) internal {\n        // Pay out front end\'s YETI gain\n        if (_frontEnd != address(0)) {\n            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);\n            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);\n            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);\n        }\n\n        // Pay out depositor\'s YETI gain\n        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);\n        _communityIssuance.sendYETI(_depositor, depositorYETIGain);\n        emit YETIPaidToDepositor(_depositor, depositorYETIGain);\n    }\n\n    // --- \'require\' functions ---\n\n    function _requireNoUnderCollateralizedTroves() internal view {\n        address lowestTrove = sortedTroves.getLast();\n        uint256 ICR = troveManager.getCurrentICR(lowestTrove);\n        require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR");\n    }\n\n    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {\n        require(_initialDeposit != 0, "SP: require nonzero deposit");\n    }\n\n    function _requireUserHasNoDeposit(address _address) internal view {\n        uint256 initialDeposit = deposits[_address].initialValue;\n        require(initialDeposit == 0, "SP: User must have no deposit");\n    }\n\n    function _requireNonZeroAmount(uint256 _amount) internal pure {\n        require(_amount != 0, "SP: Amount must be non-zero");\n    }\n\n    function _requireFrontEndNotRegistered(address _address) internal view {\n        require(\n            !frontEnds[_address].registered,\n            "SP: Frontend already registered"\n        );\n    }\n\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\n        require(\n            frontEnds[_address].registered || _address == address(0),\n            "SP: Frontend not registered"\n        );\n    }\n\n    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {\n        require(\n            _kickbackRate &lt;= DECIMAL_PRECISION,\n            "SP:Invalid Kickback rate"\n        );\n    }\n\n    function _requireCallerIsWhitelist() internal view {\n        if (msg.sender != whitelistAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsActivePool() internal view {\n        if (msg.sender != address(activePool)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != address(troveManagerLiquidationsAddress)) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view {\n        revert("SP: External caller not allowed");\n    }\n\n    // Should be called by ActivePool\n    // after collateral is transferred to this contract from Active Pool\n    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)\n        external\n        override\n    {\n        _requireCallerIsActivePool();\n        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);\n        emit StabilityPoolBalancesUpdated(_tokens, _amounts);\n    }\n\n    // should be called anytime a collateral is added to whitelist\n    function addCollateralType(address _collateral) external override {\n        _requireCallerIsWhitelist();\n        lastAssetError_Offset.push(0);\n        totalColl.tokens.push(_collateral);\n        totalColl.amounts.push(0);\n    }\n\n    // Gets reward snapshot S for certain collateral and depositor. \n    function getDepositSnapshotS(address _depositor, address _collateral)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return depositSnapshots[_depositor].S[_collateral];\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-23-08 10:56:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/IBorrowerOperations.sol"; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/ICommunityIssuance.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/IERC20.sol"; import "./Interfaces/IWAsset.sol"; import "./Dependencies/LiquityBase.sol"; import "./Dependencies/SafeMath.sol"; import "./Dependencies/LiquitySafeMath128.sol"; import "./Dependencies/Ownable.sol"; import "./Dependencies/CheckContract.sol"; import "./Dependencies/SafeERC20.sol"; /  * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.  *  * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with  * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.  *  * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.  * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,  * in the same proportion.  *  * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%  * of the total YUSD in the Stability Pool, depletes 40% of each deposit.  *  * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,  * multiplying it by some factor in range ]0,1[  *  *  * --- IMPLEMENTATION ---  *  * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.  *  * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:  * a product P, and a sum S. These are kept track for each type of collateral.  *  * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits  * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the  * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.  *  * The formula for a depositor's accumulated Collateral amount gain is derived here:  * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf  *  * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,  * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.  *  * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain  * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.  *  * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded  * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.  * Essentially, they make a fresh deposit that overwrites the old one.  *  *  * --- SCALE FACTOR ---  *  * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.  * Unfortunately, Solidity floor division always reaches 0, sooner or later.  *  * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P  * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.  *  * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to &lt;1e-9 (and be rounded to 0 by Solidity),  * we first multiply P by 1e9, and increment a currentScale factor by 1.  *  * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the  * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the  * order of 1e-9.  *  * --- EPOCHS ---  *  * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0  * forever, and break all future reward calculations.  *  * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.  *  * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---  *  * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.  *  * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,  * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.  *  * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.  * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit  * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to &lt; 1 YUSD).  *  *  *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---  *  * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -&gt; S) is stored for each epoch.  *  * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.  *  * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:  * e_1 = d_t * (S - S_t) / P_t  *  * and also for scale after, taking care to divide the latter by a factor of 1e9:  * e_2 = d_t * S / (P_t * 1e9)  *  * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.  * The deposit therefore was present for reward events from the beginning of that second scale.  *  *        S_i-S_t + S_{i+1}  *      .&lt;--------.------------&gt;  *      .         .  *      . S_i     .   S_{i+1}  *   &lt;--.--------&gt;.&lt;-----------&gt;  *   S_t.         .  *   &lt;-&gt;.         .  *      t         .  *  |---+---------|-------------|-----...  *         i            i+1  *  * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their  * deposit spanned one scale change. We only care about gains across one scale change, since the compounded  * deposit is defined as being 0 once it has spanned more than one scale change.  *  *  * --- UPDATING P WHEN A LIQUIDATION OCCURS ---  *  * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:  * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf  *  *  * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---  *  * An YETI issuance event occurs at every deposit operation, and every liquidation.  *  * Each deposit is tagged with the address of the front end through which it was made.  *  * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned  * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.  *  * Please see the system Readme for an overview:  * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers  *  * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.  * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.  *  / contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {     using LiquitySafeMath128 for uint128;     using SafeERC20 for IERC20; string public constant NAME = "StabilityPool";  address internal troveManagerLiquidationsAddress; address internal whitelistAddress;  IBorrowerOperations internal borrowerOperations; ITroveManager internal troveManager; IYUSDToken internal yusdToken; ICommunityIssuance internal communityIssuance; // Needed to check if there are pending liquidations ISortedTroves internal sortedTroves;  // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset. uint256 internal totalYUSDDeposits;  // totalColl.tokens and totalColl.amounts should be the same length and always be the same length // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist // both lists are lengthened newColls internal totalColl;  // --- Data structures ---  struct FrontEnd {     uint256 kickbackRate;     bool registered; }  struct Deposit {     uint256 initialValue;     address frontEndTag; }  struct Snapshots {     mapping(address =&gt; uint256) S;     uint256 P;     uint256 G;     uint128 scale;     uint128 epoch; }  mapping(address =&gt; Deposit) public deposits; // depositor address -&gt; Deposit struct  /* depositSnapshots maintains an entry for each depositor  * that tracks P, S, G, scale, and epoch.  * depositor's snapshot is updated only when they  * deposit or withdraw from stability pool  * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount  * and to calculate how much Collateral amount the depositor is entitled to  */ mapping(address =&gt; Snapshots) public depositSnapshots; // depositor address -&gt; snapshots struct  mapping(address =&gt; FrontEnd) public frontEnds; // front end address -&gt; FrontEnd struct mapping(address =&gt; uint256) public frontEndStakes; // front end address -&gt; last recorded total deposits, tagged with that front end mapping(address =&gt; Snapshots) public frontEndSnapshots; // front end address -&gt; snapshots struct  /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,  * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.  *  * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t  * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.  */ uint256 public P = DECIMAL_PRECISION;  uint256 public constant SCALE_FACTOR = 1e9;  // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1 uint128 public currentScale;  // With each offset that fully empties the Pool, the epoch is incremented by 1 uint128 public currentEpoch;  /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,  * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.  *  * The 'S' sums are stored in a nested mapping (epoch =&gt; scale =&gt; sum):  *  * - The inner mapping records the sum S at different scales  * - The middle mapping records the (scale =&gt; sum) mappings, for different epochs.  * - The outer mapping records the (collateralType =&gt; (epoch =&gt; (scale =&gt; sum)) mappings  */ mapping(address =&gt; mapping(uint128 =&gt; mapping(uint128 =&gt; uint256))) public epochToScaleToSum;  /*  * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of  *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.  *  *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.  *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.  */ mapping(uint128 =&gt; mapping(uint128 =&gt; uint256)) public epochToScaleToG;  // Error tracker for the error correction in the YETI issuance calculation uint256 public lastYETIError; // Error trackers for the error correction in the offset calculation uint256[] public lastAssetError_Offset; uint256 public lastYUSDLossError_Offset;  // --- Events ---  event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts); event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts); event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);  event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress); event TroveManagerAddressChanged(address _newTroveManagerAddress); event ActivePoolAddressChanged(address _newActivePoolAddress); event DefaultPoolAddressChanged(address _newDefaultPoolAddress); event YUSDTokenAddressChanged(address _newYUSDTokenAddress); event SortedTrovesAddressChanged(address _newSortedTrovesAddress); event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);  event P_Updated(uint256 _P); event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale); event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale); event EpochUpdated(uint128 _currentEpoch); event ScaleUpdated(uint128 _currentScale);  event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate); event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);  event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G); event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G); event UserDepositChanged(address indexed _depositor, uint256 _newDeposit); event FrontEndStakeChanged(     address indexed _frontEnd,     uint256 _newFrontEndStake,     address _depositor );  event GainsWithdrawn(     address indexed _depositor,     address[] collaterals,     uint256[] _amounts,     uint256 _YUSDLoss ); event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI); event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI); event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);  // --- Contract setters ---  function setAddresses(     address _borrowerOperationsAddress,     address _troveManagerAddress,     address _activePoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _communityIssuanceAddress,     address _whitelistAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_troveManagerAddress);     checkContract(_activePoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_communityIssuanceAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);     troveManager = ITroveManager(_troveManagerAddress);     activePool = IActivePool(_activePoolAddress);     yusdToken = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     communityIssuance = ICommunityIssuance(_communityIssuanceAddress);     whitelist = IWhitelist(_whitelistAddress);      troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     whitelistAddress = _whitelistAddress;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit TroveManagerAddressChanged(_troveManagerAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);      _renounceOwnership(); }  // --- Getters for public variables. Required by IPool interface ---  // total VC of collateral in Stability Pool function getVC() external view override returns (uint256) {     return _getVCColls(totalColl); }  function getCollateral(address _collateral) external view override returns (uint256) {     uint256 collateralIndex = whitelist.getIndex(_collateral);     return totalColl.amounts[collateralIndex]; }  /*  * Returns all collateral balances in state. Not necessarily the contract's actual balances.  */ function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {     return (totalColl.tokens, totalColl.amounts); }  function getTotalYUSDDeposits() external view override returns (uint256) {     return totalYUSDDeposits; }  // --- External Depositor Functions ---  /*  provideToSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Tags the deposit with the provided front end tag param, if it's a new deposit  * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Increases deposit and tagged front end's stake, and takes new snapshots for each.  */ function provideToSP(uint256 _amount, address _frontEndTag) external override {     _requireFrontEndIsRegisteredOrZero(_frontEndTag);     _requireFrontEndNotRegistered(msg.sender);     _requireNonZeroAmount(_amount);      uint256 initialDeposit = deposits[msg.sender].initialValue;      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      if (initialDeposit == 0) {         _setFrontEndTag(msg.sender, _frontEndTag);     }     (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);     uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake:     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool     // and throws an event     _sendYUSDtoStabilityPool(msg.sender, _amount);      uint256 newDeposit = compoundedYUSDDeposit.add(_amount);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  /*  withdrawFromSP():  *  * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends  * - Removes the deposit's front end tag if it is a full withdrawal  * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor  * - Sends the tagged front end's accumulated YETI gains to the tagged front end  * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.  *  * If _amount &gt; userDeposit, the user withdraws all of their compounded deposit.  */ function withdrawFromSP(uint256 _amount) external override {     if (_amount != 0) {         _requireNoUnderCollateralizedTroves();     }     uint256 initialDeposit = deposits[msg.sender].initialValue;     _requireUserHasDeposit(initialDeposit);      ICommunityIssuance communityIssuanceCached = communityIssuance;      _triggerYETIIssuance(communityIssuanceCached);      (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);      uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);      uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);     uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log      // First pay out any YETI gains     address frontEnd = deposits[msg.sender].frontEndTag;     _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);      // Update front end stake     uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);     uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);     _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);     emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);      _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);      // Update deposit     uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);     _updateDepositAndSnapshots(msg.sender, newDeposit);     emit UserDepositChanged(msg.sender, newDeposit);      emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log      _sendGainsToDepositor(msg.sender, assets, amounts); }  // --- YETI issuance functions ---  function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {     uint256 YETIIssuance = _communityIssuance.issueYETI();     _updateG(YETIIssuance); }  function _updateG(uint256 _YETIIssuance) internal {     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     /*      * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later      * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.      *      */     if (totalYUSD == 0 || _YETIIssuance == 0) {         return;     }      uint256 YETIPerUnitStaked;     YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);      uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);     epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]         .add(marginalYETIGain);      emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale); }  function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)     internal     returns (uint256) {     /*      * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the      * cumulative error low in the running total G:      *      * 1) Form a numerator which compensates for the floor division error that occurred the last time this      * function was called.      * 2) Calculate "per-unit-staked" ratio.      * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.      * 4) Store this error for use in the next correction when this function is called.      * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.      */     uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);      uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);     lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));      return YETIPerUnitStaked; }  // --- Liquidation functions ---  /*  * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)  * and transfers the Trove's collateral from ActivePool to StabilityPool.  * Only called by liquidation functions in the TroveManager.  */ function offset(     uint256 _debtToOffset,     address[] memory _tokens,     uint256[] memory _amountsAdded ) external override {     _requireCallerIsTML();     uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD     if (totalYUSD == 0 || _debtToOffset == 0) {         return;     }      _triggerYETIIssuance(communityIssuance);      (         uint256[] memory AssetGainPerUnitStaked,         uint256 YUSDLossPerUnitStaked     ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);      _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P     _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset); }  // --- Offset helper functions ---   /* * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep * the cumulative error in the P and S state variables low: * * 1) Form numerators which compensate for the floor division errors that occurred the last time this * function was called. * 2) Calculate "per-unit-staked" ratios. * 3) Multiply each ratio back by its denominator, to reveal the current floor division error. * 4) Store these errors for use in the next correction when this function is called. * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended. */ function _computeRewardsPerUnitStaked(     address[] memory _tokens,     uint256[] memory _amountsAdded,     uint256 _debtToOffset,     uint256 _totalYUSDDeposits ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {     uint256 amountsLen = _amountsAdded.length;     uint256[] memory CollateralNumerators = new uint256[](amountsLen);     uint256 currentP = P;      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(             lastAssetError_Offset[tokenIDX]         );     }      require(_debtToOffset &lt;= _totalYUSDDeposits, "SP:This debt less than totalYUSD");     if (_debtToOffset == _totalYUSDDeposits) {         YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit         lastYUSDLossError_Offset = 0;     } else {         uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(             lastYUSDLossError_Offset         );         /*          * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,          * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.          */         YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);         lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(             YUSDLossNumerator         );     }      AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);     for (uint256 i; i &lt; amountsLen; ++i) {         AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);     }      for (uint256 i; i &lt; amountsLen; ++i) {         uint256 tokenIDX = whitelist.getIndex(_tokens[i]);         lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(             AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)         );     }  }  // Update the Stability Pool reward sum S and product P function _updateRewardSumAndProduct(     address[] memory _assets,     uint256[] memory _AssetGainPerUnitStaked,     uint256 _YUSDLossPerUnitStaked ) internal {     uint256 currentP = P;     uint256 newP;      require(_YUSDLossPerUnitStaked &lt;= DECIMAL_PRECISION, "SP: YUSDLoss &lt; 1");     /*      * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.      * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)      */     uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;      /*      * Calculate the new S first, before we update P.      * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit      * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.      *      * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.      */     uint256 assetsLen = _assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address asset = _assets[i];          // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.         uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];         uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);          epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;         emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);     }      // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P     if (newProductFactor == 0) {         currentEpoch = currentEpochCached.add(1);         emit EpochUpdated(currentEpoch);         currentScale = 0;         emit ScaleUpdated(currentScale);         newP = DECIMAL_PRECISION;          // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale     } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) &lt; SCALE_FACTOR) {         newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);         currentScale = currentScaleCached.add(1);         emit ScaleUpdated(currentScale);     } else {         newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);     }      require(newP != 0, "SP: P = 0");     P = newP;     emit P_Updated(newP); }  // Internal function to move offset collateral and debt between pools.  function _moveOffsetCollAndDebt(     address[] memory _collsToAdd,     uint256[] memory _amountsToAdd,     uint256 _debtToOffset ) internal {     IActivePool activePoolCached = activePool;     // Cancel the liquidated YUSD debt with the YUSD in the stability pool     activePoolCached.decreaseYUSDDebt(_debtToOffset);     _decreaseYUSD(_debtToOffset);      // Burn the debt that was successfully offset     yusdToken.burn(address(this), _debtToOffset);      activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd); }  // Decreases YUSD Stability pool balance.  function _decreaseYUSD(uint256 _amount) internal {     uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  // --- Reward calculator functions for depositor and front end ---  /* Calculates the gains earned by the deposit since its last snapshots were taken.  * Given by the formula:  E = d0 * (S - S(0))/P(0)  * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.  * d0 is the last recorded deposit value.  * returns assets, amounts  */ function getDepositorGains(address _depositor)     public     view     override     returns (address[] memory, uint256[] memory) {     uint256 initialDeposit = deposits[_depositor].initialValue;      if (initialDeposit == 0) {         address[] memory emptyAddress = new address[](0);         uint256[] memory emptyUint = new uint256[](0);         return (emptyAddress, emptyUint);     }      Snapshots storage snapshots = depositSnapshots[_depositor];      return _calculateGains(initialDeposit, snapshots); }  // get gains on each possible asset by looping through // assets with _getGainFromSnapshots function function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)     internal     view     returns (address[] memory assets, uint256[] memory amounts) {     assets = whitelist.getValidCollateral();     uint256 assetsLen = assets.length;     amounts = new uint256[](assetsLen);     for (uint256 i; i &lt; assetsLen; ++i) {         amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);     } }  // gets the gain in S for a given asset // for a user who deposited initialDeposit function _getGainFromSnapshots(     uint256 initialDeposit,     Snapshots storage snapshots,     address asset ) internal view returns (uint256) {     /*      * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.      * If it does, the second portion of the Collateral amount gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint256 S_Snapshot = snapshots.S[asset];     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(         S_Snapshot     );             uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]         .div(SCALE_FACTOR);      uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return assetGain; }  /*  * Calculate the YETI gain earned by a deposit since its last snapshots were taken.  * Given by the formula:  YETI = d0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  * d0 is the last recorded deposit value.  */ function getDepositorYETIGain(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      address frontEndTag = deposits[_depositor].frontEndTag;      /*      * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.      * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through      * which they made their deposit.      */     uint256 kickbackRate = frontEndTag == address(0)         ? DECIMAL_PRECISION         : frontEnds[frontEndTag].kickbackRate;      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 YETIGain = kickbackRate         .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))         .div(DECIMAL_PRECISION);      return YETIGain; }  /*  * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)  * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.  *  * D0 is the last recorded value of the front end's total tagged deposits.  */ function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;     uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 YETIGain = frontEndShare         .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))         .div(DECIMAL_PRECISION);     return YETIGain; }  function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     /*      * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.      * If it does, the second portion of the YETI gain is scaled by 1e9.      * If the gain spans no scale change, the second portion will be 0.      */     uint128 epochSnapshot = snapshots.epoch;     uint128 scaleSnapshot = snapshots.scale;     uint256 G_Snapshot = snapshots.G;     uint256 P_Snapshot = snapshots.P;      uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);     uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(         SCALE_FACTOR     );      uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(         DECIMAL_PRECISION     );      return YETIGain; }  // --- Compounded deposit and compounded front end stake ---  /*  * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.  */ function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {     uint256 initialDeposit = deposits[_depositor].initialValue;     if (initialDeposit == 0) {         return 0;     }      Snapshots storage snapshots = depositSnapshots[_depositor];      uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);     return compoundedDeposit; }  /*  * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)  * where P(0) is the depositor's snapshot of the product P, taken at the last time  * when one of the front end's tagged deposits updated their deposit.  *  * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.  */ function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {     uint256 frontEndStake = frontEndStakes[_frontEnd];     if (frontEndStake == 0) {         return 0;     }      Snapshots storage snapshots = frontEndSnapshots[_frontEnd];      uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);     return compoundedFrontEndStake; }  // Internal function, used to calculate compounded deposits and compounded front end stakes. // returns 0 if the snapshots were taken prior to a a pool-emptying event // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or // If the scaleDiff is 0 or 1, // then adjust for changes in P and scale changes to calculate a compoundedStake. // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this // otherwise, just return 0. function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)     internal     view     returns (uint256) {     uint256 snapshot_P = snapshots.P;     uint128 scaleSnapshot = snapshots.scale;     uint128 epochSnapshot = snapshots.epoch;      // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0     if (epochSnapshot &lt; currentEpoch) {         return 0;     }      uint256 compoundedStake;     uint128 scaleDiff = currentScale.sub(scaleSnapshot);      /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,      * account for it. If more than one scale change was made, then the stake has decreased by a factor of      * at least 1e-9 -- so return 0.      */     if (scaleDiff == 0) {         compoundedStake = initialStake.mul(P).div(snapshot_P);     } else if (scaleDiff == 1) {         compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);     } else {         // if scaleDiff &gt;= 2         compoundedStake = 0;     }      /*      * If compounded deposit is less than a billionth of the initial deposit, return 0.      *      * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error      * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less      * than it's theoretical value.      *      * Thus it's unclear whether this line is still really needed.      */     if (compoundedStake &lt; initialStake.div(1e9)) {         return 0;     }      return compoundedStake; }  // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---  // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {     yusdToken.sendToPool(_address, address(this), _amount);     uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);     totalYUSDDeposits = newTotalYUSDDeposits;     emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits); }  function _sendGainsToDepositor(     address _to,     address[] memory assets,     uint256[] memory amounts ) internal {     uint256 assetsLen = assets.length;     require(assetsLen == amounts.length, "SP:Length mismatch");     uint256 thisAmounts;     address thisAsset;     for (uint256 i; i &lt; assetsLen; ++i) {         thisAmounts = amounts[i];         thisAsset = assets[i];         if (whitelist.isWrapped(thisAsset)) {             // In this case update the rewards from the treasury to the caller              IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);             // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param.              IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);         } else {             IERC20(thisAsset).safeTransfer(_to, thisAmounts);         }     }     totalColl.amounts = _leftSubColls(totalColl, assets, amounts); }  // Send YUSD to user and decrease YUSD in Pool function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {     if (YUSDWithdrawal == 0) {         return;     }      yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);     _decreaseYUSD(YUSDWithdrawal); }  // --- External Front End functions ---  // Front end makes a one-time selection of kickback rate upon registering function registerFrontEnd(uint256 _kickbackRate) external override {     _requireFrontEndNotRegistered(msg.sender);     _requireUserHasNoDeposit(msg.sender);     _requireValidKickbackRate(_kickbackRate);      frontEnds[msg.sender].kickbackRate = _kickbackRate;     frontEnds[msg.sender].registered = true;      emit FrontEndRegistered(msg.sender, _kickbackRate); }  // --- Stability Pool Deposit Functionality ---  function _setFrontEndTag(address _depositor, address _frontEndTag) internal {     deposits[_depositor].frontEndTag = _frontEndTag;     emit FrontEndTagSet(_depositor, _frontEndTag); }  // if _newValue is zero, delete snapshot for given _depositor and emit event // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots // with current values for P, S, G, scale and epoch and then emit event. function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {     deposits[_depositor].initialValue = _newValue;      if (_newValue == 0) {         delete deposits[_depositor].frontEndTag;         address[] memory colls = whitelist.getValidCollateral();         uint256 collsLen = colls.length;         for (uint256 i; i &lt; collsLen; ++i) {             depositSnapshots[_depositor].S[colls[i]] = 0;         }         depositSnapshots[_depositor].P = 0;         depositSnapshots[_depositor].G = 0;         depositSnapshots[_depositor].epoch = 0;         depositSnapshots[_depositor].scale = 0;         emit DepositSnapshotUpdated(_depositor, 0, 0);         return;     }     uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      address[] memory allColls = whitelist.getValidCollateral();      // Get S and G for the current epoch and current scale     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address token = allColls[i];         uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][             currentScaleCached         ];         depositSnapshots[_depositor].S[token] = currentSForToken;     }      uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor     depositSnapshots[_depositor].P = currentP;     depositSnapshots[_depositor].G = currentG;     depositSnapshots[_depositor].scale = currentScaleCached;     depositSnapshots[_depositor].epoch = currentEpochCached;      emit DepositSnapshotUpdated(_depositor, currentP, currentG); }  function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {     frontEndStakes[_frontEnd] = _newValue;      if (_newValue == 0) {         delete frontEndSnapshots[_frontEnd];         emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);         return;     }      uint128 currentScaleCached = currentScale;     uint128 currentEpochCached = currentEpoch;     uint256 currentP = P;      // Get G for the current epoch and current scale     uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];      // Record new snapshots of the latest running product P and sum G for the front end     frontEndSnapshots[_frontEnd].P = currentP;     frontEndSnapshots[_frontEnd].G = currentG;     frontEndSnapshots[_frontEnd].scale = currentScaleCached;     frontEndSnapshots[_frontEnd].epoch = currentEpochCached;      emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG); }  function _payOutYETIGains(     ICommunityIssuance _communityIssuance,     address _depositor,     address _frontEnd ) internal {     // Pay out front end's YETI gain     if (_frontEnd != address(0)) {         uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);         _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);         emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);     }      // Pay out depositor's YETI gain     uint256 depositorYETIGain = getDepositorYETIGain(_depositor);     _communityIssuance.sendYETI(_depositor, depositorYETIGain);     emit YETIPaidToDepositor(_depositor, depositorYETIGain); }  // --- 'require' functions ---  function _requireNoUnderCollateralizedTroves() internal view {     address lowestTrove = sortedTroves.getLast();     uint256 ICR = troveManager.getCurrentICR(lowestTrove);     require(ICR &gt;= MCR, "SP:No Withdraw when troveICR&lt;MCR"); }  function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {     require(_initialDeposit != 0, "SP: require nonzero deposit"); }  function _requireUserHasNoDeposit(address _address) internal view {     uint256 initialDeposit = deposits[_address].initialValue;     require(initialDeposit == 0, "SP: User must have no deposit"); }  function _requireNonZeroAmount(uint256 _amount) internal pure {     require(_amount != 0, "SP: Amount must be non-zero"); }  function _requireFrontEndNotRegistered(address _address) internal view {     require(         !frontEnds[_address].registered,         "SP: Frontend already registered"     ); }  function _requireFrontEndIsRegisteredOrZero(address _address) internal view {     require(         frontEnds[_address].registered || _address == address(0),         "SP: Frontend not registered"     ); }  function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {     require(         _kickbackRate &lt;= DECIMAL_PRECISION,         "SP:Invalid Kickback rate"     ); }  function _requireCallerIsWhitelist() internal view {     if (msg.sender != whitelistAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsActivePool() internal view {     if (msg.sender != address(activePool)) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != address(troveManagerLiquidationsAddress)) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view {     revert("SP: External caller not allowed"); }  // Should be called by ActivePool // __after__ collateral is transferred to this contract from Active Pool function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)     external     override {     _requireCallerIsActivePool();     totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);     emit StabilityPoolBalancesUpdated(_tokens, _amounts); }  // should be called anytime a collateral is added to whitelist function addCollateralType(address _collateral) external override {     _requireCallerIsWhitelist();     lastAssetError_Offset.push(0);     totalColl.tokens.push(_collateral);     totalColl.amounts.push(0); }  // Gets reward snapshot S for certain collateral and depositor.  function getDepositSnapshotS(address _depositor, address _collateral)     external     view     override     returns (uint256) {     return depositSnapshots[_depositor].S[_collateral]; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:56:14 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/IBorrowerOperations.sol";
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/ICommunityIssuance.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/IERC20.sol";
import "./Interfaces/IWAsset.sol";
import "./Dependencies/LiquityBase.sol";
import "./Dependencies/SafeMath.sol";
import "./Dependencies/LiquitySafeMath128.sol";
import "./Dependencies/Ownable.sol";
import "./Dependencies/CheckContract.sol";
import "./Dependencies/SafeERC20.sol";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a "compounded deposit": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = "StabilityPool";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a "feedback" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate "per-unit-staked" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a "feedback" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate "per-unit-staked" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, "SP:This debt less than totalYUSD");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want "slightly too much" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, "SP: YUSDLoss < 1");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, "SP: P = 0");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P "favors the Pool", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, "SP:Length mismatch");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, "SP:No Withdraw when troveICR<MCR");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, "SP: require nonzero deposit");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, "SP: User must have no deposit");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, "SP: Amount must be non-zero");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            "SP: Frontend already registered"
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            "SP: Frontend not registered"
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            "SP:Invalid Kickback rate"
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert("SP: External caller not allowed");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

