[2024-23-08 10:45:54 INFO] **[Preprocessing]**

**ChatDev Starts** (20240823104554)

**Timestamp**: 20240823104554

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}


**project_name**: RealWorld_BA_66_TroveManagerLiquidations

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_66_TroveManagerLiquidations_RealWord_20240823104554.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-23-08 10:45:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\n\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n\n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n\n    address internal troveManagerAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    address yetiFinanceTreasury;\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n\n            troveManager.removeStakeTLR(_borrower);\n\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:45:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:45:54 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-23-08 10:45:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:45:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16588
completion_tokens: 1
total_tokens: 16589
cost: $-1.000000


[2024-23-08 10:45:58 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Let's

[2024-23-08 10:45:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n    address internal borrowerOperationsAddress;\n    IStabilityPool internal stabilityPoolContract;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdTokenContract;\n    IYETIToken internal yetiTokenContract;\n    ISYETI internal sYETIContract;\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n    address internal gasPoolAddress;\n    address internal troveManagerAddress;\n    ISortedTroves internal sortedTroves;\n    ICollSurplusPool internal collSurplusPool;\n    address yetiFinanceTreasury;\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n        _renounceOwnership();\n    }\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            troveManager.removeStakeTLR(_borrower);\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n            troveManager.removeStakeTLR(_borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    /\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n /\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n    address internal borrowerOperationsAddress;\n    IStabilityPool internal stabilityPoolContract;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdTokenContract;\n    IYETIToken internal yetiTokenContract;\n    ISYETI internal sYETIContract;\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n    address internal gasPoolAddress;\n    address internal troveManagerAddress;\n    ISortedTroves internal sortedTroves;\n    ICollSurplusPool internal collSurplusPool;\n    address yetiFinanceTreasury;\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n        _renounceOwnership();\n    }\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            troveManager.removeStakeTLR(_borrower);\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n            troveManager.removeStakeTLR(_borrower);\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:45:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:45:58 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";
/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */
contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";

    address internal borrowerOperationsAddress;
    IStabilityPool internal stabilityPoolContract;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdTokenContract;
    IYETIToken internal yetiTokenContract;
    ISYETI internal sYETIContract;
    ITroveManagerLiquidations internal troveManagerLiquidations;
    address internal gasPoolAddress;
    address internal troveManagerAddress;
    ISortedTroves internal sortedTroves;
    ICollSurplusPool internal collSurplusPool;
    address yetiFinanceTreasury;
    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }
    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }
    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }
    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }
    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }
    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }
    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );
    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);
        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;
        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);
        _renounceOwnership();
    }
    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");
        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;
        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;
        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();
        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }
        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }
        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        vars.liquidatedDebt = totals.totalDebtInSequence;
        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);
        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }
    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;
        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }
                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);
                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );
                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);
                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);
                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }
    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;
        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }
    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;
        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);
        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);
        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }
        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );
        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);
        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }

    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;
        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove
        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);
        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }
        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);
            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;
            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            troveManager.removeStakeTLR(_borrower);
            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );
            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );
            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");
            troveManager.removeStakeTLR(_borrower);
            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );
            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }
        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }
    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }
    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);
        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);
            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);
            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);
            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);
            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);
            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);
            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);
            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);
            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);
                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);
                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }
    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }
    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;
        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);
        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);
        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;
        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);
        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);
        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);
        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);
            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }
    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }
        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }
    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }
    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }

    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");
        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";
/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */
contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";

    address internal borrowerOperationsAddress;
    IStabilityPool internal stabilityPoolContract;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdTokenContract;
    IYETIToken internal yetiTokenContract;
    ISYETI internal sYETIContract;
    ITroveManagerLiquidations internal troveManagerLiquidations;
    address internal gasPoolAddress;
    address internal troveManagerAddress;
    ISortedTroves internal sortedTroves;
    ICollSurplusPool internal collSurplusPool;
    address yetiFinanceTreasury;
    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }
    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }
    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }
    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }
    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }
    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }
    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );
    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);
        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;
        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);
        _renounceOwnership();
    }
    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");
        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;
        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;
        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();
        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }
        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }
        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        vars.liquidatedDebt = totals.totalDebtInSequence;
        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);
        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }
    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;
        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }
                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);
                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );
                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);
                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);
                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }
    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;
        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );
                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));
                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }
    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;
        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);
        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);
        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }
        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );
        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);
        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }

    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;
        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove
        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);
        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }
        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);
            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;
            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            troveManager.removeStakeTLR(_borrower);
            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );
            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );
            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");
            troveManager.removeStakeTLR(_borrower);
            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );
            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);
            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }
        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }
    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }
    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);
        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);
            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);
            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);
            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);
            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);
            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);
            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);
            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);
            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);
                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);
                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }
    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }
    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;
        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);
        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);
        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;
        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;
        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;
        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);
        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);
        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);
        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);
            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }
    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }
        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }
    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }
    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }

    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");
        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-23-08 10:46:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24937
completion_tokens: 1
total_tokens: 24938
cost: $-1.000000


[2024-23-08 10:46:01 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Security

[2024-23-08 10:46:01 INFO] **[Seminar Conclusion]**:

 Security

[2024-23-08 10:46:01 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-23-08 10:46:01 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 10:46:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\n\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n\n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n\n    address internal troveManagerAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    address yetiFinanceTreasury;\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n\n            troveManager.removeStakeTLR(_borrower);\n\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:46:04 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:04 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16579
completion_tokens: 1
total_tokens: 16580
cost: $-1.000000


[2024-23-08 10:46:04 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

###

[2024-23-08 10:46:04 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:46:04 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 10:46:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:04 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:46:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8349
completion_tokens: 812
total_tokens: 9161
cost: $-1.000000


[2024-23-08 10:46:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Based on the provided smart contract code for `TroveManagerLiquidations`, here is a succinct summary of the potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to other contracts (e.g., `stabilityPoolCached.offset`, `troveManager.redistributeDebtAndColl`, etc.) before updating its state. This could allow malicious contracts to re-enter the function and manipulate state variables.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, any arithmetic operations that involve external inputs or calculations should be carefully reviewed to ensure they do not lead to unexpected behavior.

3. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical addresses. If ownership is compromised, a malicious actor could redirect funds or manipulate contract behavior. The ownership transfer mechanism should be reviewed for security.

4. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function iterates over an array of troves. If the array is too large, it may exceed the gas limit, causing the transaction to fail. This could be exploited by an attacker to prevent legitimate liquidations.

5. **Lack of Input Validation**:
   - The contract does not validate the input parameters in several functions (e.g., checking if addresses are non-zero). This could lead to unexpected behavior or vulnerabilities.

6. **Potential for Denial of Service (DoS)**:
   - If a trove is non-active or if the stability pool is empty, the contract may skip liquidations without handling the situation properly, potentially leading to a situation where legitimate liquidations cannot occur.

7. **Event Emission**:
   - The contract emits events for significant state changes, but it should ensure that all critical state changes are logged to provide a complete audit trail.

8. **Fallback Function**:
   - The contract does not have a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if Ether is sent to the contract.

### Comprehensive Analysis Report:

The `TroveManagerLiquidations` contract implements complex liquidation logic for a lending protocol. While it appears to be well-structured, several security vulnerabilities could pose risks to the integrity and availability of the contract. 

1. **Reentrancy attacks** are a significant concern due to the external calls made before state changes. Implementing a reentrancy guard or using the Checks-Effects-Interactions pattern can mitigate this risk.

2. **Arithmetic operations** should be scrutinized, especially in functions that handle user inputs or external data. Although Solidity 0.6.x mitigates overflow/underflow risks, careful coding practices should still be followed.

3. **Access control** mechanisms must be robust. The ownership model should be reviewed, and potentially a multi-signature wallet could be employed to manage critical functions.

4. **Gas limit issues** should be addressed by implementing mechanisms to handle large arrays, such as breaking down operations into smaller batches or implementing a queue system.

5. **Input validation** is crucial to prevent unexpected behavior. All functions should validate their inputs to ensure they meet expected criteria.

6. **Denial of Service (DoS)** vulnerabilities should be mitigated by ensuring that the contract can handle edge cases gracefully, such as empty pools or inactive troves.

7. **Event logging** should be comprehensive to ensure that all critical state changes are recorded, providing transparency and aiding in audits.

8. **Fallback functions** should be implemented to handle unexpected Ether transfers, ensuring that funds are not lost.

In conclusion, while the `TroveManagerLiquidations` contract serves a vital function within the lending protocol, it requires a thorough security review and potential refactoring to address the identified vulnerabilities. Implementing best practices in Solidity programming and security measures will enhance the contract's resilience against attacks and ensure the safety of user funds.

[2024-23-08 10:46:15 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for `TroveManagerLiquidations`, here is a succinct summary of the potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to other contracts (e.g., `stabilityPoolCached.offset`, `troveManager.redistributeDebtAndColl`, etc.) before updating its state. This could allow malicious contracts to re-enter the function and manipulate state variables.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, any arithmetic operations that involve external inputs or calculations should be carefully reviewed to ensure they do not lead to unexpected behavior.

3. **Access Control Issues**:
   - The `setAddresses` function allows the owner to set critical addresses. If ownership is compromised, a malicious actor could redirect funds or manipulate contract behavior. The ownership transfer mechanism should be reviewed for security.

4. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function iterates over an array of troves. If the array is too large, it may exceed the gas limit, causing the transaction to fail. This could be exploited by an attacker to prevent legitimate liquidations.

5. **Lack of Input Validation**:
   - The contract does not validate the input parameters in several functions (e.g., checking if addresses are non-zero). This could lead to unexpected behavior or vulnerabilities.

6. **Potential for Denial of Service (DoS)**:
   - If a trove is non-active or if the stability pool is empty, the contract may skip liquidations without handling the situation properly, potentially leading to a situation where legitimate liquidations cannot occur.

7. **Event Emission**:
   - The contract emits events for significant state changes, but it should ensure that all critical state changes are logged to provide a complete audit trail.

8. **Fallback Function**:
   - The contract does not have a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if Ether is sent to the contract.

### Comprehensive Analysis Report:

The `TroveManagerLiquidations` contract implements complex liquidation logic for a lending protocol. While it appears to be well-structured, several security vulnerabilities could pose risks to the integrity and availability of the contract. 

1. **Reentrancy attacks** are a significant concern due to the external calls made before state changes. Implementing a reentrancy guard or using the Checks-Effects-Interactions pattern can mitigate this risk.

2. **Arithmetic operations** should be scrutinized, especially in functions that handle user inputs or external data. Although Solidity 0.6.x mitigates overflow/underflow risks, careful coding practices should still be followed.

3. **Access control** mechanisms must be robust. The ownership model should be reviewed, and potentially a multi-signature wallet could be employed to manage critical functions.

4. **Gas limit issues** should be addressed by implementing mechanisms to handle large arrays, such as breaking down operations into smaller batches or implementing a queue system.

5. **Input validation** is crucial to prevent unexpected behavior. All functions should validate their inputs to ensure they meet expected criteria.

6. **Denial of Service (DoS)** vulnerabilities should be mitigated by ensuring that the contract can handle edge cases gracefully, such as empty pools or inactive troves.

7. **Event logging** should be comprehensive to ensure that all critical state changes are recorded, providing transparency and aiding in audits.

8. **Fallback functions** should be implemented to handle unexpected Ether transfers, ensuring that funds are not lost.

In conclusion, while the `TroveManagerLiquidations` contract serves a vital function within the lending protocol, it requires a thorough security review and potential refactoring to address the identified vulnerabilities. Implementing best practices in Solidity programming and security measures will enhance the contract's resilience against attacks and ensure the safety of user funds.

[2024-23-08 10:46:15 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 10:46:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\n\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n\n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n\n    address internal troveManagerAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    address yetiFinanceTreasury;\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n\n            troveManager.removeStakeTLR(_borrower);\n\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:15 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:46:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16579
completion_tokens: 1
total_tokens: 16580
cost: $-1.000000


[2024-23-08 10:46:18 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

###

[2024-23-08 10:46:18 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:46:18 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 10:46:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:18 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:46:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8349
completion_tokens: 821
total_tokens: 9170
cost: $-1.000000


[2024-23-08 10:46:29 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

### Summary of Security Vulnerabilities in the TroveManagerLiquidations Contract

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to other contracts (e.g., `stabilityPoolCached.offset`, `troveManager.redistributeDebtAndColl`, etc.) before updating internal state variables. This could allow a malicious contract to re-enter the function and manipulate state variables unexpectedly.

2. **Arithmetic Issues**:
   - The contract uses Solidity version 0.6.11, which does not include built-in overflow and underflow checks. Although the code uses SafeMath for arithmetic operations, there is still a risk if any arithmetic operations are performed without SafeMath.

3. **Access Control**:
   - The `setAddresses` function allows the owner to set critical addresses. If the owner’s address is compromised, a malicious actor could redirect funds or manipulate contract behavior. The contract lacks a mechanism to revoke ownership or transfer ownership securely.

4. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function iterates over the `_troveArray` without a limit on the number of troves that can be processed in one transaction. This could lead to excessive gas consumption and potential transaction failures if the array is too large.

5. **Lack of Input Validation**:
   - The contract does not validate the input parameters for functions like `batchLiquidateTroves`. For instance, it does not check if the addresses in `_troveArray` are valid or if they correspond to active troves.

6. **Potential for Denial of Service (DoS)**:
   - If a trove in `_troveArray` is non-active or has an invalid state, the entire batch liquidation could be affected, leading to a DoS scenario where legitimate liquidations cannot be processed.

7. **Event Emission**:
   - The contract emits events for significant actions (e.g., `Liquidation`, `TroveLiquidated`), but it does not emit events for all state-changing actions. This could hinder tracking and auditing of contract behavior.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `_100pct`, etc.) that could be problematic if they need to be changed in the future. This reduces flexibility and adaptability.

### Comprehensive Analysis Report

The TroveManagerLiquidations contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include the potential for reentrancy attacks due to external calls made before state updates, which could lead to unexpected behavior and loss of funds. Additionally, the lack of built-in overflow checks in the Solidity version used poses a risk for arithmetic errors, despite the use of SafeMath.

Access control mechanisms are insufficient, as the contract allows the owner to set critical addresses without a secure revocation process. The potential for Denial of Service (DoS) attacks exists due to the lack of input validation and the possibility of processing large arrays in a single transaction, which could lead to excessive gas consumption.

Moreover, the contract's reliance on hardcoded values limits its flexibility and adaptability, while the absence of comprehensive event emissions may hinder effective tracking and auditing of contract actions.

To enhance the security posture of the TroveManagerLiquidations contract, it is recommended to implement the following measures:
- Introduce reentrancy guards to critical functions.
- Upgrade to a newer version of Solidity that includes built-in overflow checks or ensure all arithmetic operations use SafeMath.
- Implement a more robust access control mechanism, including ownership transfer and revocation capabilities.
- Limit the size of input arrays or implement pagination for batch processing.
- Validate input parameters thoroughly to prevent processing of invalid or non-active troves.
- Emit events for all significant state changes to improve transparency and auditability.
- Replace hardcoded values with configurable parameters to enhance flexibility.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-23-08 10:46:29 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the TroveManagerLiquidations Contract

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to other contracts (e.g., `stabilityPoolCached.offset`, `troveManager.redistributeDebtAndColl`, etc.) before updating internal state variables. This could allow a malicious contract to re-enter the function and manipulate state variables unexpectedly.

2. **Arithmetic Issues**:
   - The contract uses Solidity version 0.6.11, which does not include built-in overflow and underflow checks. Although the code uses SafeMath for arithmetic operations, there is still a risk if any arithmetic operations are performed without SafeMath.

3. **Access Control**:
   - The `setAddresses` function allows the owner to set critical addresses. If the owner’s address is compromised, a malicious actor could redirect funds or manipulate contract behavior. The contract lacks a mechanism to revoke ownership or transfer ownership securely.

4. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function iterates over the `_troveArray` without a limit on the number of troves that can be processed in one transaction. This could lead to excessive gas consumption and potential transaction failures if the array is too large.

5. **Lack of Input Validation**:
   - The contract does not validate the input parameters for functions like `batchLiquidateTroves`. For instance, it does not check if the addresses in `_troveArray` are valid or if they correspond to active troves.

6. **Potential for Denial of Service (DoS)**:
   - If a trove in `_troveArray` is non-active or has an invalid state, the entire batch liquidation could be affected, leading to a DoS scenario where legitimate liquidations cannot be processed.

7. **Event Emission**:
   - The contract emits events for significant actions (e.g., `Liquidation`, `TroveLiquidated`), but it does not emit events for all state-changing actions. This could hinder tracking and auditing of contract behavior.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `_100pct`, etc.) that could be problematic if they need to be changed in the future. This reduces flexibility and adaptability.

### Comprehensive Analysis Report

The TroveManagerLiquidations contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include the potential for reentrancy attacks due to external calls made before state updates, which could lead to unexpected behavior and loss of funds. Additionally, the lack of built-in overflow checks in the Solidity version used poses a risk for arithmetic errors, despite the use of SafeMath.

Access control mechanisms are insufficient, as the contract allows the owner to set critical addresses without a secure revocation process. The potential for Denial of Service (DoS) attacks exists due to the lack of input validation and the possibility of processing large arrays in a single transaction, which could lead to excessive gas consumption.

Moreover, the contract's reliance on hardcoded values limits its flexibility and adaptability, while the absence of comprehensive event emissions may hinder effective tracking and auditing of contract actions.

To enhance the security posture of the TroveManagerLiquidations contract, it is recommended to implement the following measures:
- Introduce reentrancy guards to critical functions.
- Upgrade to a newer version of Solidity that includes built-in overflow checks or ensure all arithmetic operations use SafeMath.
- Implement a more robust access control mechanism, including ownership transfer and revocation capabilities.
- Limit the size of input arrays or implement pagination for batch processing.
- Validate input parameters thoroughly to prevent processing of invalid or non-active troves.
- Emit events for all significant state changes to improve transparency and auditability.
- Replace hardcoded values with configurable parameters to enhance flexibility.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-23-08 10:46:29 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 10:46:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\n\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n\n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n\n    address internal troveManagerAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    address yetiFinanceTreasury;\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n\n            troveManager.removeStakeTLR(_borrower);\n\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:29 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 10:46:34 INFO] Retrying request to /chat/completions in 0.980929 seconds
[2024-23-08 10:46:37 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:37 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 16579
completion_tokens: 1
total_tokens: 16580
cost: $-1.000000


[2024-23-08 10:46:37 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

###

[2024-23-08 10:46:37 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 10:46:37 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 10:46:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 10:46:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:38 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 10:46:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 10:46:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8349
completion_tokens: 901
total_tokens: 9250
cost: $-1.000000


[2024-23-08 10:46:49 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Based on the provided Solidity smart contract code for `TroveManagerLiquidations`, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to other contracts (e.g., `sendCollaterals`, `returnFromPool`). If these external contracts are malicious, they could exploit the contract by re-entering functions before the state is updated, leading to unexpected behavior.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected results if not properly handled. Ensure that all arithmetic operations are safe and consider using SafeMath for clarity.

3. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function processes an array of troves, which could lead to excessive gas consumption if the array is large. This could cause transactions to fail due to exceeding the block gas limit.

4. **Access Control**:
   - The `setAddresses` function is marked as `onlyOwner`, but there is no check to ensure that the owner is not a malicious actor. If the ownership is compromised, the attacker could change critical addresses, leading to potential exploitation.

5. **Lack of Input Validation**:
   - Functions like `batchLiquidateTroves` do not validate the contents of the `_troveArray`. If an empty or invalid address is passed, it could lead to unexpected behavior or errors.

6. **Potential for Denial of Service (DoS)**:
   - If a trove is non-active or if the stability pool is empty, the liquidation process could be halted, leading to a denial of service for legitimate users.

7. **Event Emission**:
   - While events are emitted for significant actions, there may be a lack of comprehensive logging for all critical state changes, which could hinder tracking and debugging.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `PERCENT_DIVISOR`). If these values need to change, it would require a contract upgrade, which could be a point of failure.

9. **Lack of Fallback Function**:
   - The absence of a fallback function could lead to issues if the contract receives Ether or unexpected calls.

### Comprehensive Analysis Report:

The `TroveManagerLiquidations` contract is a complex piece of code that manages the liquidation of troves in a decentralized finance (DeFi) context. While it implements several necessary functionalities, the identified vulnerabilities pose significant risks to the integrity and security of the contract.

1. **Reentrancy**: The potential for reentrancy attacks necessitates careful management of external calls. Implementing the Checks-Effects-Interactions pattern can mitigate this risk.

2. **Arithmetic Operations**: Although Solidity 0.6.x provides built-in checks, it's prudent to ensure all arithmetic operations are explicitly safe, especially in complex calculations.

3. **Gas Limit Concerns**: The design should consider the implications of processing large arrays and implement mechanisms to handle gas limits effectively, possibly by batching operations or limiting the number of processed items.

4. **Access Control**: Strengthening access control measures and ensuring that ownership is secure is critical. Consider implementing multi-signature wallets or time-lock mechanisms for sensitive operations.

5. **Input Validation**: Robust input validation is essential to prevent unexpected behavior. Functions should validate inputs thoroughly before processing.

6. **Denial of Service Risks**: The contract should be designed to handle edge cases gracefully to avoid potential denial of service scenarios.

7. **Event Logging**: Comprehensive event logging will enhance transparency and facilitate easier debugging and tracking of contract interactions.

8. **Parameter Management**: Consider using a governance mechanism to manage critical parameters instead of hardcoding them, allowing for flexibility and adaptability.

9. **Fallback Function**: Implementing a fallback function can help manage unexpected Ether transfers and calls, ensuring the contract behaves as intended.

In conclusion, while the `TroveManagerLiquidations` contract serves a crucial role in the liquidation process, addressing the identified vulnerabilities is essential to ensure its security and reliability in a production environment. A thorough audit and testing phase should be conducted before deployment, along with continuous monitoring post-deployment to identify and mitigate any emerging risks.

[2024-23-08 10:46:49 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for `TroveManagerLiquidations`, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract allows external calls to other contracts (e.g., `sendCollaterals`, `returnFromPool`). If these external contracts are malicious, they could exploit the contract by re-entering functions before the state is updated, leading to unexpected behavior.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected results if not properly handled. Ensure that all arithmetic operations are safe and consider using SafeMath for clarity.

3. **Gas Limit and Loops**:
   - The `batchLiquidateTroves` function processes an array of troves, which could lead to excessive gas consumption if the array is large. This could cause transactions to fail due to exceeding the block gas limit.

4. **Access Control**:
   - The `setAddresses` function is marked as `onlyOwner`, but there is no check to ensure that the owner is not a malicious actor. If the ownership is compromised, the attacker could change critical addresses, leading to potential exploitation.

5. **Lack of Input Validation**:
   - Functions like `batchLiquidateTroves` do not validate the contents of the `_troveArray`. If an empty or invalid address is passed, it could lead to unexpected behavior or errors.

6. **Potential for Denial of Service (DoS)**:
   - If a trove is non-active or if the stability pool is empty, the liquidation process could be halted, leading to a denial of service for legitimate users.

7. **Event Emission**:
   - While events are emitted for significant actions, there may be a lack of comprehensive logging for all critical state changes, which could hinder tracking and debugging.

8. **Hardcoded Values**:
   - The contract contains hardcoded values (e.g., `YUSD_GAS_COMPENSATION`, `PERCENT_DIVISOR`). If these values need to change, it would require a contract upgrade, which could be a point of failure.

9. **Lack of Fallback Function**:
   - The absence of a fallback function could lead to issues if the contract receives Ether or unexpected calls.

### Comprehensive Analysis Report:

The `TroveManagerLiquidations` contract is a complex piece of code that manages the liquidation of troves in a decentralized finance (DeFi) context. While it implements several necessary functionalities, the identified vulnerabilities pose significant risks to the integrity and security of the contract.

1. **Reentrancy**: The potential for reentrancy attacks necessitates careful management of external calls. Implementing the Checks-Effects-Interactions pattern can mitigate this risk.

2. **Arithmetic Operations**: Although Solidity 0.6.x provides built-in checks, it's prudent to ensure all arithmetic operations are explicitly safe, especially in complex calculations.

3. **Gas Limit Concerns**: The design should consider the implications of processing large arrays and implement mechanisms to handle gas limits effectively, possibly by batching operations or limiting the number of processed items.

4. **Access Control**: Strengthening access control measures and ensuring that ownership is secure is critical. Consider implementing multi-signature wallets or time-lock mechanisms for sensitive operations.

5. **Input Validation**: Robust input validation is essential to prevent unexpected behavior. Functions should validate inputs thoroughly before processing.

6. **Denial of Service Risks**: The contract should be designed to handle edge cases gracefully to avoid potential denial of service scenarios.

7. **Event Logging**: Comprehensive event logging will enhance transparency and facilitate easier debugging and tracking of contract interactions.

8. **Parameter Management**: Consider using a governance mechanism to manage critical parameters instead of hardcoding them, allowing for flexibility and adaptability.

9. **Fallback Function**: Implementing a fallback function can help manage unexpected Ether transfers and calls, ensuring the contract behaves as intended.

In conclusion, while the `TroveManagerLiquidations` contract serves a crucial role in the liquidation process, addressing the identified vulnerabilities is essential to ensure its security and reliability in a production environment. A thorough audit and testing phase should be conducted before deployment, along with continuous monitoring post-deployment to identify and mitigate any emerging risks.

[2024-23-08 10:46:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/IWAsset.sol";\nimport "./Dependencies/TroveManagerBase.sol";\n\n/ \n * TroveManagerLiquidations is derived from TroveManager and has all the functions \n * related to Liquidations. \n */\n\ncontract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {\n    bytes32 constant public NAME = "TroveManagerRedemptions";\n\n\n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n\n    address internal troveManagerAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    address yetiFinanceTreasury;\n\n    struct LiquidationValues {\n        uint256 entireTroveDebt;\n        newColls entireTroveColl;\n        newColls collGasCompensation;\n        uint256 YUSDGasCompensation;\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    struct LiquidationTotals {\n        uint256 totalVCInSequence;\n        uint256 totalDebtInSequence;\n        newColls totalCollGasCompensation;\n        uint256 totalYUSDGasCompensation;\n        uint256 totalDebtToOffset;\n        newColls totalCollToSendToSP;\n        uint256 totalDebtToRedistribute;\n        newColls totalCollToRedistribute;\n        newColls totalCollSurplus;\n    }\n\n    struct LocalVariables_LiquidationSequence {\n        uint256 remainingYUSDInStabPool;\n        uint256 i;\n        uint256 ICR;\n        address user;\n        bool backToNormalMode;\n        uint256 entireSystemDebt;\n        uint256 entireSystemColl;\n    }\n\n    struct LocalVariables_OuterLiquidationFunction {\n        uint256 YUSDInStabPool;\n        bool recoveryModeAtStart;\n        uint256 liquidatedDebt;\n    }\n\n    struct LocalVariables_InnerSingleLiquidateFunction {\n        newColls collToLiquidate;\n        uint256 pendingDebtReward;\n        newColls pendingCollReward;\n    }\n\n    struct LocalVariables_ORVals {\n        uint256 debtToOffset;\n        newColls collToSendToSP;\n        uint256 debtToRedistribute;\n        newColls collToRedistribute;\n        newColls collSurplus;\n    }\n\n    event TroveLiquidated(\n        address indexed _borrower,\n        uint256 _debt,\n        TroveManagerOperation _operation\n    );\n    event Liquidation(\n        uint256 liquidatedAmount,\n        uint256 totalYUSDGasCompensation,\n        address[] totalCollTokens,\n        uint256[] totalCollAmounts,\n        address[] totalCollGasCompTokens,\n        uint256[] totalCollGasCompAmounts\n    );\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerAddress,\n        address _yetiFinanceTreasury\n    ) external onlyOwner {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerAddress);\n        checkContract(_yetiFinanceTreasury);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManager = ITroveManager(_troveManagerAddress);\n        troveManagerAddress = _troveManagerAddress;\n        yetiFinanceTreasury = _yetiFinanceTreasury;\n\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YETITokenAddressChanged(_yetiTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    / \n     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can \n     * and looks at if it is eligible for liquidation based on the current ICR value. \n     /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {\n        _requireCallerisTroveManager();\n        require(_troveArray.length != 0, "TML: One trove must exist");\n\n        IActivePool activePoolCached = activePool;\n        IDefaultPool defaultPoolCached = defaultPool;\n        IStabilityPool stabilityPoolCached = stabilityPoolContract;\n\n        LocalVariables_OuterLiquidationFunction memory vars;\n        LiquidationTotals memory totals;\n\n        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();\n        vars.recoveryModeAtStart = _checkRecoveryMode();\n\n        // Perform the appropriate liquidation sequence - tally values and obtain their totals.\n        if (vars.recoveryModeAtStart) {\n            totals = _getTotalFromBatchLiquidate_RecoveryMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        } else {\n            //  if !vars.recoveryModeAtStart\n            totals = _getTotalsFromBatchLiquidate_NormalMode(\n                activePoolCached,\n                defaultPoolCached,\n                vars.YUSDInStabPool,\n                _troveArray\n            );\n        }\n\n        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");\n        // Move liquidated Collateral and YUSD to the appropriate pools\n        stabilityPoolCached.offset(\n            totals.totalDebtToOffset,\n            totals.totalCollToSendToSP.tokens,\n            totals.totalCollToSendToSP.amounts\n        );\n        troveManager.redistributeDebtAndColl(\n            activePoolCached,\n            defaultPoolCached,\n            totals.totalDebtToRedistribute,\n            totals.totalCollToRedistribute.tokens,\n            totals.totalCollToRedistribute.amounts\n        );\n        if (_CollsIsNonZero(totals.totalCollSurplus)) {\n            activePoolCached.sendCollaterals(\n                address(collSurplusPool),\n                totals.totalCollSurplus.tokens,\n                totals.totalCollSurplus.amounts\n            );\n        }\n\n        // Update system snapshots\n        troveManager.updateSystemSnapshots_excludeCollRemainder(\n            activePoolCached,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n\n        vars.liquidatedDebt = totals.totalDebtInSequence;\n\n        // merge the colls into one to emit correct event.\n        newColls memory sumCollsResult = _sumColls(\n            totals.totalCollToSendToSP,\n            totals.totalCollToRedistribute\n        );\n        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);\n\n        emit Liquidation(\n            vars.liquidatedDebt,\n            totals.totalYUSDGasCompensation,\n            sumCollsResult.tokens,\n            sumCollsResult.amounts,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n        // Send gas compensation to caller\n        _sendGasCompensation(\n            activePoolCached,\n            _liquidator,\n            totals.totalYUSDGasCompensation,\n            totals.totalCollGasCompensation.tokens,\n            totals.totalCollGasCompensation.amounts\n        );\n    }\n\n    /\n     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it\n     * handle the case where the system leaves Recovery Mode, part way through the liquidation sequence\n     /\n    function _getTotalFromBatchLiquidate_RecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        vars.backToNormalMode = false;\n        vars.entireSystemDebt = getEntireSystemDebt();\n        // get total VC\n        vars.entireSystemColl = getEntireSystemColl();\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n\n            // Skip non-active troves\n            Status userStatus = Status(troveManager.getTroveStatus(vars.user));\n            if (userStatus != Status.active) {\n                continue;\n            }\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n\n            if (!vars.backToNormalMode) {\n                // Skip this trove if ICR is greater than MCR and Stability Pool is empty\n                if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {\n                    continue;\n                }\n\n                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);\n\n                singleLiquidation = _liquidateRecoveryMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.ICR,\n                    vars.remainingYUSDInStabPool,\n                    TCR\n                );\n\n                // Update aggregate trackers\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);\n\n                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);\n                uint256 collGasCompensationTotal = _getVCColls(\n                    singleLiquidation.collGasCompensation\n                );\n                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);\n\n                vars.entireSystemColl = vars\n                    .entireSystemColl\n                    .sub(collToSendToSpVc)\n                    .sub(collGasCompensationTotal)\n                    .sub(collSurplusTotal);\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n\n                vars.backToNormalMode = !_checkPotentialRecoveryMode(\n                    vars.entireSystemColl,\n                    vars.entireSystemDebt\n                );\n            } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            } else continue; // In Normal Mode skip troves with ICR &gt;= MCR\n        }\n    }\n\n    function _getTotalsFromBatchLiquidate_NormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        uint256 _YUSDInStabPool,\n        address[] memory _troveArray\n    ) internal returns (LiquidationTotals memory totals) {\n        LocalVariables_LiquidationSequence memory vars;\n        LiquidationValues memory singleLiquidation;\n\n        vars.remainingYUSDInStabPool = _YUSDInStabPool;\n        uint256 troveArrayLen = _troveArray.length;\n        for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {\n            vars.user = _troveArray[vars.i];\n            vars.ICR = troveManager.getCurrentICR(vars.user);\n            if (vars.ICR &lt; MCR) {\n                singleLiquidation = _liquidateNormalMode(\n                    _activePool,\n                    _defaultPool,\n                    vars.user,\n                    vars.remainingYUSDInStabPool\n                );\n                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(\n                    singleLiquidation.debtToOffset\n                );\n\n                // If wrapped assets exist then update the reward to this contract temporarily\n                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));\n\n                // Add liquidation values to their respective running totals\n                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);\n            }\n        }\n    }\n\n    // Liquidate one trove, in Normal Mode.\n    function _liquidateNormalMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _YUSDInStabPool\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        troveManager.movePendingTroveRewardsToActivePool(\n            _activePool,\n            _defaultPool,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts, \n            _borrower\n        );\n        troveManager.removeStakeTLR(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n            singleLiquidation.entireTroveDebt,\n            vars.collToLiquidate,\n            _YUSDInStabPool\n        );\n\n        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n        // rewards for WAssets sent to SP and collToRedistribute will\n        // accrue to Yeti Finance Treasury until the assets are claimed\n        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n        troveManager.closeTroveLiquidation(_borrower);\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n\n        emit TroveLiquidated(\n            _borrower,\n            singleLiquidation.entireTroveDebt,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n        newColls memory borrowerColls;\n        emit TroveUpdated(\n            _borrower,\n            0,\n            borrowerColls.tokens,\n            borrowerColls.amounts,\n            TroveManagerOperation.liquidateInNormalMode\n        );\n    }\n\n\n    // Liquidate one trove, in Recovery Mode.\n    function _liquidateRecoveryMode(\n        IActivePool _activePool,\n        IDefaultPool _defaultPool,\n        address _borrower,\n        uint256 _ICR,\n        uint256 _YUSDInStabPool,\n        uint256 _TCR\n    ) internal returns (LiquidationValues memory singleLiquidation) {\n        LocalVariables_InnerSingleLiquidateFunction memory vars;\n\n        if (troveManager.getTroveOwnersCount() &lt;= 1) {\n            return singleLiquidation;\n        } // don\'t liquidate if last trove\n\n        (\n            singleLiquidation.entireTroveDebt,\n            singleLiquidation.entireTroveColl.tokens,\n            singleLiquidation.entireTroveColl.amounts,\n            vars.pendingDebtReward,\n            vars.pendingCollReward.tokens,\n            vars.pendingCollReward.amounts\n        ) = troveManager.getEntireDebtAndColls(_borrower);\n\n        singleLiquidation.collGasCompensation = _getCollGasCompensation(\n            singleLiquidation.entireTroveColl\n        );\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;\n        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;\n        vars.collToLiquidate.amounts = new uint256;\n        for (uint256 i; i &lt; collToLiquidateLen; ++i) {\n            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(\n                singleLiquidation.collGasCompensation.amounts[i]\n            );\n        }\n\n        // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves\n        if (_ICR &lt;= _100pct) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation.debtToOffset = 0;\n            newColls memory emptyColls;\n            singleLiquidation.collToSendToSP = emptyColls;\n            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;\n            singleLiquidation.collToRedistribute = vars.collToLiquidate;\n\n            // WAsset rewards for collToRedistribute will accrue to\n            // Yeti Finance Treasury until the WAssets are claimed by troves\n            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n\n            // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder\n            // ICR &gt; 100% is implied by prevoius state. \n        } else if (_ICR &lt; MCR) {\n\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts, \n                _borrower\n            );\n\n            troveManager.removeStakeTLR(_borrower);\n\n            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(\n                singleLiquidation.entireTroveDebt,\n                vars.collToLiquidate,\n                _YUSDInStabPool\n            );\n\n            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);\n\n            troveManager.closeTroveLiquidation(_borrower);\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            /\n             * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)\n             * and there is YUSD in the Stability Pool, only offset, with no redistribution,\n             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.\n             * The remainder due to the capped rate will be claimable as collateral surplus.\n             * ICR &gt;= 110% is implied from last else if statement. \n             /\n        } else if (\n           (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)\n        ) {\n            troveManager.movePendingTroveRewardsToActivePool(\n                _activePool,\n                _defaultPool,\n                vars.pendingDebtReward,\n                vars.pendingCollReward.tokens,\n                vars.pendingCollReward.amounts,\n                _borrower\n            );\n\n            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");\n\n            troveManager.removeStakeTLR(_borrower);\n\n            singleLiquidation = _getCappedOffsetVals(\n                singleLiquidation.entireTroveDebt,\n                singleLiquidation.entireTroveColl.tokens,\n                singleLiquidation.entireTroveColl.amounts,\n                MCR\n            );\n\n            newColls memory collsToUpdate = _sumColls(\n                singleLiquidation.collToSendToSP,\n                singleLiquidation.collToRedistribute\n            );\n            // rewards for WAssets sent to SP and collToRedistribute will\n            // accrue to Yeti Finance Treasury until the assets are claimed\n            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);\n\n            troveManager.closeTroveLiquidation(_borrower);\n\n            emit TroveLiquidated(\n                _borrower,\n                singleLiquidation.entireTroveDebt,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n            newColls memory borrowerColls;\n            emit TroveUpdated(\n                _borrower,\n                0,\n                borrowerColls.tokens,\n                borrowerColls.amounts,\n                TroveManagerOperation.liquidateInRecoveryMode\n            );\n        } else {\n            // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))\n            LiquidationValues memory zeroVals;\n            return zeroVals;\n        }\n\n        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {\n            troveManager.collSurplusUpdate(\n                _borrower,\n                singleLiquidation.collSurplus.tokens,\n                singleLiquidation.collSurplus.amounts\n            );\n        }\n    }\n\n    function _updateSingleLiquidation(\n        LocalVariables_ORVals memory or_vals,\n        LiquidationValues memory singleLiquidation\n    ) internal pure returns (LiquidationValues memory) {\n        singleLiquidation.debtToOffset = or_vals.debtToOffset;\n        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;\n        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;\n        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;\n        singleLiquidation.collSurplus = or_vals.collSurplus;\n        return singleLiquidation;\n    }\n\n    / In a full liquidation, returns the values for a trove\'s coll and debt to be offset, and coll and debt to be\n     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)\n     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length\n     * and should be the same length as _colls.tokens and _colls.amounts.\n     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts\n     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),\n     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.\n     /\n    function _getOffsetAndRedistributionVals(\n        uint256 _entireTroveDebt,\n        newColls memory _collsToLiquidate,\n        uint256 _YUSDInStabPool\n    ) internal view returns (LocalVariables_ORVals memory or_vals) {\n        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;\n        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;\n        or_vals.collToRedistribute.amounts = new uint256;\n\n        if (_YUSDInStabPool != 0) {\n            /\n             * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder\n             * between all active troves.\n             \n             *  If the trove\'s debt is larger than the deposited YUSD in the Stability Pool:\n             \n             *  - Offset an amount of the trove\'s debt equal to the YUSD in the Stability Pool\n             *  - Remainder of trove\'s debt will be redistributed\n             *  - Trove collateral can be partitioned into two parts:\n             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral\n             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral\n             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that\n             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is\n             *  - sent to the collSurplusPool and can be claimed by the borrower.\n             /\n            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;\n            or_vals.collToSendToSP.amounts = new uint256;\n\n            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;\n            or_vals.collSurplus.amounts = new uint256;\n\n            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);\n\n            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);\n\n            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);\n\n            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral\n            // collOffsetRatio = percentage of the trove\'s debt that can be offset by the stability pool\n            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);\n\n            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors\n            // $110 of collateral for every 100 YUSD they are using to liquidate.\n            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);\n\n            // But SP ratio is capped at collOffsetRatio:\n            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);\n\n            // if there is extra collateral left in the offset portion of the collateral after\n            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,\n            // then this is surplus collateral that can be claimed by the borrower\n            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);\n\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(\n                    _100pct\n                ).div(_100pct);\n\n                or_vals.collSurplus.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .mul(collSurplusRatio)\n                    .div(_100pct)\n                    .div(_100pct);\n\n                // remaining collateral is redistributed:\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate\n                    .amounts[i]\n                    .sub(or_vals.collToSendToSP.amounts[i])\n                    .sub(or_vals.collSurplus.amounts[i]);\n            }\n        } else {\n            // all colls are redistributed because no YUSD in stability pool to liquidate\n            or_vals.debtToOffset = 0;\n            for (uint256 i; i &lt; collsToLiquidateLen; ++i) {\n                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];\n            }\n            or_vals.debtToRedistribute = _entireTroveDebt;\n        }\n    }\n\n    function _addLiquidationValuesToTotals(\n        LiquidationTotals memory oldTotals,\n        LiquidationValues memory singleLiquidation\n    ) internal view returns (LiquidationTotals memory newTotals) {\n        // Tally all the values with their respective running totals\n        //update one of these\n        newTotals.totalCollGasCompensation = _sumColls(\n            oldTotals.totalCollGasCompensation,\n            singleLiquidation.collGasCompensation\n        );\n        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(\n            singleLiquidation.YUSDGasCompensation\n        );\n        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(\n            singleLiquidation.entireTroveDebt\n        );\n        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(\n            singleLiquidation.debtToOffset\n        );\n        newTotals.totalCollToSendToSP = _sumColls(\n            oldTotals.totalCollToSendToSP,\n            singleLiquidation.collToSendToSP\n        );\n        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(\n            singleLiquidation.debtToRedistribute\n        );\n        newTotals.totalCollToRedistribute = _sumColls(\n            oldTotals.totalCollToRedistribute,\n            singleLiquidation.collToRedistribute\n        );\n        newTotals.totalCollSurplus = _sumColls(\n            oldTotals.totalCollSurplus,\n            singleLiquidation.collSurplus\n        );\n    }\n\n    /\n    *  Get its offset coll/debt and Collateral gas comp, and close the trove.\n    /\n    function _getCappedOffsetVals\n    (\n        uint _entireTroveDebt,\n        address[] memory _troveTokens,\n        uint[] memory _troveAmounts,\n        uint _MCR\n    )\n    internal\n    view\n    returns (LiquidationValues memory singleLiquidation)\n    {\n        newColls memory _entireTroveColl;\n        _entireTroveColl.tokens = _troveTokens;\n        _entireTroveColl.amounts = _troveAmounts;\n\n        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);\n        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);\n\n        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);\n        SPRatio = LiquityMath._min(SPRatio, _100pct);\n\n        singleLiquidation.entireTroveDebt = _entireTroveDebt;\n        singleLiquidation.entireTroveColl = _entireTroveColl;\n\n        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;\n\n        singleLiquidation.debtToOffset = _entireTroveDebt;\n        singleLiquidation.debtToRedistribute = 0;\n\n        singleLiquidation.collToSendToSP.tokens = _troveTokens;\n        uint256 troveTokensLen = _troveTokens.length;\n        \n        singleLiquidation.collToSendToSP.amounts = new uint;\n\n        singleLiquidation.collSurplus.tokens = _troveTokens;\n        singleLiquidation.collSurplus.amounts = new uint;\n\n        singleLiquidation.collGasCompensation.tokens = _troveTokens;\n        singleLiquidation.collGasCompensation.amounts = new uint;\n\n        for (uint256 i; i &lt; troveTokensLen; ++i) {\n            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);\n            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);\n            uint _toSP = _cappedCollAmount.sub(_gasComp);\n            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);\n\n            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;\n            singleLiquidation.collToSendToSP.amounts[i] = _toSP;\n            singleLiquidation.collSurplus.amounts[i] = _collSurplus;\n        }\n    }\n\n    function _sendGasCompensation(\n        IActivePool _activePool,\n        address _liquidator,\n        uint256 _YUSD,\n        address[] memory _tokens,\n        uint256[] memory _amounts\n    ) internal {\n        if (_YUSD != 0) {\n            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);\n        }\n\n        // This contract owns the rewards temporarily until the liquidation is complete\n        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);\n    }\n\n    /\n     * Update rewards tracking so future rewards go to Yeti Finance Treasury\n     * for the trove\'s asset that have been liquidated and moved to either the\n     * Stability Pool or Default Pool\n    */\n    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {\n        uint256 collsLen = _colls.tokens.length;\n        for (uint256 i; i &lt; collsLen; ++i) {\n            address token = _colls.tokens[i];\n            if (whitelist.isWrapped(token)) {\n                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);\n            }\n        }\n    }\n\n    function _requireCallerisTroveManager() internal view {\n        require(msg.sender == troveManagerAddress, "Caller not TM");\n    }\n\n\n    // Return the amount of collateral to be drawn from a trove\'s collateral and sent as gas compensation.\n    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {\n        require(_coll.tokens.length == _coll.amounts.length, "Not same length");\n\n        uint[] memory amounts = new uint;\n        for (uint256 i; i &lt; _coll.tokens.length; ++i) {\n            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;\n        }\n        return newColls(_coll.tokens, amounts);\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-23-08 10:46:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/IWAsset.sol"; import "./Dependencies/TroveManagerBase.sol"; /*   * TroveManagerLiquidations is derived from TroveManager and has all the functions   * related to Liquidations.   / contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {     bytes32 constant public NAME = "TroveManagerRedemptions"; address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress;  address internal troveManagerAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  address yetiFinanceTreasury;  struct LiquidationValues {     uint256 entireTroveDebt;     newColls entireTroveColl;     newColls collGasCompensation;     uint256 YUSDGasCompensation;     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  struct LiquidationTotals {     uint256 totalVCInSequence;     uint256 totalDebtInSequence;     newColls totalCollGasCompensation;     uint256 totalYUSDGasCompensation;     uint256 totalDebtToOffset;     newColls totalCollToSendToSP;     uint256 totalDebtToRedistribute;     newColls totalCollToRedistribute;     newColls totalCollSurplus; }  struct LocalVariables_LiquidationSequence {     uint256 remainingYUSDInStabPool;     uint256 i;     uint256 ICR;     address user;     bool backToNormalMode;     uint256 entireSystemDebt;     uint256 entireSystemColl; }  struct LocalVariables_OuterLiquidationFunction {     uint256 YUSDInStabPool;     bool recoveryModeAtStart;     uint256 liquidatedDebt; }  struct LocalVariables_InnerSingleLiquidateFunction {     newColls collToLiquidate;     uint256 pendingDebtReward;     newColls pendingCollReward; }  struct LocalVariables_ORVals {     uint256 debtToOffset;     newColls collToSendToSP;     uint256 debtToRedistribute;     newColls collToRedistribute;     newColls collSurplus; }  event TroveLiquidated(     address indexed _borrower,     uint256 _debt,     TroveManagerOperation _operation ); event Liquidation(     uint256 liquidatedAmount,     uint256 totalYUSDGasCompensation,     address[] totalCollTokens,     uint256[] totalCollAmounts,     address[] totalCollGasCompTokens,     uint256[] totalCollGasCompAmounts );  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerAddress,     address _yetiFinanceTreasury ) external onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerAddress);     checkContract(_yetiFinanceTreasury);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);     troveManager = ITroveManager(_troveManagerAddress);     troveManagerAddress = _troveManagerAddress;     yetiFinanceTreasury = _yetiFinanceTreasury;      emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);     emit ActivePoolAddressChanged(_activePoolAddress);     emit DefaultPoolAddressChanged(_defaultPoolAddress);     emit StabilityPoolAddressChanged(_stabilityPoolAddress);     emit GasPoolAddressChanged(_gasPoolAddress);     emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);     emit YUSDTokenAddressChanged(_yusdTokenAddress);     emit SortedTrovesAddressChanged(_sortedTrovesAddress);     emit YETITokenAddressChanged(_yetiTokenAddress);     emit SYETIAddressChanged(_sYETIAddress);      _renounceOwnership(); }  /**   * Function for liquidating a list of troves in a single transaction. Will perform as many as it can   * and looks at if it is eligible for liquidation based on the current ICR value.   */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {     _requireCallerisTroveManager();     require(_troveArray.length != 0, "TML: One trove must exist");      IActivePool activePoolCached = activePool;     IDefaultPool defaultPoolCached = defaultPool;     IStabilityPool stabilityPoolCached = stabilityPoolContract;      LocalVariables_OuterLiquidationFunction memory vars;     LiquidationTotals memory totals;      vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();     vars.recoveryModeAtStart = _checkRecoveryMode();      // Perform the appropriate liquidation sequence - tally values and obtain their totals.     if (vars.recoveryModeAtStart) {         totals = _getTotalFromBatchLiquidate_RecoveryMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     } else {         //  if !vars.recoveryModeAtStart         totals = _getTotalsFromBatchLiquidate_NormalMode(             activePoolCached,             defaultPoolCached,             vars.YUSDInStabPool,             _troveArray         );     }      require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");     // Move liquidated Collateral and YUSD to the appropriate pools     stabilityPoolCached.offset(         totals.totalDebtToOffset,         totals.totalCollToSendToSP.tokens,         totals.totalCollToSendToSP.amounts     );     troveManager.redistributeDebtAndColl(         activePoolCached,         defaultPoolCached,         totals.totalDebtToRedistribute,         totals.totalCollToRedistribute.tokens,         totals.totalCollToRedistribute.amounts     );     if (_CollsIsNonZero(totals.totalCollSurplus)) {         activePoolCached.sendCollaterals(             address(collSurplusPool),             totals.totalCollSurplus.tokens,             totals.totalCollSurplus.amounts         );     }      // Update system snapshots     troveManager.updateSystemSnapshots_excludeCollRemainder(         activePoolCached,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );      vars.liquidatedDebt = totals.totalDebtInSequence;      // merge the colls into one to emit correct event.     newColls memory sumCollsResult = _sumColls(         totals.totalCollToSendToSP,         totals.totalCollToRedistribute     );     sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);      emit Liquidation(         vars.liquidatedDebt,         totals.totalYUSDGasCompensation,         sumCollsResult.tokens,         sumCollsResult.amounts,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     );     // Send gas compensation to caller     _sendGasCompensation(         activePoolCached,         _liquidator,         totals.totalYUSDGasCompensation,         totals.totalCollGasCompensation.tokens,         totals.totalCollGasCompensation.amounts     ); }  /*  * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it  * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence  */ function _getTotalFromBatchLiquidate_RecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     vars.backToNormalMode = false;     vars.entireSystemDebt = getEntireSystemDebt();     // get total VC     vars.entireSystemColl = getEntireSystemColl();     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];          // Skip non-active troves         Status userStatus = Status(troveManager.getTroveStatus(vars.user));         if (userStatus != Status.active) {             continue;         }         vars.ICR = troveManager.getCurrentICR(vars.user);          if (!vars.backToNormalMode) {             // Skip this trove if ICR is greater than MCR and Stability Pool is empty             if (vars.ICR &gt;= MCR &amp;&amp; vars.remainingYUSDInStabPool == 0) {                 continue;             }              uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);              singleLiquidation = _liquidateRecoveryMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.ICR,                 vars.remainingYUSDInStabPool,                 TCR             );              // Update aggregate trackers             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);              uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);             uint256 collGasCompensationTotal = _getVCColls(                 singleLiquidation.collGasCompensation             );             uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);              vars.entireSystemColl = vars                 .entireSystemColl                 .sub(collToSendToSpVc)                 .sub(collGasCompensationTotal)                 .sub(collSurplusTotal);              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);              vars.backToNormalMode = !_checkPotentialRecoveryMode(                 vars.entireSystemColl,                 vars.entireSystemDebt             );         } else if (vars.backToNormalMode &amp;&amp; vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         } else continue; // In Normal Mode skip troves with ICR &gt;= MCR     } }  function _getTotalsFromBatchLiquidate_NormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     uint256 _YUSDInStabPool,     address[] memory _troveArray ) internal returns (LiquidationTotals memory totals) {     LocalVariables_LiquidationSequence memory vars;     LiquidationValues memory singleLiquidation;      vars.remainingYUSDInStabPool = _YUSDInStabPool;     uint256 troveArrayLen = _troveArray.length;     for (vars.i = 0; vars.i &lt; troveArrayLen; ++vars.i) {         vars.user = _troveArray[vars.i];         vars.ICR = troveManager.getCurrentICR(vars.user);         if (vars.ICR &lt; MCR) {             singleLiquidation = _liquidateNormalMode(                 _activePool,                 _defaultPool,                 vars.user,                 vars.remainingYUSDInStabPool             );             vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(                 singleLiquidation.debtToOffset             );              // If wrapped assets exist then update the reward to this contract temporarily             _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));              // Add liquidation values to their respective running totals             totals = _addLiquidationValuesToTotals(totals, singleLiquidation);         }     } }  // Liquidate one trove, in Normal Mode. function _liquidateNormalMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _YUSDInStabPool ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      troveManager.movePendingTroveRewardsToActivePool(         _activePool,         _defaultPool,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts,          _borrower     );     troveManager.removeStakeTLR(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(         singleLiquidation.entireTroveDebt,         vars.collToLiquidate,         _YUSDInStabPool     );      newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);     // rewards for WAssets sent to SP and collToRedistribute will     // accrue to Yeti Finance Treasury until the assets are claimed     _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);      singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);     troveManager.closeTroveLiquidation(_borrower);      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     }      emit TroveLiquidated(         _borrower,         singleLiquidation.entireTroveDebt,         TroveManagerOperation.liquidateInNormalMode     );     newColls memory borrowerColls;     emit TroveUpdated(         _borrower,         0,         borrowerColls.tokens,         borrowerColls.amounts,         TroveManagerOperation.liquidateInNormalMode     ); }   // Liquidate one trove, in Recovery Mode. function _liquidateRecoveryMode(     IActivePool _activePool,     IDefaultPool _defaultPool,     address _borrower,     uint256 _ICR,     uint256 _YUSDInStabPool,     uint256 _TCR ) internal returns (LiquidationValues memory singleLiquidation) {     LocalVariables_InnerSingleLiquidateFunction memory vars;      if (troveManager.getTroveOwnersCount() &lt;= 1) {         return singleLiquidation;     } // don't liquidate if last trove      (         singleLiquidation.entireTroveDebt,         singleLiquidation.entireTroveColl.tokens,         singleLiquidation.entireTroveColl.amounts,         vars.pendingDebtReward,         vars.pendingCollReward.tokens,         vars.pendingCollReward.amounts     ) = troveManager.getEntireDebtAndColls(_borrower);      singleLiquidation.collGasCompensation = _getCollGasCompensation(         singleLiquidation.entireTroveColl     );      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;     uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;     vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);     for (uint256 i; i &lt; collToLiquidateLen; ++i) {         vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(             singleLiquidation.collGasCompensation.amounts[i]         );     }      // If ICR &lt;= 100%, purely redistribute the Trove across all active Troves     if (_ICR &lt;= _100pct) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );         // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);         troveManager.removeStakeTLR(_borrower);          singleLiquidation.debtToOffset = 0;         newColls memory emptyColls;         singleLiquidation.collToSendToSP = emptyColls;         singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;         singleLiquidation.collToRedistribute = vars.collToLiquidate;          // WAsset rewards for collToRedistribute will accrue to         // Yeti Finance Treasury until the WAssets are claimed by troves         _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );          // If 100% &lt; ICR &lt; MCR, offset as much as possible, and redistribute the remainder         // ICR &gt; 100% is implied by prevoius state.      } else if (_ICR &lt; MCR) {          troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,              _borrower         );          troveManager.removeStakeTLR(_borrower);          LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(             singleLiquidation.entireTroveDebt,             vars.collToLiquidate,             _YUSDInStabPool         );          newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);          troveManager.closeTroveLiquidation(_borrower);         emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );         /*          * If 110% &lt;= ICR &lt; current TCR (accounting for the preceding liquidations in the current sequence)          * and there is YUSD in the Stability Pool, only offset, with no redistribution,          * but at a capped rate of 1.1 and only if the whole debt can be liquidated.          * The remainder due to the capped rate will be claimable as collateral surplus.          * ICR &gt;= 110% is implied from last else if statement.           */     } else if (        (_ICR &lt; _TCR) &amp;&amp; (singleLiquidation.entireTroveDebt &lt;= _YUSDInStabPool)     ) {         troveManager.movePendingTroveRewardsToActivePool(             _activePool,             _defaultPool,             vars.pendingDebtReward,             vars.pendingCollReward.tokens,             vars.pendingCollReward.amounts,             _borrower         );          require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");          troveManager.removeStakeTLR(_borrower);          singleLiquidation = _getCappedOffsetVals(             singleLiquidation.entireTroveDebt,             singleLiquidation.entireTroveColl.tokens,             singleLiquidation.entireTroveColl.amounts,             MCR         );          newColls memory collsToUpdate = _sumColls(             singleLiquidation.collToSendToSP,             singleLiquidation.collToRedistribute         );         // rewards for WAssets sent to SP and collToRedistribute will         // accrue to Yeti Finance Treasury until the assets are claimed         _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);          troveManager.closeTroveLiquidation(_borrower);          emit TroveLiquidated(             _borrower,             singleLiquidation.entireTroveDebt,             TroveManagerOperation.liquidateInRecoveryMode         );         newColls memory borrowerColls;         emit TroveUpdated(             _borrower,             0,             borrowerColls.tokens,             borrowerColls.amounts,             TroveManagerOperation.liquidateInRecoveryMode         );     } else {         // if (_ICR &gt;= MCR &amp;&amp; ( _ICR &gt;= _TCR || singleLiquidation.entireTroveDebt &gt; _YUSDInStabPool))         LiquidationValues memory zeroVals;         return zeroVals;     }      if (_CollsIsNonZero(singleLiquidation.collSurplus)) {         troveManager.collSurplusUpdate(             _borrower,             singleLiquidation.collSurplus.tokens,             singleLiquidation.collSurplus.amounts         );     } }  function _updateSingleLiquidation(     LocalVariables_ORVals memory or_vals,     LiquidationValues memory singleLiquidation ) internal pure returns (LiquidationValues memory) {     singleLiquidation.debtToOffset = or_vals.debtToOffset;     singleLiquidation.collToSendToSP = or_vals.collToSendToSP;     singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;     singleLiquidation.collToRedistribute = or_vals.collToRedistribute;     singleLiquidation.collSurplus = or_vals.collSurplus;     return singleLiquidation; }  /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be  * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)  * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length  * and should be the same length as _colls.tokens and _colls.amounts.  * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts  * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),  * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.  */ function _getOffsetAndRedistributionVals(     uint256 _entireTroveDebt,     newColls memory _collsToLiquidate,     uint256 _YUSDInStabPool ) internal view returns (LocalVariables_ORVals memory or_vals) {     or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;     uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;     or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);      if (_YUSDInStabPool != 0) {         /*          * Offset as much debt &amp; collateral as possible against the Stability Pool, and redistribute the remainder          * between all active troves.          *          *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:          *          *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool          *  - Remainder of trove's debt will be redistributed          *  - Trove collateral can be partitioned into two parts:          *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral          *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral          *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that          *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is          *  - sent to the collSurplusPool and can be claimed by the borrower.          */         or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;         or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);          or_vals.collSurplus.tokens = _collsToLiquidate.tokens;         or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);          or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);          or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);          uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);          // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral         // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool         uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);          // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors         // $110 of collateral for every 100 YUSD they are using to liquidate.         uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);          // But SP ratio is capped at collOffsetRatio:         SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);          // if there is extra collateral left in the offset portion of the collateral after         // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,         // then this is surplus collateral that can be claimed by the borrower         uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);          for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(                 _100pct             ).div(_100pct);              or_vals.collSurplus.amounts[i] = _collsToLiquidate                 .amounts[i]                 .mul(collSurplusRatio)                 .div(_100pct)                 .div(_100pct);              // remaining collateral is redistributed:             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate                 .amounts[i]                 .sub(or_vals.collToSendToSP.amounts[i])                 .sub(or_vals.collSurplus.amounts[i]);         }     } else {         // all colls are redistributed because no YUSD in stability pool to liquidate         or_vals.debtToOffset = 0;         for (uint256 i; i &lt; collsToLiquidateLen; ++i) {             or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];         }         or_vals.debtToRedistribute = _entireTroveDebt;     } }  function _addLiquidationValuesToTotals(     LiquidationTotals memory oldTotals,     LiquidationValues memory singleLiquidation ) internal view returns (LiquidationTotals memory newTotals) {     // Tally all the values with their respective running totals     //update one of these     newTotals.totalCollGasCompensation = _sumColls(         oldTotals.totalCollGasCompensation,         singleLiquidation.collGasCompensation     );     newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(         singleLiquidation.YUSDGasCompensation     );     newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(         singleLiquidation.entireTroveDebt     );     newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(         singleLiquidation.debtToOffset     );     newTotals.totalCollToSendToSP = _sumColls(         oldTotals.totalCollToSendToSP,         singleLiquidation.collToSendToSP     );     newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(         singleLiquidation.debtToRedistribute     );     newTotals.totalCollToRedistribute = _sumColls(         oldTotals.totalCollToRedistribute,         singleLiquidation.collToRedistribute     );     newTotals.totalCollSurplus = _sumColls(         oldTotals.totalCollSurplus,         singleLiquidation.collSurplus     ); }  /* *  Get its offset coll/debt and Collateral gas comp, and close the trove. */ function _getCappedOffsetVals (     uint _entireTroveDebt,     address[] memory _troveTokens,     uint[] memory _troveAmounts,     uint _MCR ) internal view returns (LiquidationValues memory singleLiquidation) {     newColls memory _entireTroveColl;     _entireTroveColl.tokens = _troveTokens;     _entireTroveColl.amounts = _troveAmounts;      uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);     uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);      uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);     SPRatio = LiquityMath._min(SPRatio, _100pct);      singleLiquidation.entireTroveDebt = _entireTroveDebt;     singleLiquidation.entireTroveColl = _entireTroveColl;      singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;      singleLiquidation.debtToOffset = _entireTroveDebt;     singleLiquidation.debtToRedistribute = 0;      singleLiquidation.collToSendToSP.tokens = _troveTokens;     uint256 troveTokensLen = _troveTokens.length;      singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);      singleLiquidation.collSurplus.tokens = _troveTokens;     singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);      singleLiquidation.collGasCompensation.tokens = _troveTokens;     singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);      for (uint256 i; i &lt; troveTokensLen; ++i) {         uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);         uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);         uint _toSP = _cappedCollAmount.sub(_gasComp);         uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);          singleLiquidation.collGasCompensation.amounts[i] = _gasComp;         singleLiquidation.collToSendToSP.amounts[i] = _toSP;         singleLiquidation.collSurplus.amounts[i] = _collSurplus;     } }  function _sendGasCompensation(     IActivePool _activePool,     address _liquidator,     uint256 _YUSD,     address[] memory _tokens,     uint256[] memory _amounts ) internal {     if (_YUSD != 0) {         yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);     }      // This contract owns the rewards temporarily until the liquidation is complete     _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts); }  /*  * Update rewards tracking so future rewards go to Yeti Finance Treasury  * for the trove's asset that have been liquidated and moved to either the  * Stability Pool or Default Pool */ function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     uint256 collsLen = _colls.tokens.length;     for (uint256 i; i &lt; collsLen; ++i) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } }  function _requireCallerisTroveManager() internal view {     require(msg.sender == troveManagerAddress, "Caller not TM"); }   // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation. function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {     require(_coll.tokens.length == _coll.amounts.length, "Not same length");      uint[] memory amounts = new uint[](_coll.tokens.length);     for (uint256 i; i &lt; _coll.tokens.length; ++i) {         amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;     }     return newColls(_coll.tokens, amounts); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 10:46:52 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/IWAsset.sol";
import "./Dependencies/TroveManagerBase.sol";

/** 
 * TroveManagerLiquidations is derived from TroveManager and has all the functions 
 * related to Liquidations. 
 */

contract TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations {
    bytes32 constant public NAME = "TroveManagerRedemptions";


    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;

    address internal troveManagerAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    address yetiFinanceTreasury;

    struct LiquidationValues {
        uint256 entireTroveDebt;
        newColls entireTroveColl;
        newColls collGasCompensation;
        uint256 YUSDGasCompensation;
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    struct LiquidationTotals {
        uint256 totalVCInSequence;
        uint256 totalDebtInSequence;
        newColls totalCollGasCompensation;
        uint256 totalYUSDGasCompensation;
        uint256 totalDebtToOffset;
        newColls totalCollToSendToSP;
        uint256 totalDebtToRedistribute;
        newColls totalCollToRedistribute;
        newColls totalCollSurplus;
    }

    struct LocalVariables_LiquidationSequence {
        uint256 remainingYUSDInStabPool;
        uint256 i;
        uint256 ICR;
        address user;
        bool backToNormalMode;
        uint256 entireSystemDebt;
        uint256 entireSystemColl;
    }

    struct LocalVariables_OuterLiquidationFunction {
        uint256 YUSDInStabPool;
        bool recoveryModeAtStart;
        uint256 liquidatedDebt;
    }

    struct LocalVariables_InnerSingleLiquidateFunction {
        newColls collToLiquidate;
        uint256 pendingDebtReward;
        newColls pendingCollReward;
    }

    struct LocalVariables_ORVals {
        uint256 debtToOffset;
        newColls collToSendToSP;
        uint256 debtToRedistribute;
        newColls collToRedistribute;
        newColls collSurplus;
    }

    event TroveLiquidated(
        address indexed _borrower,
        uint256 _debt,
        TroveManagerOperation _operation
    );
    event Liquidation(
        uint256 liquidatedAmount,
        uint256 totalYUSDGasCompensation,
        address[] totalCollTokens,
        uint256[] totalCollAmounts,
        address[] totalCollGasCompTokens,
        uint256[] totalCollGasCompAmounts
    );

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerAddress,
        address _yetiFinanceTreasury
    ) external onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerAddress);
        checkContract(_yetiFinanceTreasury);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        troveManagerAddress = _troveManagerAddress;
        yetiFinanceTreasury = _yetiFinanceTreasury;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YETITokenAddressChanged(_yetiTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    /** 
     * Function for liquidating a list of troves in a single transaction. Will perform as many as it can 
     * and looks at if it is eligible for liquidation based on the current ICR value. 
     */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override {
        _requireCallerisTroveManager();
        require(_troveArray.length != 0, "TML: One trove must exist");

        IActivePool activePoolCached = activePool;
        IDefaultPool defaultPoolCached = defaultPool;
        IStabilityPool stabilityPoolCached = stabilityPoolContract;

        LocalVariables_OuterLiquidationFunction memory vars;
        LiquidationTotals memory totals;

        vars.YUSDInStabPool = stabilityPoolCached.getTotalYUSDDeposits();
        vars.recoveryModeAtStart = _checkRecoveryMode();

        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
        if (vars.recoveryModeAtStart) {
            totals = _getTotalFromBatchLiquidate_RecoveryMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        } else {
            //  if !vars.recoveryModeAtStart
            totals = _getTotalsFromBatchLiquidate_NormalMode(
                activePoolCached,
                defaultPoolCached,
                vars.YUSDInStabPool,
                _troveArray
            );
        }

        require(totals.totalDebtInSequence != 0, "TML: nothing to liquidate");
        // Move liquidated Collateral and YUSD to the appropriate pools
        stabilityPoolCached.offset(
            totals.totalDebtToOffset,
            totals.totalCollToSendToSP.tokens,
            totals.totalCollToSendToSP.amounts
        );
        troveManager.redistributeDebtAndColl(
            activePoolCached,
            defaultPoolCached,
            totals.totalDebtToRedistribute,
            totals.totalCollToRedistribute.tokens,
            totals.totalCollToRedistribute.amounts
        );
        if (_CollsIsNonZero(totals.totalCollSurplus)) {
            activePoolCached.sendCollaterals(
                address(collSurplusPool),
                totals.totalCollSurplus.tokens,
                totals.totalCollSurplus.amounts
            );
        }

        // Update system snapshots
        troveManager.updateSystemSnapshots_excludeCollRemainder(
            activePoolCached,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );

        vars.liquidatedDebt = totals.totalDebtInSequence;

        // merge the colls into one to emit correct event.
        newColls memory sumCollsResult = _sumColls(
            totals.totalCollToSendToSP,
            totals.totalCollToRedistribute
        );
        sumCollsResult = _sumColls(sumCollsResult, totals.totalCollSurplus);

        emit Liquidation(
            vars.liquidatedDebt,
            totals.totalYUSDGasCompensation,
            sumCollsResult.tokens,
            sumCollsResult.amounts,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
        // Send gas compensation to caller
        _sendGasCompensation(
            activePoolCached,
            _liquidator,
            totals.totalYUSDGasCompensation,
            totals.totalCollGasCompensation.tokens,
            totals.totalCollGasCompensation.amounts
        );
    }

    /*
     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
     */
    function _getTotalFromBatchLiquidate_RecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        vars.backToNormalMode = false;
        vars.entireSystemDebt = getEntireSystemDebt();
        // get total VC
        vars.entireSystemColl = getEntireSystemColl();
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];

            // Skip non-active troves
            Status userStatus = Status(troveManager.getTroveStatus(vars.user));
            if (userStatus != Status.active) {
                continue;
            }
            vars.ICR = troveManager.getCurrentICR(vars.user);

            if (!vars.backToNormalMode) {
                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
                if (vars.ICR >= MCR && vars.remainingYUSDInStabPool == 0) {
                    continue;
                }

                uint256 TCR = LiquityMath._computeCR(vars.entireSystemColl, vars.entireSystemDebt);

                singleLiquidation = _liquidateRecoveryMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.ICR,
                    vars.remainingYUSDInStabPool,
                    TCR
                );

                // Update aggregate trackers
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                vars.entireSystemDebt = vars.entireSystemDebt.sub(singleLiquidation.debtToOffset);

                uint256 collToSendToSpVc = _getVCColls(singleLiquidation.collToSendToSP);
                uint256 collGasCompensationTotal = _getVCColls(
                    singleLiquidation.collGasCompensation
                );
                uint256 collSurplusTotal = _getVCColls(singleLiquidation.collSurplus);

                vars.entireSystemColl = vars
                    .entireSystemColl
                    .sub(collToSendToSpVc)
                    .sub(collGasCompensationTotal)
                    .sub(collSurplusTotal);

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);

                vars.backToNormalMode = !_checkPotentialRecoveryMode(
                    vars.entireSystemColl,
                    vars.entireSystemDebt
                );
            } else if (vars.backToNormalMode && vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            } else continue; // In Normal Mode skip troves with ICR >= MCR
        }
    }

    function _getTotalsFromBatchLiquidate_NormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        uint256 _YUSDInStabPool,
        address[] memory _troveArray
    ) internal returns (LiquidationTotals memory totals) {
        LocalVariables_LiquidationSequence memory vars;
        LiquidationValues memory singleLiquidation;

        vars.remainingYUSDInStabPool = _YUSDInStabPool;
        uint256 troveArrayLen = _troveArray.length;
        for (vars.i = 0; vars.i < troveArrayLen; ++vars.i) {
            vars.user = _troveArray[vars.i];
            vars.ICR = troveManager.getCurrentICR(vars.user);
            if (vars.ICR < MCR) {
                singleLiquidation = _liquidateNormalMode(
                    _activePool,
                    _defaultPool,
                    vars.user,
                    vars.remainingYUSDInStabPool
                );
                vars.remainingYUSDInStabPool = vars.remainingYUSDInStabPool.sub(
                    singleLiquidation.debtToOffset
                );

                // If wrapped assets exist then update the reward to this contract temporarily
                _updateWAssetsRewardOwner(singleLiquidation.collGasCompensation, vars.user, address(this));

                // Add liquidation values to their respective running totals
                totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
            }
        }
    }

    // Liquidate one trove, in Normal Mode.
    function _liquidateNormalMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _YUSDInStabPool
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        troveManager.movePendingTroveRewardsToActivePool(
            _activePool,
            _defaultPool,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts, 
            _borrower
        );
        troveManager.removeStakeTLR(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
            singleLiquidation.entireTroveDebt,
            vars.collToLiquidate,
            _YUSDInStabPool
        );

        newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
        // rewards for WAssets sent to SP and collToRedistribute will
        // accrue to Yeti Finance Treasury until the assets are claimed
        _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

        singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);
        troveManager.closeTroveLiquidation(_borrower);

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }

        emit TroveLiquidated(
            _borrower,
            singleLiquidation.entireTroveDebt,
            TroveManagerOperation.liquidateInNormalMode
        );
        newColls memory borrowerColls;
        emit TroveUpdated(
            _borrower,
            0,
            borrowerColls.tokens,
            borrowerColls.amounts,
            TroveManagerOperation.liquidateInNormalMode
        );
    }


    // Liquidate one trove, in Recovery Mode.
    function _liquidateRecoveryMode(
        IActivePool _activePool,
        IDefaultPool _defaultPool,
        address _borrower,
        uint256 _ICR,
        uint256 _YUSDInStabPool,
        uint256 _TCR
    ) internal returns (LiquidationValues memory singleLiquidation) {
        LocalVariables_InnerSingleLiquidateFunction memory vars;

        if (troveManager.getTroveOwnersCount() <= 1) {
            return singleLiquidation;
        } // don't liquidate if last trove

        (
            singleLiquidation.entireTroveDebt,
            singleLiquidation.entireTroveColl.tokens,
            singleLiquidation.entireTroveColl.amounts,
            vars.pendingDebtReward,
            vars.pendingCollReward.tokens,
            vars.pendingCollReward.amounts
        ) = troveManager.getEntireDebtAndColls(_borrower);

        singleLiquidation.collGasCompensation = _getCollGasCompensation(
            singleLiquidation.entireTroveColl
        );

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        vars.collToLiquidate.tokens = singleLiquidation.entireTroveColl.tokens;
        uint256 collToLiquidateLen = vars.collToLiquidate.tokens.length;
        vars.collToLiquidate.amounts = new uint256[](collToLiquidateLen);
        for (uint256 i; i < collToLiquidateLen; ++i) {
            vars.collToLiquidate.amounts[i] = singleLiquidation.entireTroveColl.amounts[i].sub(
                singleLiquidation.collGasCompensation.amounts[i]
            );
        }

        // If ICR <= 100%, purely redistribute the Trove across all active Troves
        if (_ICR <= _100pct) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );
            // troveManager.movePendingTroveRewardsToActivePool(_activePool, _defaultPool, vars.pendingDebtReward, singleLiquidation.entireTroveColl.tokens, singleLiquidation.entireTroveColl.amounts);
            troveManager.removeStakeTLR(_borrower);

            singleLiquidation.debtToOffset = 0;
            newColls memory emptyColls;
            singleLiquidation.collToSendToSP = emptyColls;
            singleLiquidation.debtToRedistribute = singleLiquidation.entireTroveDebt;
            singleLiquidation.collToRedistribute = vars.collToLiquidate;

            // WAsset rewards for collToRedistribute will accrue to
            // Yeti Finance Treasury until the WAssets are claimed by troves
            _updateWAssetsRewardOwner(singleLiquidation.collToRedistribute, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );

            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
            // ICR > 100% is implied by prevoius state. 
        } else if (_ICR < MCR) {

            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts, 
                _borrower
            );

            troveManager.removeStakeTLR(_borrower);

            LocalVariables_ORVals memory or_vals = _getOffsetAndRedistributionVals(
                singleLiquidation.entireTroveDebt,
                vars.collToLiquidate,
                _YUSDInStabPool
            );

            newColls memory collsToUpdate = _sumColls(or_vals.collToSendToSP, or_vals.collToRedistribute);
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            singleLiquidation = _updateSingleLiquidation(or_vals, singleLiquidation);

            troveManager.closeTroveLiquidation(_borrower);
            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;// = troveManager.getTroveColls(_borrower);
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            /*
             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
             * and there is YUSD in the Stability Pool, only offset, with no redistribution,
             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
             * The remainder due to the capped rate will be claimable as collateral surplus.
             * ICR >= 110% is implied from last else if statement. 
             */
        } else if (
           (_ICR < _TCR) && (singleLiquidation.entireTroveDebt <= _YUSDInStabPool)
        ) {
            troveManager.movePendingTroveRewardsToActivePool(
                _activePool,
                _defaultPool,
                vars.pendingDebtReward,
                vars.pendingCollReward.tokens,
                vars.pendingCollReward.amounts,
                _borrower
            );

            require(_YUSDInStabPool != 0, "TML: zero YUSD in Stab Pool");

            troveManager.removeStakeTLR(_borrower);

            singleLiquidation = _getCappedOffsetVals(
                singleLiquidation.entireTroveDebt,
                singleLiquidation.entireTroveColl.tokens,
                singleLiquidation.entireTroveColl.amounts,
                MCR
            );

            newColls memory collsToUpdate = _sumColls(
                singleLiquidation.collToSendToSP,
                singleLiquidation.collToRedistribute
            );
            // rewards for WAssets sent to SP and collToRedistribute will
            // accrue to Yeti Finance Treasury until the assets are claimed
            _updateWAssetsRewardOwner(collsToUpdate, _borrower, yetiFinanceTreasury);

            troveManager.closeTroveLiquidation(_borrower);

            emit TroveLiquidated(
                _borrower,
                singleLiquidation.entireTroveDebt,
                TroveManagerOperation.liquidateInRecoveryMode
            );
            newColls memory borrowerColls;
            emit TroveUpdated(
                _borrower,
                0,
                borrowerColls.tokens,
                borrowerColls.amounts,
                TroveManagerOperation.liquidateInRecoveryMode
            );
        } else {
            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _YUSDInStabPool))
            LiquidationValues memory zeroVals;
            return zeroVals;
        }

        if (_CollsIsNonZero(singleLiquidation.collSurplus)) {
            troveManager.collSurplusUpdate(
                _borrower,
                singleLiquidation.collSurplus.tokens,
                singleLiquidation.collSurplus.amounts
            );
        }
    }

    function _updateSingleLiquidation(
        LocalVariables_ORVals memory or_vals,
        LiquidationValues memory singleLiquidation
    ) internal pure returns (LiquidationValues memory) {
        singleLiquidation.debtToOffset = or_vals.debtToOffset;
        singleLiquidation.collToSendToSP = or_vals.collToSendToSP;
        singleLiquidation.debtToRedistribute = or_vals.debtToRedistribute;
        singleLiquidation.collToRedistribute = or_vals.collToRedistribute;
        singleLiquidation.collSurplus = or_vals.collSurplus;
        return singleLiquidation;
    }

    /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
     * redistributed to active troves. _colls parameters is the _colls to be liquidated (total trove colls minus collateral for gas compensation)
     * collsToRedistribute.tokens and collsToRedistribute.amounts should be the same length
     * and should be the same length as _colls.tokens and _colls.amounts.
     * If there is any colls redistributed to stability pool, collsToSendToSP.tokens and collsToSendToSP.amounts
     * will be length equal to _colls.tokens and _colls.amounts. However, if no colls are redistributed to stability pool (which is the case when _YUSDInStabPool == 0),
     * then collsToSendToSP.tokens and collsToSendToSP.amounts will be empty.
     */
    function _getOffsetAndRedistributionVals(
        uint256 _entireTroveDebt,
        newColls memory _collsToLiquidate,
        uint256 _YUSDInStabPool
    ) internal view returns (LocalVariables_ORVals memory or_vals) {
        or_vals.collToRedistribute.tokens = _collsToLiquidate.tokens;
        uint256 collsToLiquidateLen = _collsToLiquidate.tokens.length;
        or_vals.collToRedistribute.amounts = new uint256[](collsToLiquidateLen);

        if (_YUSDInStabPool != 0) {
            /*
             * Offset as much debt & collateral as possible against the Stability Pool, and redistribute the remainder
             * between all active troves.
             *
             *  If the trove's debt is larger than the deposited YUSD in the Stability Pool:
             *
             *  - Offset an amount of the trove's debt equal to the YUSD in the Stability Pool
             *  - Remainder of trove's debt will be redistributed
             *  - Trove collateral can be partitioned into two parts:
             *  - (1) Offsetting Collateral = (debtToOffset / troveDebt) * Collateral
             *  - (2) Redistributed Collateral = Total Collateral - Offsetting Collateral
             *  - The max offsetting collateral that can be sent to the stability pool is an amount of collateral such that
             *  - the stability pool receives 110% of value of the debtToOffset. Any extra Offsetting Collateral is
             *  - sent to the collSurplusPool and can be claimed by the borrower.
             */
            or_vals.collToSendToSP.tokens = _collsToLiquidate.tokens;
            or_vals.collToSendToSP.amounts = new uint256[](collsToLiquidateLen);

            or_vals.collSurplus.tokens = _collsToLiquidate.tokens;
            or_vals.collSurplus.amounts = new uint256[](collsToLiquidateLen);

            or_vals.debtToOffset = LiquityMath._min(_entireTroveDebt, _YUSDInStabPool);

            or_vals.debtToRedistribute = _entireTroveDebt.sub(or_vals.debtToOffset);

            uint toLiquidateCollValueUSD = _getUSDColls(_collsToLiquidate);

            // collOffsetRatio: max percentage of the collateral that can be sent to the SP as offsetting collateral
            // collOffsetRatio = percentage of the trove's debt that can be offset by the stability pool
            uint256 collOffsetRatio = _100pct.mul(_100pct).mul(or_vals.debtToOffset).div(_entireTroveDebt);

            // SPRatio: percentage of liquidated collateral that needs to be sent to SP in order to give SP depositors
            // $110 of collateral for every 100 YUSD they are using to liquidate.
            uint256 SPRatio = or_vals.debtToOffset.mul(_100pct).mul(_110pct).div(toLiquidateCollValueUSD);

            // But SP ratio is capped at collOffsetRatio:
            SPRatio = LiquityMath._min(collOffsetRatio, SPRatio);

            // if there is extra collateral left in the offset portion of the collateral after
            // giving stability pool holders $110 of collateral for every 100 YUSD that is taken from them,
            // then this is surplus collateral that can be claimed by the borrower
            uint256 collSurplusRatio = collOffsetRatio.sub(SPRatio);

            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToSendToSP.amounts[i] = _collsToLiquidate.amounts[i].mul(SPRatio).div(
                    _100pct
                ).div(_100pct);

                or_vals.collSurplus.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .mul(collSurplusRatio)
                    .div(_100pct)
                    .div(_100pct);

                // remaining collateral is redistributed:
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate
                    .amounts[i]
                    .sub(or_vals.collToSendToSP.amounts[i])
                    .sub(or_vals.collSurplus.amounts[i]);
            }
        } else {
            // all colls are redistributed because no YUSD in stability pool to liquidate
            or_vals.debtToOffset = 0;
            for (uint256 i; i < collsToLiquidateLen; ++i) {
                or_vals.collToRedistribute.amounts[i] = _collsToLiquidate.amounts[i];
            }
            or_vals.debtToRedistribute = _entireTroveDebt;
        }
    }

    function _addLiquidationValuesToTotals(
        LiquidationTotals memory oldTotals,
        LiquidationValues memory singleLiquidation
    ) internal view returns (LiquidationTotals memory newTotals) {
        // Tally all the values with their respective running totals
        //update one of these
        newTotals.totalCollGasCompensation = _sumColls(
            oldTotals.totalCollGasCompensation,
            singleLiquidation.collGasCompensation
        );
        newTotals.totalYUSDGasCompensation = oldTotals.totalYUSDGasCompensation.add(
            singleLiquidation.YUSDGasCompensation
        );
        newTotals.totalDebtInSequence = oldTotals.totalDebtInSequence.add(
            singleLiquidation.entireTroveDebt
        );
        newTotals.totalDebtToOffset = oldTotals.totalDebtToOffset.add(
            singleLiquidation.debtToOffset
        );
        newTotals.totalCollToSendToSP = _sumColls(
            oldTotals.totalCollToSendToSP,
            singleLiquidation.collToSendToSP
        );
        newTotals.totalDebtToRedistribute = oldTotals.totalDebtToRedistribute.add(
            singleLiquidation.debtToRedistribute
        );
        newTotals.totalCollToRedistribute = _sumColls(
            oldTotals.totalCollToRedistribute,
            singleLiquidation.collToRedistribute
        );
        newTotals.totalCollSurplus = _sumColls(
            oldTotals.totalCollSurplus,
            singleLiquidation.collSurplus
        );
    }

    /*
    *  Get its offset coll/debt and Collateral gas comp, and close the trove.
    */
    function _getCappedOffsetVals
    (
        uint _entireTroveDebt,
        address[] memory _troveTokens,
        uint[] memory _troveAmounts,
        uint _MCR
    )
    internal
    view
    returns (LiquidationValues memory singleLiquidation)
    {
        newColls memory _entireTroveColl;
        _entireTroveColl.tokens = _troveTokens;
        _entireTroveColl.amounts = _troveAmounts;

        uint USD_Value_To_Send_To_SP = _MCR.mul(_entireTroveDebt).div(_100pct);
        uint USD_Value_of_Trove_Colls = _getUSDColls(_entireTroveColl);

        uint SPRatio = USD_Value_To_Send_To_SP.mul(_100pct).div(USD_Value_of_Trove_Colls);
        SPRatio = LiquityMath._min(SPRatio, _100pct);

        singleLiquidation.entireTroveDebt = _entireTroveDebt;
        singleLiquidation.entireTroveColl = _entireTroveColl;

        singleLiquidation.YUSDGasCompensation = YUSD_GAS_COMPENSATION;

        singleLiquidation.debtToOffset = _entireTroveDebt;
        singleLiquidation.debtToRedistribute = 0;

        singleLiquidation.collToSendToSP.tokens = _troveTokens;
        uint256 troveTokensLen = _troveTokens.length;
        
        singleLiquidation.collToSendToSP.amounts = new uint[](troveTokensLen);

        singleLiquidation.collSurplus.tokens = _troveTokens;
        singleLiquidation.collSurplus.amounts = new uint[](troveTokensLen);

        singleLiquidation.collGasCompensation.tokens = _troveTokens;
        singleLiquidation.collGasCompensation.amounts = new uint[](troveTokensLen);

        for (uint256 i; i < troveTokensLen; ++i) {
            uint _cappedCollAmount = SPRatio.mul(_troveAmounts[i]).div(_100pct);
            uint _gasComp = _cappedCollAmount.div(PERCENT_DIVISOR);
            uint _toSP = _cappedCollAmount.sub(_gasComp);
            uint _collSurplus = _troveAmounts[i].sub(_cappedCollAmount);

            singleLiquidation.collGasCompensation.amounts[i] = _gasComp;
            singleLiquidation.collToSendToSP.amounts[i] = _toSP;
            singleLiquidation.collSurplus.amounts[i] = _collSurplus;
        }
    }

    function _sendGasCompensation(
        IActivePool _activePool,
        address _liquidator,
        uint256 _YUSD,
        address[] memory _tokens,
        uint256[] memory _amounts
    ) internal {
        if (_YUSD != 0) {
            yusdTokenContract.returnFromPool(gasPoolAddress, _liquidator, _YUSD);
        }

        // This contract owns the rewards temporarily until the liquidation is complete
        _activePool.sendCollateralsUnwrap(address(this), _liquidator, _tokens, _amounts);
    }

    /*
     * Update rewards tracking so future rewards go to Yeti Finance Treasury
     * for the trove's asset that have been liquidated and moved to either the
     * Stability Pool or Default Pool
    */
    function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {
        uint256 collsLen = _colls.tokens.length;
        for (uint256 i; i < collsLen; ++i) {
            address token = _colls.tokens[i];
            if (whitelist.isWrapped(token)) {
                IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);
            }
        }
    }

    function _requireCallerisTroveManager() internal view {
        require(msg.sender == troveManagerAddress, "Caller not TM");
    }


    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
    function _getCollGasCompensation(newColls memory _coll) internal pure returns (newColls memory) {
        require(_coll.tokens.length == _coll.amounts.length, "Not same length");

        uint[] memory amounts = new uint[](_coll.tokens.length);
        for (uint256 i; i < _coll.tokens.length; ++i) {
            amounts[i] = _coll.amounts[i] / PERCENT_DIVISOR;
        }
        return newColls(_coll.tokens, amounts);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

