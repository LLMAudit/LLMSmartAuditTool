[2024-23-08 11:01:52 INFO] **[Preprocessing]**

**ChatDev Starts** (20240823110152)

**Timestamp**: 20240823110152

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }

**project_name**: RealWorld_BA_66_TroveManager

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_66_TroveManager_RealWord_20240823110152.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-23-08 11:01:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = "TroveManager";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:52 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-23-08 11:01:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:01:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20021
completion_tokens: 1
total_tokens: 20022
cost: $-1.000000


[2024-23-08 11:01:56 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Let's

[2024-23-08 11:01:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n    IStabilityPool internal stabilityPoolContract;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdTokenContract;\n    IYETIToken internal yetiTokenContract;\n    ISYETI internal sYETIContract;\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n    ISortedTroves internal sortedTroves;\n    ICollSurplusPool internal collSurplusPool;\n    bytes32 constant public NAME = "TroveManager";\n    // --- Data structures ---\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n    uint public baseRate;\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n    mapping (address =&gt; Trove) Troves;\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n    // --- Events ---\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n    // --- Getters ---\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n    // --- Trove Liquidation functions ---\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n    // --- Liquidation helper functions ---\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n    // --- Helper functions ---\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n            _updateTroveRewardSnapshots(_borrower);\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n            uint stake =  Troves[_borrower].stakes[coll];\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        debt = debt.add(pendingYUSDDebtReward);\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n        address addressToMove = TroveOwners[idxLast];\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n        TroveOwners.pop();\n    }\n    // --- Recovery Mode and TCR functions ---\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n    // --- Redemption fee functions ---\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n    // --- \'require\' wrapper functions ---\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n    // --- Trove property getters ---\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n    // -- Trove Manager State Variable Getters -- \n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n    // --- Called by TroveManagerRedemptions Only ---\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n    // --- Called by TroverManagerLiquidations Only ---\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n    // --- Trove property setters, called by BorrowerOperations ---\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n    // --- contract getters ---\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.11;\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n    IStabilityPool internal stabilityPoolContract;\n    ITroveManager internal troveManager;\n    IYUSDToken internal yusdTokenContract;\n    IYETIToken internal yetiTokenContract;\n    ISYETI internal sYETIContract;\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n    ISortedTroves internal sortedTroves;\n    ICollSurplusPool internal collSurplusPool;\n    bytes32 constant public NAME = "TroveManager";\n    // --- Data structures ---\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n    uint public baseRate;\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n    mapping (address =&gt; Trove) Troves;\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n    // --- Events ---\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n    // --- Getters ---\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n    // --- Trove Liquidation functions ---\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n    // --- Liquidation helper functions ---\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n    // --- Helper functions ---\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n            _updateTroveRewardSnapshots(_borrower);\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n            uint stake =  Troves[_borrower].stakes[coll];\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        debt = debt.add(pendingYUSDDebtReward);\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n        address addressToMove = TroveOwners[idxLast];\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n        TroveOwners.pop();\n    }\n    // --- Recovery Mode and TCR functions ---\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n    // --- Redemption fee functions ---\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n    // --- Borrowing fee functions ---\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    // --- Internal fee functions ---\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n    // --- \'require\' wrapper functions ---\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n    // --- Trove property getters ---\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n    // -- Trove Manager State Variable Getters -- \n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n    // --- Called by TroveManagerRedemptions Only ---\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n    // --- Called by TroverManagerLiquidations Only ---\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n    // --- Trove property setters, called by BorrowerOperations ---\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n    // --- contract getters ---\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:01:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:01:57 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";

/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */
contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;
    IStabilityPool internal stabilityPoolContract;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdTokenContract;
    IYETIToken internal yetiTokenContract;
    ISYETI internal sYETIContract;
    ITroveManagerRedemptions internal troveManagerRedemptions;
    ITroveManagerLiquidations internal troveManagerLiquidations;
    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;
    ISortedTroves internal sortedTroves;
    ICollSurplusPool internal collSurplusPool;
    bytes32 constant public NAME = "TroveManager";
    // --- Data structures ---
    uint constant internal SECONDS_IN_ONE_MINUTE = 60;
    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%
    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;
    uint public baseRate;
    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;
    mapping (address => Trove) Troves;
    // uint public totalStakes;
    mapping (address => uint) public totalStakes;
    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;
    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;
    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;
    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;
    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }
    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;
    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;
    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/
    // --- Events ---
    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);
    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);
    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);
    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);
        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }
    // --- Getters ---
    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }
    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }
    // --- Trove Liquidation functions ---
    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);
        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }
    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }
    // --- Liquidation helper functions ---
    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }
    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }
    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }
    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);
        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;
        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }
    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");
        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }
    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }
    // --- Helper functions ---
    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }
    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }
    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }
    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);
            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
            _updateTroveRewardSnapshots(_borrower);
            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);
            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }
    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }
    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }
    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }
    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }
        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }
            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }
    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }
            uint stake =  Troves[_borrower].stakes[coll];
            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }
    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }
    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        debt = debt.add(pendingYUSDDebtReward);
        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);
        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }
    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }
    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }
    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }
    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];
            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];
            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);
            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }
    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }
    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));
                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));
                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }
        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }
    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }
    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }
    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }
    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");
        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;
        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;
        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }
        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }
    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];
            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }
    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }
    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);
        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }
    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");
        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);
        require(index <= idxLast, "TM: index must be > last index");
        address addressToMove = TroveOwners[idxLast];
        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);
        TroveOwners.pop();
    }
    // --- Recovery Mode and TCR functions ---
    function getTCR() external view override returns (uint) {
        return _getTCR();
    }
    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }

    // --- Redemption fee functions ---
    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }
    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }
    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }
    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }
    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }
    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }
    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }

    // --- Borrowing fee functions ---
    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }
    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }
    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }
    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }
    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }
    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }

    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();
        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0
        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);
        _updateLastFeeOpTime();
    }

    // --- Internal fee functions ---
    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);
        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }
    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);
        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }
    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }
    // --- 'require' wrapper functions ---
    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }
    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }
    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }
    // --- Trove property getters ---
    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }
    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }
    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }
    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }
    // -- Trove Manager State Variable Getters -- 
    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }
    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }
    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }
    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }
    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }
    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }
    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }
    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }
    // --- Called by TroveManagerRedemptions Only ---

    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }
    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }
    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }
    // --- Called by TroverManagerLiquidations Only ---
    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }
    // --- Trove property setters, called by BorrowerOperations ---
    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }
    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }
    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }
    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }
    // --- contract getters ---
    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }
    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }
    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }
    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;
import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";

/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */
contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;
    IStabilityPool internal stabilityPoolContract;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdTokenContract;
    IYETIToken internal yetiTokenContract;
    ISYETI internal sYETIContract;
    ITroveManagerRedemptions internal troveManagerRedemptions;
    ITroveManagerLiquidations internal troveManagerLiquidations;
    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;
    ISortedTroves internal sortedTroves;
    ICollSurplusPool internal collSurplusPool;
    bytes32 constant public NAME = "TroveManager";
    // --- Data structures ---
    uint constant internal SECONDS_IN_ONE_MINUTE = 60;
    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%
    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;
    uint public baseRate;
    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;
    mapping (address => Trove) Troves;
    // uint public totalStakes;
    mapping (address => uint) public totalStakes;
    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;
    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;
    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;
    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;
    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }
    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;
    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;
    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/
    // --- Events ---
    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);
    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);
    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);
    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);
        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }
    // --- Getters ---
    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }
    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }
    // --- Trove Liquidation functions ---
    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);
        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }
    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }
    // --- Liquidation helper functions ---
    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }
    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }
    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }
    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);
        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;
        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }
    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");
        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }
    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }
    // --- Helper functions ---
    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }
    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }
    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }
    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);
            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
            _updateTroveRewardSnapshots(_borrower);
            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);
            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }
    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }
    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }
    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }
    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }
        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }
            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }
    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }
            uint stake =  Troves[_borrower].stakes[coll];
            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }
    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }
    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        debt = debt.add(pendingYUSDDebtReward);
        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);
        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }
    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }
    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }
    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }
    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];
            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];
            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);
            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }
    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }
    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));
                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));
                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }
        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }
    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }
    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }
    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }
    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");
        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;
        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;
        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }
        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }
    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];
            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }
    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }
    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);
        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }
    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");
        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);
        require(index <= idxLast, "TM: index must be > last index");
        address addressToMove = TroveOwners[idxLast];
        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);
        TroveOwners.pop();
    }
    // --- Recovery Mode and TCR functions ---
    function getTCR() external view override returns (uint) {
        return _getTCR();
    }
    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }

    // --- Redemption fee functions ---
    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }
    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }
    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }
    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }
    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }
    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }
    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }

    // --- Borrowing fee functions ---
    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }
    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }
    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }
    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }
    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }
    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }

    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();
        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0
        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);
        _updateLastFeeOpTime();
    }

    // --- Internal fee functions ---
    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);
        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }
    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);
        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }
    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }
    // --- 'require' wrapper functions ---
    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }
    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }
    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }
    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }
    // --- Trove property getters ---
    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }
    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }
    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }
    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }
    // -- Trove Manager State Variable Getters -- 
    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }
    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }
    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }
    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }
    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }
    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }
    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }
    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }
    // --- Called by TroveManagerRedemptions Only ---

    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }
    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }
    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }
    // --- Called by TroverManagerLiquidations Only ---
    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }
    // --- Trove property setters, called by BorrowerOperations ---
    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }
    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }
    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }
    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }
    // --- contract getters ---
    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }
    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }
    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }
    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-23-08 11:02:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30053
completion_tokens: 1
total_tokens: 30054
cost: $-1.000000


[2024-23-08 11:02:01 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Security

[2024-23-08 11:02:01 INFO] **[Seminar Conclusion]**:

 Security

[2024-23-08 11:02:01 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-23-08 11:02:01 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 11:02:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = "TroveManager";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:01 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:02:04 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:04 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20012
completion_tokens: 1
total_tokens: 20013
cost: $-1.000000


[2024-23-08 11:02:04 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

###

[2024-23-08 11:02:04 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:02:04 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-23-08 11:02:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:04 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:02:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10065
completion_tokens: 832
total_tokens: 10897
cost: $-1.000000


[2024-23-08 11:02:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Based on the provided Solidity smart contract code for the `TroveManager`, here is a summary of the potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract implements `ReentrancyGuard`, there are multiple functions that call external contracts (e.g., `troveManagerLiquidations.batchLiquidateTroves`). If these external calls are not properly managed, they could still be susceptible to reentrancy attacks.

2. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions like `setAddresses`. If the ownership is compromised, an attacker could manipulate the contract's state.
   - There are several internal functions that require specific caller checks (e.g., `_requireCallerIsTML`, `_requireCallerIsTMR`). If these checks are not robust, they could allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, any arithmetic operations that involve user inputs or external contract calls should be carefully validated to prevent unexpected behaviors.

4. **Gas Limit and Loops**:
   - Functions like `updateTroves` and `redeemCollateral` involve loops that could potentially run out of gas if the input arrays are too large. This could lead to denial of service if not handled properly.

5. **Improper Error Handling**:
   - The contract uses `require` statements for input validation, but it lacks detailed error messages in some cases, which could make debugging difficult.

6. **Lack of Input Validation**:
   - Functions that accept addresses or amounts (e.g., `setAddresses`, `updateTroveColl`) do not perform thorough validation on the inputs, which could lead to unexpected behavior or state corruption.

7. **Potential for Unchecked External Calls**:
   - The contract makes several external calls to other contracts (e.g., `collSurplusPool.accountSurplus`). If these contracts are malicious or have vulnerabilities, they could exploit the `TroveManager`.

8. **State Variable Visibility**:
   - Some state variables are declared as `internal` when they could be `private`, which exposes them to derived contracts unnecessarily.

9. **Lack of Events for Critical State Changes**:
   - While there are events emitted for some state changes, critical operations (like state transitions in troves) may not have corresponding events, making it difficult to track changes on-chain.

### Comprehensive Analysis Report

The `TroveManager` contract is a complex piece of code that manages user troves and collateralized debt positions. While it incorporates several best practices, including the use of interfaces and modular design, there are notable security vulnerabilities that need to be addressed:

- **Reentrancy Protection**: Ensure that all external calls are properly guarded against reentrancy attacks, even with the `ReentrancyGuard` in place.
- **Access Control**: Strengthen access control mechanisms to ensure that only authorized entities can execute sensitive functions. Consider implementing role-based access control for better granularity.
- **Input Validation**: Implement thorough input validation for all functions that accept user inputs to prevent unexpected behaviors and state corruption.
- **Gas Limit Management**: Review functions with loops to ensure they can handle large inputs without running out of gas. Consider implementing chunking or limiting the number of iterations.
- **Error Handling**: Improve error messages in `require` statements to facilitate easier debugging and understanding of failures.
- **State Variable Management**: Review the visibility of state variables and restrict access where possible to enhance encapsulation.
- **Event Emission**: Ensure that all critical state changes are accompanied by appropriate event emissions to facilitate tracking and monitoring.

In conclusion, while the `TroveManager` contract demonstrates a solid foundation for managing collateralized debt positions, addressing the identified vulnerabilities will significantly enhance its security posture and resilience against potential attacks. A thorough audit and testing phase should be conducted before deployment to ensure the contract's integrity and security in a live environment.

[2024-23-08 11:02:32 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `TroveManager`, here is a summary of the potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract implements `ReentrancyGuard`, there are multiple functions that call external contracts (e.g., `troveManagerLiquidations.batchLiquidateTroves`). If these external calls are not properly managed, they could still be susceptible to reentrancy attacks.

2. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions like `setAddresses`. If the ownership is compromised, an attacker could manipulate the contract's state.
   - There are several internal functions that require specific caller checks (e.g., `_requireCallerIsTML`, `_requireCallerIsTMR`). If these checks are not robust, they could allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.6.x has built-in overflow/underflow checks, any arithmetic operations that involve user inputs or external contract calls should be carefully validated to prevent unexpected behaviors.

4. **Gas Limit and Loops**:
   - Functions like `updateTroves` and `redeemCollateral` involve loops that could potentially run out of gas if the input arrays are too large. This could lead to denial of service if not handled properly.

5. **Improper Error Handling**:
   - The contract uses `require` statements for input validation, but it lacks detailed error messages in some cases, which could make debugging difficult.

6. **Lack of Input Validation**:
   - Functions that accept addresses or amounts (e.g., `setAddresses`, `updateTroveColl`) do not perform thorough validation on the inputs, which could lead to unexpected behavior or state corruption.

7. **Potential for Unchecked External Calls**:
   - The contract makes several external calls to other contracts (e.g., `collSurplusPool.accountSurplus`). If these contracts are malicious or have vulnerabilities, they could exploit the `TroveManager`.

8. **State Variable Visibility**:
   - Some state variables are declared as `internal` when they could be `private`, which exposes them to derived contracts unnecessarily.

9. **Lack of Events for Critical State Changes**:
   - While there are events emitted for some state changes, critical operations (like state transitions in troves) may not have corresponding events, making it difficult to track changes on-chain.

### Comprehensive Analysis Report

The `TroveManager` contract is a complex piece of code that manages user troves and collateralized debt positions. While it incorporates several best practices, including the use of interfaces and modular design, there are notable security vulnerabilities that need to be addressed:

- **Reentrancy Protection**: Ensure that all external calls are properly guarded against reentrancy attacks, even with the `ReentrancyGuard` in place.
- **Access Control**: Strengthen access control mechanisms to ensure that only authorized entities can execute sensitive functions. Consider implementing role-based access control for better granularity.
- **Input Validation**: Implement thorough input validation for all functions that accept user inputs to prevent unexpected behaviors and state corruption.
- **Gas Limit Management**: Review functions with loops to ensure they can handle large inputs without running out of gas. Consider implementing chunking or limiting the number of iterations.
- **Error Handling**: Improve error messages in `require` statements to facilitate easier debugging and understanding of failures.
- **State Variable Management**: Review the visibility of state variables and restrict access where possible to enhance encapsulation.
- **Event Emission**: Ensure that all critical state changes are accompanied by appropriate event emissions to facilitate tracking and monitoring.

In conclusion, while the `TroveManager` contract demonstrates a solid foundation for managing collateralized debt positions, addressing the identified vulnerabilities will significantly enhance its security posture and resilience against potential attacks. A thorough audit and testing phase should be conducted before deployment to ensure the contract's integrity and security in a live environment.

[2024-23-08 11:02:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 11:02:33 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = "TroveManager";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:33 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:33 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:02:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20012
completion_tokens: 1
total_tokens: 20013
cost: $-1.000000


[2024-23-08 11:02:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

###

[2024-23-08 11:02:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:02:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-23-08 11:02:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:02:47 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:47 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10065
completion_tokens: 909
total_tokens: 10974
cost: $-1.000000


[2024-23-08 11:02:47 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Based on the provided smart contract code for the `TroveManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - Although the contract uses the `ReentrancyGuard` to prevent reentrancy attacks, it is crucial to ensure that all external calls are properly guarded. Any function that interacts with external contracts should be reviewed to confirm that they do not allow reentrancy.

2. **Arithmetic Issues**:
   - The contract uses Solidity version 0.6.11, which does not have built-in overflow and underflow checks. While the code uses SafeMath for arithmetic operations, it is essential to ensure that all arithmetic operations are correctly handled to prevent potential overflow or underflow issues.

3. **Access Control**:
   - The contract relies on `onlyOwner` and other custom access control mechanisms. It is vital to ensure that these modifiers are correctly implemented and that there are no functions that can be called by unauthorized users, which could lead to privilege escalation.

4. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `updateTroves`, `batchLiquidateTroves`) may run into gas limit issues if the arrays are large. This could lead to transaction failures. It is advisable to implement chunking or batching mechanisms to handle large datasets.

5. **Timestamp Dependence**:
   - The contract uses block timestamps for critical operations (e.g., `lastFeeOperationTime`). This can be manipulated by miners, leading to potential exploitation. It is recommended to use block numbers instead of timestamps for critical logic.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly (e.g., checking for zero addresses or ensuring that arrays are not empty). This could lead to unexpected behavior or vulnerabilities.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions. Consider implementing time-locks or commit-reveal schemes to mitigate this risk.

8. **State Variable Visibility**:
   - Some state variables are declared as `internal` when they could be `private`. This could expose sensitive data to derived contracts unintentionally. Review the visibility of state variables to ensure they are as restrictive as necessary.

9. **Error Handling**:
   - The contract uses `require` statements for error handling, which is good practice. However, it is essential to ensure that all require statements provide meaningful error messages to aid in debugging.

### Comprehensive Analysis Report:

The `TroveManager` contract is a complex financial instrument that manages user troves, liquidations, and redemptions. While it incorporates several best practices, such as the use of `ReentrancyGuard` and SafeMath, there are notable vulnerabilities that need to be addressed to enhance the security posture of the contract.

1. **Reentrancy Protection**: Ensure that all external calls are adequately protected against reentrancy attacks, especially in functions that modify state variables.

2. **Arithmetic Safety**: Transition to a more recent version of Solidity that includes built-in overflow and underflow checks or ensure that SafeMath is consistently used throughout the contract.

3. **Access Control**: Conduct a thorough audit of all access control mechanisms to ensure that only authorized entities can execute sensitive functions.

4. **Gas Limit Management**: Implement strategies to handle large arrays and avoid gas limit issues, potentially by breaking down operations into smaller, manageable chunks.

5. **Timestamp Manipulation**: Replace reliance on block timestamps for critical logic with block numbers to mitigate the risk of miner manipulation.

6. **Input Validation**: Enhance input validation to prevent unexpected behavior and ensure that all inputs are checked for validity.

7. **Front-Running Mitigation**: Consider implementing mechanisms to protect against front-running attacks, which could lead to financial losses for users.

8. **State Variable Visibility**: Review and adjust the visibility of state variables to ensure that sensitive data is adequately protected.

9. **Error Messaging**: Ensure that all require statements provide clear and informative error messages to facilitate debugging and user understanding.

In conclusion, while the `TroveManager` contract demonstrates a solid foundation for managing user interactions with the system, addressing the identified vulnerabilities will significantly enhance its security and reliability. A comprehensive security audit and testing should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-23-08 11:02:47 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `TroveManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - Although the contract uses the `ReentrancyGuard` to prevent reentrancy attacks, it is crucial to ensure that all external calls are properly guarded. Any function that interacts with external contracts should be reviewed to confirm that they do not allow reentrancy.

2. **Arithmetic Issues**:
   - The contract uses Solidity version 0.6.11, which does not have built-in overflow and underflow checks. While the code uses SafeMath for arithmetic operations, it is essential to ensure that all arithmetic operations are correctly handled to prevent potential overflow or underflow issues.

3. **Access Control**:
   - The contract relies on `onlyOwner` and other custom access control mechanisms. It is vital to ensure that these modifiers are correctly implemented and that there are no functions that can be called by unauthorized users, which could lead to privilege escalation.

4. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `updateTroves`, `batchLiquidateTroves`) may run into gas limit issues if the arrays are large. This could lead to transaction failures. It is advisable to implement chunking or batching mechanisms to handle large datasets.

5. **Timestamp Dependence**:
   - The contract uses block timestamps for critical operations (e.g., `lastFeeOperationTime`). This can be manipulated by miners, leading to potential exploitation. It is recommended to use block numbers instead of timestamps for critical logic.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly (e.g., checking for zero addresses or ensuring that arrays are not empty). This could lead to unexpected behavior or vulnerabilities.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions. Consider implementing time-locks or commit-reveal schemes to mitigate this risk.

8. **State Variable Visibility**:
   - Some state variables are declared as `internal` when they could be `private`. This could expose sensitive data to derived contracts unintentionally. Review the visibility of state variables to ensure they are as restrictive as necessary.

9. **Error Handling**:
   - The contract uses `require` statements for error handling, which is good practice. However, it is essential to ensure that all require statements provide meaningful error messages to aid in debugging.

### Comprehensive Analysis Report:

The `TroveManager` contract is a complex financial instrument that manages user troves, liquidations, and redemptions. While it incorporates several best practices, such as the use of `ReentrancyGuard` and SafeMath, there are notable vulnerabilities that need to be addressed to enhance the security posture of the contract.

1. **Reentrancy Protection**: Ensure that all external calls are adequately protected against reentrancy attacks, especially in functions that modify state variables.

2. **Arithmetic Safety**: Transition to a more recent version of Solidity that includes built-in overflow and underflow checks or ensure that SafeMath is consistently used throughout the contract.

3. **Access Control**: Conduct a thorough audit of all access control mechanisms to ensure that only authorized entities can execute sensitive functions.

4. **Gas Limit Management**: Implement strategies to handle large arrays and avoid gas limit issues, potentially by breaking down operations into smaller, manageable chunks.

5. **Timestamp Manipulation**: Replace reliance on block timestamps for critical logic with block numbers to mitigate the risk of miner manipulation.

6. **Input Validation**: Enhance input validation to prevent unexpected behavior and ensure that all inputs are checked for validity.

7. **Front-Running Mitigation**: Consider implementing mechanisms to protect against front-running attacks, which could lead to financial losses for users.

8. **State Variable Visibility**: Review and adjust the visibility of state variables to ensure that sensitive data is adequately protected.

9. **Error Messaging**: Ensure that all require statements provide clear and informative error messages to facilitate debugging and user understanding.

In conclusion, while the `TroveManager` contract demonstrates a solid foundation for managing user interactions with the system, addressing the identified vulnerabilities will significantly enhance its security and reliability. A comprehensive security audit and testing should be conducted before deployment to ensure that all potential risks are mitigated.

[2024-23-08 11:02:47 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 11:02:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = "TroveManager";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:47 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-23-08 11:02:50 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:02:50 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20012
completion_tokens: 1
total_tokens: 20013
cost: $-1.000000


[2024-23-08 11:02:50 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

###

[2024-23-08 11:02:50 INFO] **[Seminar Conclusion]**:

 ###

[2024-23-08 11:02:50 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-23-08 11:02:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-23-08 11:02:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:02:50 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-23-08 11:03:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-23-08 11:03:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10065
completion_tokens: 840
total_tokens: 10905
cost: $-1.000000


[2024-23-08 11:03:19 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Based on the provided Solidity smart contract code for the `TroveManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses the `ReentrancyGuard` to prevent reentrancy attacks, it is crucial to ensure that all external calls are properly guarded. Any function that interacts with external contracts should be carefully reviewed to ensure that state changes occur before external calls.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses Solidity version 0.6.11, which has built-in overflow and underflow checks. However, if the contract were to be upgraded to an earlier version, it would be susceptible to arithmetic issues. It is essential to ensure that all arithmetic operations are safe, especially in functions that handle user balances and stakes.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions, but it is essential to ensure that ownership is managed securely. If the owner’s address is compromised, it could lead to unauthorized access to sensitive functions.

4. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `updateTroves`, `redeemCollateral`) could run into gas limit issues if the number of troves or tokens is large. This could lead to failed transactions and denial of service for users.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly, such as checking for zero values or ensuring that arrays have matching lengths. This could lead to unexpected behavior or state corruption.

6. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if an external contract called during a transaction fails. This could prevent users from executing critical functions like liquidations or redemptions.

7. **Inadequate Event Emissions**:
   - While the contract emits events for significant state changes, it may not emit events for all critical actions, such as when stakes are updated or when rewards are applied. This could hinder transparency and tracking of contract activity.

8. **Uncontrolled External Calls**:
   - The contract makes several external calls to other contracts (e.g., `collSurplusPool`, `activePool`). If these contracts are not trusted or have vulnerabilities, they could compromise the security of the `TroveManager`.

### Comprehensive Analysis Report:

The `TroveManager` contract is a complex piece of code that handles critical operations related to user troves, including liquidations, redemptions, and reward distributions. While it incorporates several security measures, including reentrancy protection and arithmetic checks, there are still notable vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must ensure that all external calls are made after state changes to prevent reentrancy attacks.

2. **Access Control**: The reliance on ownership for critical functions necessitates a robust ownership management strategy. Consider implementing multi-signature wallets or role-based access control to enhance security.

3. **Gas Limit Considerations**: Functions that may iterate over large datasets should be optimized or designed to handle gas limits gracefully. This could involve batching operations or limiting the number of iterations.

4. **Input Validation**: Implement thorough input validation checks to prevent unexpected behavior. This includes ensuring that arrays are of the same length and that critical parameters are not zero.

5. **Event Emissions**: Increasing the granularity of event emissions can improve transparency and allow for better tracking of contract interactions.

6. **External Call Management**: Careful consideration should be given to the contracts being interacted with. Ensure that they are audited and trusted to minimize the risk of external vulnerabilities affecting the `TroveManager`.

In conclusion, while the `TroveManager` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing process, including formal verification and audits, are recommended before deployment to ensure the integrity and safety of user funds.

[2024-23-08 11:03:19 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `TroveManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses the `ReentrancyGuard` to prevent reentrancy attacks, it is crucial to ensure that all external calls are properly guarded. Any function that interacts with external contracts should be carefully reviewed to ensure that state changes occur before external calls.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses Solidity version 0.6.11, which has built-in overflow and underflow checks. However, if the contract were to be upgraded to an earlier version, it would be susceptible to arithmetic issues. It is essential to ensure that all arithmetic operations are safe, especially in functions that handle user balances and stakes.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions, but it is essential to ensure that ownership is managed securely. If the owner’s address is compromised, it could lead to unauthorized access to sensitive functions.

4. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `updateTroves`, `redeemCollateral`) could run into gas limit issues if the number of troves or tokens is large. This could lead to failed transactions and denial of service for users.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly, such as checking for zero values or ensuring that arrays have matching lengths. This could lead to unexpected behavior or state corruption.

6. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if an external contract called during a transaction fails. This could prevent users from executing critical functions like liquidations or redemptions.

7. **Inadequate Event Emissions**:
   - While the contract emits events for significant state changes, it may not emit events for all critical actions, such as when stakes are updated or when rewards are applied. This could hinder transparency and tracking of contract activity.

8. **Uncontrolled External Calls**:
   - The contract makes several external calls to other contracts (e.g., `collSurplusPool`, `activePool`). If these contracts are not trusted or have vulnerabilities, they could compromise the security of the `TroveManager`.

### Comprehensive Analysis Report:

The `TroveManager` contract is a complex piece of code that handles critical operations related to user troves, including liquidations, redemptions, and reward distributions. While it incorporates several security measures, including reentrancy protection and arithmetic checks, there are still notable vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect, but developers must ensure that all external calls are made after state changes to prevent reentrancy attacks.

2. **Access Control**: The reliance on ownership for critical functions necessitates a robust ownership management strategy. Consider implementing multi-signature wallets or role-based access control to enhance security.

3. **Gas Limit Considerations**: Functions that may iterate over large datasets should be optimized or designed to handle gas limits gracefully. This could involve batching operations or limiting the number of iterations.

4. **Input Validation**: Implement thorough input validation checks to prevent unexpected behavior. This includes ensuring that arrays are of the same length and that critical parameters are not zero.

5. **Event Emissions**: Increasing the granularity of event emissions can improve transparency and allow for better tracking of contract interactions.

6. **External Call Management**: Careful consideration should be given to the contracts being interacted with. Ensure that they are audited and trusted to minimize the risk of external vulnerabilities affecting the `TroveManager`.

In conclusion, while the `TroveManager` contract has a solid foundation, addressing the identified vulnerabilities will significantly enhance its security posture. A thorough review and testing process, including formal verification and audits, are recommended before deployment to ensure the integrity and safety of user funds.

[2024-23-08 11:03:22 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport "./Interfaces/ITroveManager.sol";\nimport "./Interfaces/IStabilityPool.sol";\nimport "./Interfaces/ICollSurplusPool.sol";\nimport "./Interfaces/IYUSDToken.sol";\nimport "./Interfaces/ISortedTroves.sol";\nimport "./Interfaces/IYETIToken.sol";\nimport "./Interfaces/ISYETI.sol";\nimport "./Interfaces/IWhitelist.sol";\nimport "./Interfaces/ITroveManagerLiquidations.sol";\nimport "./Interfaces/ITroveManagerRedemptions.sol";\nimport "./Interfaces/IERC20.sol";\nimport "./Dependencies/TroveManagerBase.sol";\nimport "./Dependencies/ReentrancyGuard.sol";\n\n\n/ \n * Trove Manager is the contract which deals with the state of a user\'s trove. It has all the \n * external functions for liquidations, redemptions, as well as functions called by \n * BorrowerOperations function calls. \n /\n\ncontract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {\n    \n    address internal borrowerOperationsAddress;\n\n    IStabilityPool internal stabilityPoolContract;\n\n    ITroveManager internal troveManager;\n\n    IYUSDToken internal yusdTokenContract;\n\n    IYETIToken internal yetiTokenContract;\n\n    ISYETI internal sYETIContract;\n\n    ITroveManagerRedemptions internal troveManagerRedemptions;\n\n    ITroveManagerLiquidations internal troveManagerLiquidations;\n\n    address internal gasPoolAddress;\n    address internal troveManagerRedemptionsAddress;\n    address internal troveManagerLiquidationsAddress;\n\n    ISortedTroves internal sortedTroves;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    bytes32 constant public NAME = "TroveManager";\n\n    // --- Data structures ---\n\n    uint constant internal SECONDS_IN_ONE_MINUTE = 60;\n\n    /\n     * Half-life of 12h. 12h = 720 min\n     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)\n     /\n    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;\n    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // During bootsrap period redemptions are not allowed\n    uint constant public BOOTSTRAP_PERIOD = 14 days;\n\n    uint public baseRate;\n\n    // The timestamp of the latest fee operation (redemption or new YUSD issuance)\n    uint public lastFeeOperationTime;\n\n    mapping (address =&gt; Trove) Troves;\n\n    // uint public totalStakes;\n    mapping (address =&gt; uint) public totalStakes;\n\n    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation\n    mapping (address =&gt; uint) public totalStakesSnapshot;\n\n    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\n    mapping (address =&gt; uint) public totalCollateralSnapshot;\n\n    /\n    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has \n    * its own L_Coll and L_YUSDDebt.\n    * During its lifetime, each stake earns:\n    \n    * A Collateral gain of ( stake * [L_Coll[coll] - L_Collcoll] )\n    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )\n    \n    * Where L_Collcoll and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made\n    /\n    mapping (address =&gt; uint) private L_Coll;\n    mapping (address =&gt; uint) public L_YUSDDebt;\n\n    // Map addresses with active troves to their RewardSnapshot\n    mapping (address =&gt; RewardSnapshot) rewardSnapshots;\n\n    // Object containing the reward snapshots for a given active trove\n    struct RewardSnapshot {\n        mapping(address =&gt; uint) CollRewards;\n        mapping(address =&gt; uint) YUSDDebts;\n    }\n\n    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\n    address[] private TroveOwners;\n\n    // Error trackers for the trove redistribution calculation\n    mapping (address =&gt; uint) public lastCollError_Redistribution;\n    mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;\n\n    /\n    * --- Variable container structs for liquidations ---\n    *\n    * These structs are used to hold, return and assign variables inside the liquidation functions,\n    * in order to avoid the error: "CompilerError: Stack too deep".\n    /\n\n    // --- Events ---\n\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(address token, uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _unix);\n\n    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, \n        address[] totalCollTokens, uint[] totalCollAmounts,\n        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);\n\n    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);\n    event TroveSnapshotsUpdated(uint _unix);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _yusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _yetiTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress,\n        address _troveManagerRedemptionsAddress,\n        address _troveManagerLiquidationsAddress\n    )\n    external\n    override\n    onlyOwner\n    {\n        checkContract(_borrowerOperationsAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yetiTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n        checkContract(_troveManagerRedemptionsAddress);\n        checkContract(_troveManagerLiquidationsAddress);\n\n        borrowerOperationsAddress = _borrowerOperationsAddress;\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        yusdTokenContract = IYUSDToken(_yusdTokenAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yetiTokenContract = IYETIToken(_yetiTokenAddress);\n        sYETIContract = ISYETI(_sYETIAddress);\n\n        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;\n        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;\n        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);\n        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);\n        _renounceOwnership();\n    }\n\n    // --- Getters ---\n\n    function getTroveOwnersCount() external view override returns (uint) {\n        return TroveOwners.length;\n    }\n\n    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {\n        return TroveOwners[_index];\n    }\n\n    // --- Trove Liquidation functions ---\n\n    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.\n    function liquidate(address _borrower) external override nonReentrant {\n        _requireTroveIsActive(_borrower);\n\n        address[] memory borrowers = new address;\n        borrowers[0] = _borrower;\n        // calls this.batchLiquidateTroves so nonReentrant works correctly\n        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);\n    }\n\n    /\n    * Attempt to liquidate a custom list of troves provided by the caller.\n    /\n    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {\n        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);\n    }\n\n    // --- Liquidation helper functions ---\n\n    /\n    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where\n    * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in\n    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool\n    /\n    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        collSurplusPool.accountSurplus(_account, _tokens, _amounts);\n    }\n\n    // Move a Trove\'s pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\n    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {\n        _requireCallerIsTML();\n        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);\n    }\n\n    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {\n        _defaultPool.decreaseYUSDDebt(_YUSD);\n        _activePool.increaseYUSDDebt(_YUSD);\n        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);\n    }\n\n    // Update position of given trove\n    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {\n        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);\n\n        newColls memory troveColl;\n        troveColl.tokens = tokens;\n        troveColl.amounts = amounts;\n\n        uint ICR = _getICRColls(troveColl, debt);\n        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);\n    }\n\n    // Update position for a set of troves using latest price data. This can be called by anyone.\n    // Yeti Finance will also be running a bot to assist with keeping the list from becoming\n    // too stale.\n    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {\n        uint lowerHintsLen = _lowerHints.length;\n        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");\n        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");\n\n        for (uint256 i; i &lt; lowerHintsLen; ++i) {\n            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);\n        }\n    }\n\n    / Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption\n    * request.  Applies pending rewards to a Trove before reducing its debt and coll.\n    \n    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by\n    * splitting the total _amount in appropriate chunks and calling the function multiple times.\n    \n    * Param _maxIterations can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to\n    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”\n    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode\n    * costs can vary.\n    \n    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.\n    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.\n    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position\n    * in the sortedTroves list along with the ICR value that the hint was found for.\n    \n    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it\n    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the\n    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt\n    * to redeem later.\n    /\n    function redeemCollateral(\n        uint _YUSDamount,\n        uint _YUSDMaxFee,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintICR,\n        uint _maxIterations\n    )\n    external\n    override\n    nonReentrant\n    {\n        troveManagerRedemptions.redeemCollateral(\n            _YUSDamount,\n            _YUSDMaxFee,\n            _firstRedemptionHint,\n            _upperPartialRedemptionHint,\n            _lowerPartialRedemptionHint,\n            _partialRedemptionHintICR,\n            _maxIterations,\n            msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    // Return the current collateral ratio (ICR) of a given Trove.\n    // Takes a trove\'s pending coll and debt rewards from redistributions into account.\n    function getCurrentICR(address _borrower) external view override returns (uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n\n        uint ICR = _getICRColls(colls, currentYUSDDebt);\n        return ICR;\n    }\n\n    // Gets current trove state as colls and debt. \n    function _getCurrentTroveState(address _borrower) internal view\n    returns (newColls memory colls, uint YUSDdebt) {\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        \n        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function applyPendingRewards(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        return _applyPendingRewards(activePool, defaultPool, _borrower);\n    }\n\n    // Add the borrowers\'s coll and debt rewards earned from redistributions, to their Trove\n    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {\n        if (hasPendingRewards(_borrower)) {\n            _requireTroveIsActive(_borrower);\n\n            // Compute pending collateral rewards\n            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n\n            // Apply pending rewards to trove\'s state\n            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);\n            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);\n\n            _updateTroveRewardSnapshots(_borrower);\n\n            // Transfer from DefaultPool to ActivePool\n            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);\n\n            emit TroveUpdated(\n                _borrower,\n                Troves[_borrower].debt,\n                Troves[_borrower].colls.tokens,\n                Troves[_borrower].colls.amounts,\n                TroveManagerOperation.applyPendingRewards\n            );\n        }\n    }\n\n    // Update borrower\'s snapshots of L_Coll and L_YUSDDebt to reflect the current values\n    function updateTroveRewardSnapshots(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        _updateTroveRewardSnapshots(_borrower);\n    }\n\n    function _updateTroveRewardSnapshots(address _borrower) internal {\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address asset = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];\n            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];\n        }\n        emit TroveSnapshotsUpdated(block.timestamp);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;\n    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {\n        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);\n        return (pendingCollRewards.tokens, pendingCollRewards.amounts);\n    }\n\n    // Get the borrower\'s pending accumulated Coll rewards, earned by their stake\n    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();\n    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {\n        if (Troves[_borrower].status != Status.active) {\n            newColls memory emptyColls;\n            return emptyColls;\n        }\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        pendingCollRewards.amounts = new uint;\n        pendingCollRewards.tokens = allColls;\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];\n            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);\n            if ( rewardPerUnitStaked == 0) {\n                pendingCollRewards.amounts[i] = 0;\n                continue; }\n\n            uint stake = Troves[_borrower].stakes[coll];\n            uint dec = IERC20(coll).decimals();\n            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);\n            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here\n        }\n    }\n\n    // Get the borrower\'s pending accumulated YUSD reward, earned by their stake\n    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {\n        if (Troves[_borrower].status != Status.active) {\n            return 0;\n        }\n        address[] memory allColls = whitelist.getValidCollateral();\n\n        uint256 allCollsLen = allColls.length;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            address coll = allColls[i];\n            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];\n            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);\n            if ( rewardPerUnitStaked == 0) { continue; }\n\n            uint stake =  Troves[_borrower].stakes[coll];\n\n            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);\n            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);\n        }\n    }\n\n    function hasPendingRewards(address _borrower) public view override returns (bool) {\n        /\n        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:\n        * this indicates that rewards have occured since the snapshot was made, and the user therefore has\n        * pending rewards\n        /\n        if (Troves[_borrower].status != Status.active) {return false;}\n        address[] memory assets =  Troves[_borrower].colls.tokens;\n        uint256 assetsLen = assets.length;\n        for (uint256 i; i &lt; assetsLen; ++i) {\n            address token = assets[i];\n            if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns\n    function getEntireDebtAndColls(\n        address _borrower\n    )\n    public\n    view override\n    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)\n    {\n        uint debt = Troves[_borrower].debt;\n        newColls memory colls = Troves[_borrower].colls;\n\n        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);\n        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);\n\n        debt = debt.add(pendingYUSDDebtReward);\n\n        // add in pending rewards to colls\n        colls = _sumColls(colls, pendingCollReward);\n\n        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);\n    }\n\n    // Borrower operations remove stake sum. \n    function removeStake(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _removeStake(_borrower);\n    }\n\n    // Remove borrower\'s stake from the totalStakes sum, and set their stake to 0\n    function _removeStake(address _borrower) internal {\n        address[] memory borrowerColls = Troves[_borrower].colls.tokens;\n        uint256 borrowerCollsLen = borrowerColls.length;\n        for (uint256 i; i &lt; borrowerCollsLen; ++i) {\n            address coll = borrowerColls[i];\n            uint stake = Troves[_borrower].stakes[coll];\n            totalStakes[coll] = totalStakes[coll].sub(stake);\n            Troves[_borrower].stakes[coll] = 0;\n        }\n    }\n\n    // Update borrower\'s stake based on their latest collateral value\n    // computed at time function is called based on current price of collateral\n    function updateStakeAndTotalStakes(address _borrower) external override {\n        _requireCallerIsBOorTMR();\n        _updateStakeAndTotalStakes(_borrower);\n    }\n\n    function _updateStakeAndTotalStakes(address _borrower) internal {\n        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;\n        for (uint256 i; i &lt; troveOwnerLen; ++i) {\n            address token = Troves[_borrower].colls.tokens[i];\n            uint amount = Troves[_borrower].colls.amounts[i];\n\n            uint newStake = _computeNewStake(token, amount);\n            uint oldStake = Troves[_borrower].stakes[token];\n\n            Troves[_borrower].stakes[token] = newStake;\n            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);\n\n            emit TotalStakesUpdated(token, totalStakes[token]);\n        }\n    }\n\n    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\n    function _computeNewStake(address token, uint _coll) internal view returns (uint) {\n        uint stake;\n        if (totalCollateralSnapshot[token] == 0) {\n            stake = _coll;\n        } else {\n            /\n            * The following assert() holds true because:\n            * - The system always contains &gt;= 1 trove\n            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,\n            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.\n            /\n            require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");\n            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);\n        }\n        return stake;\n    }\n\n    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        require(tokensLen == _amounts.length, "TM: len tokens amounts");\n        if (_debt == 0) { return; }\n        /\n        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"\n        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:\n        \n        * 1) Form numerators which compensate for the floor division errors that occurred the last time this\n        * function was called.\n        * 2) Calculate "per-unit-staked" ratios.\n        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\n        * 4) Store these errors for use in the next correction when this function is called.\n        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.\n        /\n        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms\n\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            uint amount = _amounts[i];\n            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt\n            uint collateralVC = whitelist.getValueVC(token, amount);\n            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);\n            uint dec = IERC20(token).decimals();\n            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);\n            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);\n            if (totalStakes[token] != 0) {\n                // Get the per-unit-staked terms\n                uint256 thisTotalStakes = totalStakes[token];\n                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);\n                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));\n\n                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));\n                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));\n\n                // Add per-unit-staked terms to the running totals\n                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);\n                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);\n                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);\n            }\n        }\n\n        // Transfer coll and debt from ActivePool to DefaultPool\n        _activePool.decreaseYUSDDebt(_debt);\n        _defaultPool.increaseYUSDDebt(_debt);\n        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);\n    }\n\n    function closeTrove(address _borrower) external override {\n        _requireCallerIsBorrowerOperations();\n        return _closeTrove(_borrower, Status.closedByOwner);\n    }\n\n    function closeTroveLiquidation(address _borrower) external override {\n        _requireCallerIsTML();\n        return _closeTrove(_borrower, Status.closedByLiquidation);\n    }\n\n    function closeTroveRedemption(address _borrower) external override {\n        _requireCallerIsTMR();\n        return _closeTrove(_borrower, Status.closedByRedemption);\n    }\n\n    function _closeTrove(address _borrower, Status closedStatus) internal {\n        require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");\n\n        uint TroveOwnersArrayLength = TroveOwners.length;\n        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);\n        newColls memory emptyColls;\n\n        Troves[_borrower].status = closedStatus;\n        Troves[_borrower].colls = emptyColls;\n        Troves[_borrower].debt = 0;\n\n        address[] memory allColls = whitelist.getValidCollateral();\n        uint allCollsLen = allColls.length;\n        address thisAllColls;\n        for (uint256 i; i &lt; allCollsLen; ++i) {\n            thisAllColls = allColls[i];\n            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;\n            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;\n        }\n\n        _removeTroveOwner(_borrower, TroveOwnersArrayLength);\n        sortedTroves.remove(_borrower);\n    }\n\n    /\n    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.\n    * Used in a liquidation sequence.\n    \n    * The calculation excludes a portion of collateral that is in the ActivePool:\n    \n    * the total Coll gas compensation from the liquidation sequence\n    \n    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.\n    /\n    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsTML();\n        uint256 tokensLen = _tokens.length;\n        for (uint256 i; i &lt; tokensLen; ++i) {\n            address token = _tokens[i];\n            totalStakesSnapshot[token] = totalStakes[token];\n\n            uint _tokenRemainder = _amounts[i];\n            uint activeColl = _activePool.getCollateral(token);\n            uint liquidatedColl = defaultPool.getCollateral(token);\n            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);\n        }\n        emit SystemSnapshotsUpdated(block.timestamp);\n    }\n\n    // Push the owner\'s address to the Trove owners list, and record the corresponding array index on the Trove struct\n    function addTroveOwnerToArray(address _borrower) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        return _addTroveOwnerToArray(_borrower);\n    }\n\n    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {\n        / Max array size is 2128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD\n        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). /\n        // Push the Troveowner to the array\n        TroveOwners.push(_borrower);\n\n        // Record the index of the new Troveowner on their Trove struct\n        index = uint128(TroveOwners.length.sub(1));\n        Troves[_borrower].arrayIndex = index;\n    }\n\n    /\n    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner \'B\' does the following:\n    * [A B C D E] =&gt; [A E C D], and updates E\'s Trove struct to point to its new array index.\n    /\n    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {\n        Status troveStatus = Troves[_borrower].status;\n        // It’s set in caller function _closeTrove\n        require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");\n\n        uint128 index = Troves[_borrower].arrayIndex;\n        uint length = TroveOwnersArrayLength;\n        uint idxLast = length.sub(1);\n\n        require(index &lt;= idxLast, "TM: index must be &gt; last index");\n\n        address addressToMove = TroveOwners[idxLast];\n\n        TroveOwners[index] = addressToMove;\n        Troves[addressToMove].arrayIndex = index;\n        emit TroveIndexUpdated(addressToMove, index);\n\n        TroveOwners.pop();\n    }\n\n    // --- Recovery Mode and TCR functions ---\n\n    function getTCR() external view override returns (uint) {\n        return _getTCR();\n    }\n\n    function checkRecoveryMode() external view override returns (bool) {\n        return _checkRecoveryMode();\n    }\n\n\n    // --- Redemption fee functions ---\n\n    function updateBaseRate(uint newBaseRate) external override {\n        _requireCallerIsTMR();\n        require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");\n        baseRate = newBaseRate;\n        emit BaseRateUpdated(newBaseRate);\n        _updateLastFeeOpTime();\n    }\n\n    function getRedemptionRate() public view override returns (uint) {\n        return _calcRedemptionRate(baseRate);\n    }\n\n    function getRedemptionRateWithDecay() public view override returns (uint) {\n        return _calcRedemptionRate(calcDecayedBaseRate());\n    }\n\n    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            REDEMPTION_FEE_FLOOR.add(_baseRate),\n            DECIMAL_PRECISION // cap at a maximum of 100%\n        );\n    }\n\n    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {\n        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);\n    }\n\n    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {\n        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);\n    }\n\n    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {\n        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);\n        require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");\n        return redemptionFee;\n    }\n\n\n    // --- Borrowing fee functions ---\n\n    function getBorrowingRate() public view override returns (uint) {\n        return _calcBorrowingRate(baseRate);\n    }\n\n    function getBorrowingRateWithDecay() public view override returns (uint) {\n        return _calcBorrowingRate(calcDecayedBaseRate());\n    }\n\n    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {\n        return LiquityMath._min(\n            BORROWING_FEE_FLOOR.add(_baseRate),\n            MAX_BORROWING_FEE\n        );\n    }\n\n    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);\n    }\n\n    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {\n        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);\n    }\n\n    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {\n        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);\n    }\n\n\n    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.\n    function decayBaseRateFromBorrowing() external override {\n        _requireCallerIsBorrowerOperations();\n\n        uint decayedBaseRate = calcDecayedBaseRate();\n        require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0\n\n        baseRate = decayedBaseRate;\n        emit BaseRateUpdated(decayedBaseRate);\n\n        _updateLastFeeOpTime();\n    }\n\n\n    // --- Internal fee functions ---\n\n    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.\n    function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {\n            lastFeeOperationTime = block.timestamp;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n\n    function calcDecayedBaseRate() public view override returns (uint) {\n        uint minutesPassed = _minutesPassedSinceLastFeeOp();\n        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\n\n        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);\n    }\n\n    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {\n        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);\n    }\n\n    // --- \'require\' wrapper functions ---\n\n    function _requireCallerIsBorrowerOperations() internal view {\n        if (msg.sender != borrowerOperationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsBOorTMR() internal view {\n        if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTMR() internal view {\n        if (msg.sender != troveManagerRedemptionsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _requireCallerIsTML() internal view {\n        if (msg.sender != troveManagerLiquidationsAddress) {\n            _revertWrongFuncCaller();\n        }\n    }\n\n    function _revertWrongFuncCaller() internal view{\n        revert("TM: External caller not allowed");\n    }\n\n    function _requireTroveIsActive(address _borrower) internal view {\n        require(Troves[_borrower].status == Status.active, "TM: trove must exist");\n    }\n\n    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {\n        require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove");\n    }\n\n    // --- Trove property getters ---\n\n    function getTroveStatus(address _borrower) external view override returns (uint) {\n        return uint(Troves[_borrower].status);\n    }\n\n    function isTroveActive(address _borrower) external view override returns (bool) {\n        return Troves[_borrower].status == Status.active;\n    }\n\n    function getTroveStake(address _borrower, address _token) external view override returns (uint) {\n        return Troves[_borrower].stakes[_token];\n    }\n\n    function getTroveDebt(address _borrower) external view override returns (uint) {\n        return Troves[_borrower].debt;\n    }\n\n    // -- Trove Manager State Variable Getters -- \n\n    function getTotalStake(address _token) external view override returns (uint) {\n        return totalStakes[_token];\n    }\n\n    function getL_Coll(address _token) external view override returns (uint) {\n        return L_Coll[_token];\n    }\n\n    function getL_YUSD(address _token) external view override returns (uint) {\n        return L_YUSDDebt[_token];\n    }\n\n    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].CollRewards[_token];\n    }\n\n    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {\n        return rewardSnapshots[_borrower].YUSDDebts[_token];\n    }\n\n    // recomputes VC given current prices and returns it\n    function getTroveVC(address _borrower) external view override returns (uint) {\n        return _getVCColls(Troves[_borrower].colls);\n    }\n\n    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {\n        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);\n    }\n\n    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {\n        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);\n        return (colls.tokens, colls.amounts, currentYUSDDebt);\n    }\n\n    // --- Called by TroveManagerRedemptions Only ---\n\n\n    function updateTroveDebt(address _borrower, uint debt) external override {\n        _requireCallerIsTMR();\n        Troves[_borrower].debt = debt;\n    }\n\n    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {\n        _requireCallerIsTMR();\n        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);\n    }\n\n    function removeStakeTMR(address _borrower) external override {\n        _requireCallerIsTMR();\n        _removeStake(_borrower);\n    }\n\n    // --- Called by TroverManagerLiquidations Only ---\n\n    function removeStakeTLR(address _borrower) external override {\n        _requireCallerIsTML();\n        _removeStake(_borrower);\n    }\n\n    // --- Trove property setters, called by BorrowerOperations ---\n\n    function setTroveStatus(address _borrower, uint _num) external override {\n        _requireCallerIsBorrowerOperations();\n        Troves[_borrower].status = Status(_num);\n    }\n\n    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {\n        _requireCallerIsBorrowerOperations();\n        require(_tokens.length == _amounts.length, "TM: length mismatch");\n        Troves[_borrower].colls.tokens = _tokens;\n        Troves[_borrower].colls.amounts = _amounts;\n    }\n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {\n        _requireCallerIsBorrowerOperations();\n        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);\n        Troves[_borrower].debt = newDebt;\n        return newDebt;\n    }\n\n    // --- contract getters ---\n\n    function stabilityPool() external view override returns (IStabilityPool) {\n        return stabilityPoolContract;\n    }\n\n    function yusdToken() external view override returns (IYUSDToken) {\n        return yusdTokenContract;\n    }\n\n    function yetiToken() external view override returns (IYETIToken) {\n        return yetiTokenContract;\n    }\n\n    function sYETI() external view override returns (ISYETI) {\n        return sYETIContract;\n    }\n }', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-23-08 11:03:22 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: UNLICENSED pragma solidity 0.6.11; import "./Interfaces/ITroveManager.sol"; import "./Interfaces/IStabilityPool.sol"; import "./Interfaces/ICollSurplusPool.sol"; import "./Interfaces/IYUSDToken.sol"; import "./Interfaces/ISortedTroves.sol"; import "./Interfaces/IYETIToken.sol"; import "./Interfaces/ISYETI.sol"; import "./Interfaces/IWhitelist.sol"; import "./Interfaces/ITroveManagerLiquidations.sol"; import "./Interfaces/ITroveManagerRedemptions.sol"; import "./Interfaces/IERC20.sol"; import "./Dependencies/TroveManagerBase.sol"; import "./Dependencies/ReentrancyGuard.sol"; /*   * Trove Manager is the contract which deals with the state of a user's trove. It has all the   * external functions for liquidations, redemptions, as well as functions called by   * BorrowerOperations function calls.   / contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard { address internal borrowerOperationsAddress;  IStabilityPool internal stabilityPoolContract;  ITroveManager internal troveManager;  IYUSDToken internal yusdTokenContract;  IYETIToken internal yetiTokenContract;  ISYETI internal sYETIContract;  ITroveManagerRedemptions internal troveManagerRedemptions;  ITroveManagerLiquidations internal troveManagerLiquidations;  address internal gasPoolAddress; address internal troveManagerRedemptionsAddress; address internal troveManagerLiquidationsAddress;  ISortedTroves internal sortedTroves;  ICollSurplusPool internal collSurplusPool;  bytes32 constant public NAME = "TroveManager";  // --- Data structures ---  uint constant internal SECONDS_IN_ONE_MINUTE = 60;  /*  * Half-life of 12h. 12h = 720 min  * (1/2) = d^720 =&gt; d = (1/2)^(1/720)  */ uint constant public MINUTE_DECAY_FACTOR = 999037758833783000; uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%  // During bootsrap period redemptions are not allowed uint constant public BOOTSTRAP_PERIOD = 14 days;  uint public baseRate;  // The timestamp of the latest fee operation (redemption or new YUSD issuance) uint public lastFeeOperationTime;  mapping (address =&gt; Trove) Troves;  // uint public totalStakes; mapping (address =&gt; uint) public totalStakes;  // Snapshot of the value of totalStakes, taken immediately after the latest liquidation mapping (address =&gt; uint) public totalStakesSnapshot;  // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation. mapping (address =&gt; uint) public totalCollateralSnapshot;  /* * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has  * its own L_Coll and L_YUSDDebt. * During its lifetime, each stake earns: * * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] ) * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] ) * * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made */ mapping (address =&gt; uint) private L_Coll; mapping (address =&gt; uint) public L_YUSDDebt;  // Map addresses with active troves to their RewardSnapshot mapping (address =&gt; RewardSnapshot) rewardSnapshots;  // Object containing the reward snapshots for a given active trove struct RewardSnapshot {     mapping(address =&gt; uint) CollRewards;     mapping(address =&gt; uint) YUSDDebts; }  // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion address[] private TroveOwners;  // Error trackers for the trove redistribution calculation mapping (address =&gt; uint) public lastCollError_Redistribution; mapping (address =&gt; uint) public lastYUSDDebtError_Redistribution;  /* * --- Variable container structs for liquidations --- * * These structs are used to hold, return and assign variables inside the liquidation functions, * in order to avoid the error: "CompilerError: Stack too deep". **/  // --- Events ---  event BaseRateUpdated(uint _baseRate); event LastFeeOpTimeUpdated(uint _lastFeeOpTime); event TotalStakesUpdated(address token, uint _newTotalStakes); event SystemSnapshotsUpdated(uint _unix);  event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation,      address[] totalCollTokens, uint[] totalCollAmounts,     address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);  event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt); event TroveSnapshotsUpdated(uint _unix); event TroveIndexUpdated(address _borrower, uint _newIndex); event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);  function setAddresses(     address _borrowerOperationsAddress,     address _activePoolAddress,     address _defaultPoolAddress,     address _stabilityPoolAddress,     address _gasPoolAddress,     address _collSurplusPoolAddress,     address _yusdTokenAddress,     address _sortedTrovesAddress,     address _yetiTokenAddress,     address _sYETIAddress,     address _whitelistAddress,     address _troveManagerRedemptionsAddress,     address _troveManagerLiquidationsAddress ) external override onlyOwner {     checkContract(_borrowerOperationsAddress);     checkContract(_activePoolAddress);     checkContract(_defaultPoolAddress);     checkContract(_stabilityPoolAddress);     checkContract(_gasPoolAddress);     checkContract(_collSurplusPoolAddress);     checkContract(_yusdTokenAddress);     checkContract(_sortedTrovesAddress);     checkContract(_yetiTokenAddress);     checkContract(_sYETIAddress);     checkContract(_whitelistAddress);     checkContract(_troveManagerRedemptionsAddress);     checkContract(_troveManagerLiquidationsAddress);      borrowerOperationsAddress = _borrowerOperationsAddress;     activePool = IActivePool(_activePoolAddress);     defaultPool = IDefaultPool(_defaultPoolAddress);     stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);     whitelist = IWhitelist(_whitelistAddress);     gasPoolAddress = _gasPoolAddress;     collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);     yusdTokenContract = IYUSDToken(_yusdTokenAddress);     sortedTroves = ISortedTroves(_sortedTrovesAddress);     yetiTokenContract = IYETIToken(_yetiTokenAddress);     sYETIContract = ISYETI(_sYETIAddress);      troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;     troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;     troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);     troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);     _renounceOwnership(); }  // --- Getters ---  function getTroveOwnersCount() external view override returns (uint) {     return TroveOwners.length; }  function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {     return TroveOwners[_index]; }  // --- Trove Liquidation functions ---  // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio. function liquidate(address _borrower) external override nonReentrant {     _requireTroveIsActive(_borrower);      address[] memory borrowers = new address[](1);     borrowers[0] = _borrower;     // calls this.batchLiquidateTroves so nonReentrant works correctly     troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender); }  /* * Attempt to liquidate a custom list of troves provided by the caller. */ function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {     troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator); }  // --- Liquidation helper functions ---  /* * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where * the trove has TCR &gt; ICR &gt;= MCR. In this case, the liquidation occurs. 110% of the debt in * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool */ function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     collSurplusPool.accountSurplus(_account, _tokens, _amounts); }  // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {     _requireCallerIsTML();     _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower); }  function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {     _defaultPool.decreaseYUSDDebt(_YUSD);     _activePool.increaseYUSDDebt(_YUSD);     _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower); }  // Update position of given trove function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {     (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);      newColls memory troveColl;     troveColl.tokens = tokens;     troveColl.amounts = amounts;      uint ICR = _getICRColls(troveColl, debt);     sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint); }  // Update position for a set of troves using latest price data. This can be called by anyone. // Yeti Finance will also be running a bot to assist with keeping the list from becoming // too stale. function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {     uint lowerHintsLen = _lowerHints.length;     require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");     require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");      for (uint256 i; i &lt; lowerHintsLen; ++i) {         _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);     } }  /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption * request.  Applies pending rewards to a Trove before reducing its debt and coll. * * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by * splitting the total _amount in appropriate chunks and calling the function multiple times. * * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology” * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode * costs can vary. * * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed. * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint. * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position * in the sortedTroves list along with the ICR value that the hint was found for. * * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt * to redeem later. */ function redeemCollateral(     uint _YUSDamount,     uint _YUSDMaxFee,     address _firstRedemptionHint,     address _upperPartialRedemptionHint,     address _lowerPartialRedemptionHint,     uint _partialRedemptionHintICR,     uint _maxIterations ) external override nonReentrant {     troveManagerRedemptions.redeemCollateral(         _YUSDamount,         _YUSDMaxFee,         _firstRedemptionHint,         _upperPartialRedemptionHint,         _lowerPartialRedemptionHint,         _partialRedemptionHintICR,         _maxIterations,         msg.sender); }  // --- Helper functions ---  // Return the current collateral ratio (ICR) of a given Trove. // Takes a trove's pending coll and debt rewards from redistributions into account. function getCurrentICR(address _borrower) external view override returns (uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);      uint ICR = _getICRColls(colls, currentYUSDDebt);     return ICR; }  // Gets current trove state as colls and debt.  function _getCurrentTroveState(address _borrower) internal view returns (newColls memory colls, uint YUSDdebt) {     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);     uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);      YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);     colls = _sumColls(Troves[_borrower].colls, pendingCollReward); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function applyPendingRewards(address _borrower) external override {     _requireCallerIsBOorTMR();     return _applyPendingRewards(activePool, defaultPool, _borrower); }  // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {     if (hasPendingRewards(_borrower)) {         _requireTroveIsActive(_borrower);          // Compute pending collateral rewards         newColls memory pendingCollReward = _getPendingCollRewards(_borrower);         uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);          // Apply pending rewards to trove's state         Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);         Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);          _updateTroveRewardSnapshots(_borrower);          // Transfer from DefaultPool to ActivePool         _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);          emit TroveUpdated(             _borrower,             Troves[_borrower].debt,             Troves[_borrower].colls.tokens,             Troves[_borrower].colls.amounts,             TroveManagerOperation.applyPendingRewards         );     } }  // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values function updateTroveRewardSnapshots(address _borrower) external override {     _requireCallerIsBorrowerOperations();     _updateTroveRewardSnapshots(_borrower); }  function _updateTroveRewardSnapshots(address _borrower) internal {     address[] memory allColls = whitelist.getValidCollateral();     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address asset = allColls[i];         rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];         rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];     }     emit TroveSnapshotsUpdated(block.timestamp); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // Returned tokens and amounts are the length of whitelist.getValidCollateral();; function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {     newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);     return (pendingCollRewards.tokens, pendingCollRewards.amounts); }  // Get the borrower's pending accumulated Coll rewards, earned by their stake // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral(); function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {     if (Troves[_borrower].status != Status.active) {         newColls memory emptyColls;         return emptyColls;     }      address[] memory allColls = whitelist.getValidCollateral();     pendingCollRewards.amounts = new uint[](allColls.length);     pendingCollRewards.tokens = allColls;     uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];         uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);         if ( rewardPerUnitStaked == 0) {             pendingCollRewards.amounts[i] = 0;             continue; }          uint stake = Troves[_borrower].stakes[coll];         uint dec = IERC20(coll).decimals();         uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);         pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here     } }  // Get the borrower's pending accumulated YUSD reward, earned by their stake function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {     if (Troves[_borrower].status != Status.active) {         return 0;     }     address[] memory allColls = whitelist.getValidCollateral();      uint256 allCollsLen = allColls.length;     for (uint256 i; i &lt; allCollsLen; ++i) {         address coll = allColls[i];         uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];         uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);         if ( rewardPerUnitStaked == 0) { continue; }          uint stake =  Troves[_borrower].stakes[coll];          uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);         pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);     } }  function hasPendingRewards(address _borrower) public view override returns (bool) {     /*     * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:     * this indicates that rewards have occured since the snapshot was made, and the user therefore has     * pending rewards     */     if (Troves[_borrower].status != Status.active) {return false;}     address[] memory assets =  Troves[_borrower].colls.tokens;     uint256 assetsLen = assets.length;     for (uint256 i; i &lt; assetsLen; ++i) {         address token = assets[i];         if (rewardSnapshots[_borrower].CollRewards[token] &lt; L_Coll[token]) {             return true;         }     }     return false; }  // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns function getEntireDebtAndColls(     address _borrower ) public view override returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory) {     uint debt = Troves[_borrower].debt;     newColls memory colls = Troves[_borrower].colls;      uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);     newColls memory pendingCollReward = _getPendingCollRewards(_borrower);      debt = debt.add(pendingYUSDDebtReward);      // add in pending rewards to colls     colls = _sumColls(colls, pendingCollReward);      return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts); }  // Borrower operations remove stake sum.  function removeStake(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _removeStake(_borrower); }  // Remove borrower's stake from the totalStakes sum, and set their stake to 0 function _removeStake(address _borrower) internal {     address[] memory borrowerColls = Troves[_borrower].colls.tokens;     uint256 borrowerCollsLen = borrowerColls.length;     for (uint256 i; i &lt; borrowerCollsLen; ++i) {         address coll = borrowerColls[i];         uint stake = Troves[_borrower].stakes[coll];         totalStakes[coll] = totalStakes[coll].sub(stake);         Troves[_borrower].stakes[coll] = 0;     } }  // Update borrower's stake based on their latest collateral value // computed at time function is called based on current price of collateral function updateStakeAndTotalStakes(address _borrower) external override {     _requireCallerIsBOorTMR();     _updateStakeAndTotalStakes(_borrower); }  function _updateStakeAndTotalStakes(address _borrower) internal {     uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;     for (uint256 i; i &lt; troveOwnerLen; ++i) {         address token = Troves[_borrower].colls.tokens[i];         uint amount = Troves[_borrower].colls.amounts[i];          uint newStake = _computeNewStake(token, amount);         uint oldStake = Troves[_borrower].stakes[token];          Troves[_borrower].stakes[token] = newStake;         totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);          emit TotalStakesUpdated(token, totalStakes[token]);     } }  // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation function _computeNewStake(address token, uint _coll) internal view returns (uint) {     uint stake;     if (totalCollateralSnapshot[token] == 0) {         stake = _coll;     } else {         /*         * The following assert() holds true because:         * - The system always contains &gt;= 1 trove         * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,         * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.         */         require(totalStakesSnapshot[token] != 0, "TM: stake must be &gt; 0");         stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);     }     return stake; }  function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     require(tokensLen == _amounts.length, "TM: len tokens amounts");     if (_debt == 0) { return; }     /*     * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"     * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:     *     * 1) Form numerators which compensate for the floor division errors that occurred the last time this     * function was called.     * 2) Calculate "per-unit-staked" ratios.     * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.     * 4) Store these errors for use in the next correction when this function is called.     * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.     */     uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms      for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         uint amount = _amounts[i];         // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt         uint collateralVC = whitelist.getValueVC(token, amount);         uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);         uint dec = IERC20(token).decimals();         uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);         uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);         if (totalStakes[token] != 0) {             // Get the per-unit-staked terms             uint256 thisTotalStakes = totalStakes[token];             uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);             uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));              lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));             lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));              // Add per-unit-staked terms to the running totals             L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);             L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);             emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);         }     }      // Transfer coll and debt from ActivePool to DefaultPool     _activePool.decreaseYUSDDebt(_debt);     _defaultPool.increaseYUSDDebt(_debt);     _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts); }  function closeTrove(address _borrower) external override {     _requireCallerIsBorrowerOperations();     return _closeTrove(_borrower, Status.closedByOwner); }  function closeTroveLiquidation(address _borrower) external override {     _requireCallerIsTML();     return _closeTrove(_borrower, Status.closedByLiquidation); }  function closeTroveRedemption(address _borrower) external override {     _requireCallerIsTMR();     return _closeTrove(_borrower, Status.closedByRedemption); }  function _closeTrove(address _borrower, Status closedStatus) internal {     require(closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active, "Status must be active and exists");      uint TroveOwnersArrayLength = TroveOwners.length;     _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);     newColls memory emptyColls;      Troves[_borrower].status = closedStatus;     Troves[_borrower].colls = emptyColls;     Troves[_borrower].debt = 0;      address[] memory allColls = whitelist.getValidCollateral();     uint allCollsLen = allColls.length;     address thisAllColls;     for (uint256 i; i &lt; allCollsLen; ++i) {         thisAllColls = allColls[i];         rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;         rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;     }      _removeTroveOwner(_borrower, TroveOwnersArrayLength);     sortedTroves.remove(_borrower); }  /* * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation. * Used in a liquidation sequence. * * The calculation excludes a portion of collateral that is in the ActivePool: * * the total Coll gas compensation from the liquidation sequence * * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence. */ function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsTML();     uint256 tokensLen = _tokens.length;     for (uint256 i; i &lt; tokensLen; ++i) {         address token = _tokens[i];         totalStakesSnapshot[token] = totalStakes[token];          uint _tokenRemainder = _amounts[i];         uint activeColl = _activePool.getCollateral(token);         uint liquidatedColl = defaultPool.getCollateral(token);         totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);     }     emit SystemSnapshotsUpdated(block.timestamp); }  // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct function addTroveOwnerToArray(address _borrower) external override returns (uint) {     _requireCallerIsBorrowerOperations();     return _addTroveOwnerToArray(_borrower); }  function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {     /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD     debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is &lt; 1e15 USD). */     // Push the Troveowner to the array     TroveOwners.push(_borrower);      // Record the index of the new Troveowner on their Trove struct     index = uint128(TroveOwners.length.sub(1));     Troves[_borrower].arrayIndex = index; }  /* * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following: * [A B C D E] =&gt; [A E C D], and updates E's Trove struct to point to its new array index. */ function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {     Status troveStatus = Troves[_borrower].status;     // It’s set in caller function `_closeTrove`     require(troveStatus != Status.nonExistent &amp;&amp; troveStatus != Status.active, "TM: trove !exists or !active");      uint128 index = Troves[_borrower].arrayIndex;     uint length = TroveOwnersArrayLength;     uint idxLast = length.sub(1);      require(index &lt;= idxLast, "TM: index must be &gt; last index");      address addressToMove = TroveOwners[idxLast];      TroveOwners[index] = addressToMove;     Troves[addressToMove].arrayIndex = index;     emit TroveIndexUpdated(addressToMove, index);      TroveOwners.pop(); }  // --- Recovery Mode and TCR functions ---  function getTCR() external view override returns (uint) {     return _getTCR(); }  function checkRecoveryMode() external view override returns (bool) {     return _checkRecoveryMode(); }   // --- Redemption fee functions ---  function updateBaseRate(uint newBaseRate) external override {     _requireCallerIsTMR();     require(newBaseRate != 0, "TM: newBaseRate must be &gt; 0");     baseRate = newBaseRate;     emit BaseRateUpdated(newBaseRate);     _updateLastFeeOpTime(); }  function getRedemptionRate() public view override returns (uint) {     return _calcRedemptionRate(baseRate); }  function getRedemptionRateWithDecay() public view override returns (uint) {     return _calcRedemptionRate(calcDecayedBaseRate()); }  function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         REDEMPTION_FEE_FLOOR.add(_baseRate),         DECIMAL_PRECISION // cap at a maximum of 100%     ); }  function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {     return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed); }  function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {     return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed); }  function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {     uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);     require(redemptionFee &lt; _YUSDRedeemed, "TM:Fee&gt;returned colls");     return redemptionFee; }   // --- Borrowing fee functions ---  function getBorrowingRate() public view override returns (uint) {     return _calcBorrowingRate(baseRate); }  function getBorrowingRateWithDecay() public view override returns (uint) {     return _calcBorrowingRate(calcDecayedBaseRate()); }  function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {     return LiquityMath._min(         BORROWING_FEE_FLOOR.add(_baseRate),         MAX_BORROWING_FEE     ); }  function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt); }  function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {     return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt); }  function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {     return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION); }   // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation. function decayBaseRateFromBorrowing() external override {     _requireCallerIsBorrowerOperations();      uint decayedBaseRate = calcDecayedBaseRate();     require(decayedBaseRate &lt;= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0      baseRate = decayedBaseRate;     emit BaseRateUpdated(decayedBaseRate);      _updateLastFeeOpTime(); }   // --- Internal fee functions ---  // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing. function _updateLastFeeOpTime() internal {     uint timePassed = block.timestamp.sub(lastFeeOperationTime);      if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {         lastFeeOperationTime = block.timestamp;         emit LastFeeOpTimeUpdated(block.timestamp);     } }  function calcDecayedBaseRate() public view override returns (uint) {     uint minutesPassed = _minutesPassedSinceLastFeeOp();     uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);      return baseRate.mul(decayFactor).div(DECIMAL_PRECISION); }  function _minutesPassedSinceLastFeeOp() internal view returns (uint) {     return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE); }  // --- 'require' wrapper functions ---  function _requireCallerIsBorrowerOperations() internal view {     if (msg.sender != borrowerOperationsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsBOorTMR() internal view {     if (msg.sender != borrowerOperationsAddress &amp;&amp; msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTMR() internal view {     if (msg.sender != troveManagerRedemptionsAddress) {         _revertWrongFuncCaller();     } }  function _requireCallerIsTML() internal view {     if (msg.sender != troveManagerLiquidationsAddress) {         _revertWrongFuncCaller();     } }  function _revertWrongFuncCaller() internal view{     revert("TM: External caller not allowed"); }  function _requireTroveIsActive(address _borrower) internal view {     require(Troves[_borrower].status == Status.active, "TM: trove must exist"); }  function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {     require (TroveOwnersArrayLength &gt; 1 &amp;&amp; sortedTroves.getSize() &gt; 1, "TM: last trove"); }  // --- Trove property getters ---  function getTroveStatus(address _borrower) external view override returns (uint) {     return uint(Troves[_borrower].status); }  function isTroveActive(address _borrower) external view override returns (bool) {     return Troves[_borrower].status == Status.active; }  function getTroveStake(address _borrower, address _token) external view override returns (uint) {     return Troves[_borrower].stakes[_token]; }  function getTroveDebt(address _borrower) external view override returns (uint) {     return Troves[_borrower].debt; }  // -- Trove Manager State Variable Getters --  function getTotalStake(address _token) external view override returns (uint) {     return totalStakes[_token]; }  function getL_Coll(address _token) external view override returns (uint) {     return L_Coll[_token]; }  function getL_YUSD(address _token) external view override returns (uint) {     return L_YUSDDebt[_token]; }  function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].CollRewards[_token]; }  function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {     return rewardSnapshots[_borrower].YUSDDebts[_token]; }  // recomputes VC given current prices and returns it function getTroveVC(address _borrower) external view override returns (uint) {     return _getVCColls(Troves[_borrower].colls); }  function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {     return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts); }  function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {     (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);     return (colls.tokens, colls.amounts, currentYUSDDebt); }  // --- Called by TroveManagerRedemptions Only ---   function updateTroveDebt(address _borrower, uint debt) external override {     _requireCallerIsTMR();     Troves[_borrower].debt = debt; }  function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {     _requireCallerIsTMR();     (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts); }  function removeStakeTMR(address _borrower) external override {     _requireCallerIsTMR();     _removeStake(_borrower); }  // --- Called by TroverManagerLiquidations Only ---  function removeStakeTLR(address _borrower) external override {     _requireCallerIsTML();     _removeStake(_borrower); }  // --- Trove property setters, called by BorrowerOperations ---  function setTroveStatus(address _borrower, uint _num) external override {     _requireCallerIsBorrowerOperations();     Troves[_borrower].status = Status(_num); }  function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {     _requireCallerIsBorrowerOperations();     require(_tokens.length == _amounts.length, "TM: length mismatch");     Troves[_borrower].colls.tokens = _tokens;     Troves[_borrower].colls.amounts = _amounts; }  function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.add(_debtIncrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {     _requireCallerIsBorrowerOperations();     uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);     Troves[_borrower].debt = newDebt;     return newDebt; }  // --- contract getters ---  function stabilityPool() external view override returns (IStabilityPool) {     return stabilityPoolContract; }  function yusdToken() external view override returns (IYUSDToken) {     return yusdTokenContract; }  function yetiToken() external view override returns (IYETIToken) {     return yetiTokenContract; }  function sYETI() external view override returns (ISYETI) {     return sYETIContract; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-23-08 11:03:22 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import "./Interfaces/ITroveManager.sol";
import "./Interfaces/IStabilityPool.sol";
import "./Interfaces/ICollSurplusPool.sol";
import "./Interfaces/IYUSDToken.sol";
import "./Interfaces/ISortedTroves.sol";
import "./Interfaces/IYETIToken.sol";
import "./Interfaces/ISYETI.sol";
import "./Interfaces/IWhitelist.sol";
import "./Interfaces/ITroveManagerLiquidations.sol";
import "./Interfaces/ITroveManagerRedemptions.sol";
import "./Interfaces/IERC20.sol";
import "./Dependencies/TroveManagerBase.sol";
import "./Dependencies/ReentrancyGuard.sol";


/** 
 * Trove Manager is the contract which deals with the state of a user's trove. It has all the 
 * external functions for liquidations, redemptions, as well as functions called by 
 * BorrowerOperations function calls. 
 */

contract TroveManager is TroveManagerBase, ITroveManager, ReentrancyGuard {
    
    address internal borrowerOperationsAddress;

    IStabilityPool internal stabilityPoolContract;

    ITroveManager internal troveManager;

    IYUSDToken internal yusdTokenContract;

    IYETIToken internal yetiTokenContract;

    ISYETI internal sYETIContract;

    ITroveManagerRedemptions internal troveManagerRedemptions;

    ITroveManagerLiquidations internal troveManagerLiquidations;

    address internal gasPoolAddress;
    address internal troveManagerRedemptionsAddress;
    address internal troveManagerLiquidationsAddress;

    ISortedTroves internal sortedTroves;

    ICollSurplusPool internal collSurplusPool;

    bytes32 constant public NAME = "TroveManager";

    // --- Data structures ---

    uint constant internal SECONDS_IN_ONE_MINUTE = 60;

    /*
     * Half-life of 12h. 12h = 720 min
     * (1/2) = d^720 => d = (1/2)^(1/720)
     */
    uint constant public MINUTE_DECAY_FACTOR = 999037758833783000;
    uint constant public MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%

    // During bootsrap period redemptions are not allowed
    uint constant public BOOTSTRAP_PERIOD = 14 days;

    uint public baseRate;

    // The timestamp of the latest fee operation (redemption or new YUSD issuance)
    uint public lastFeeOperationTime;

    mapping (address => Trove) Troves;

    // uint public totalStakes;
    mapping (address => uint) public totalStakes;

    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation
    mapping (address => uint) public totalStakesSnapshot;

    // Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.
    mapping (address => uint) public totalCollateralSnapshot;

    /*
    * L_Coll and L_YUSDDebt track the sums of accumulated liquidation rewards per unit staked. Each collateral type has 
    * its own L_Coll and L_YUSDDebt.
    * During its lifetime, each stake earns:
    *
    * A Collateral gain of ( stake * [L_Coll[coll] - L_Coll[coll](0)] )
    * A YUSDDebt increase  of ( stake * [L_YUSDDebt - L_YUSDDebt(0)] )
    *
    * Where L_Coll[coll](0) and L_YUSDDebt(0) are snapshots of L_Coll[coll] and L_YUSDDebt for the active Trove taken at the instant the stake was made
    */
    mapping (address => uint) private L_Coll;
    mapping (address => uint) public L_YUSDDebt;

    // Map addresses with active troves to their RewardSnapshot
    mapping (address => RewardSnapshot) rewardSnapshots;

    // Object containing the reward snapshots for a given active trove
    struct RewardSnapshot {
        mapping(address => uint) CollRewards;
        mapping(address => uint) YUSDDebts;
    }

    // Array of all active trove addresses - used to to compute an approximate hint off-chain, for the sorted list insertion
    address[] private TroveOwners;

    // Error trackers for the trove redistribution calculation
    mapping (address => uint) public lastCollError_Redistribution;
    mapping (address => uint) public lastYUSDDebtError_Redistribution;

    /*
    * --- Variable container structs for liquidations ---
    *
    * These structs are used to hold, return and assign variables inside the liquidation functions,
    * in order to avoid the error: "CompilerError: Stack too deep".
    **/

    // --- Events ---

    event BaseRateUpdated(uint _baseRate);
    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);
    event TotalStakesUpdated(address token, uint _newTotalStakes);
    event SystemSnapshotsUpdated(uint _unix);

    event Liquidation(uint liquidatedAmount, uint totalYUSDGasCompensation, 
        address[] totalCollTokens, uint[] totalCollAmounts,
        address[] totalCollGasCompTokens, uint[] totalCollGasCompAmounts);

    event LTermsUpdated(address _Coll_Address, uint _L_Coll, uint _L_YUSDDebt);
    event TroveSnapshotsUpdated(uint _unix);
    event TroveIndexUpdated(address _borrower, uint _newIndex);
    event TroveUpdated(address indexed _borrower, uint _debt, address[] _tokens, uint[] _amounts, TroveManagerOperation operation);

    function setAddresses(
        address _borrowerOperationsAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _yetiTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress,
        address _troveManagerRedemptionsAddress,
        address _troveManagerLiquidationsAddress
    )
    external
    override
    onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yetiTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        stabilityPoolContract = IStabilityPool(_stabilityPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        yusdTokenContract = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yetiTokenContract = IYETIToken(_yetiTokenAddress);
        sYETIContract = ISYETI(_sYETIAddress);

        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptions = ITroveManagerRedemptions(_troveManagerRedemptionsAddress);
        troveManagerLiquidations = ITroveManagerLiquidations(_troveManagerLiquidationsAddress);
        _renounceOwnership();
    }

    // --- Getters ---

    function getTroveOwnersCount() external view override returns (uint) {
        return TroveOwners.length;
    }

    function getTroveFromTroveOwnersArray(uint _index) external view override returns (address) {
        return TroveOwners[_index];
    }

    // --- Trove Liquidation functions ---

    // Single liquidation function. Closes the trove if its ICR is lower than the minimum collateral ratio.
    function liquidate(address _borrower) external override nonReentrant {
        _requireTroveIsActive(_borrower);

        address[] memory borrowers = new address[](1);
        borrowers[0] = _borrower;
        // calls this.batchLiquidateTroves so nonReentrant works correctly
        troveManagerLiquidations.batchLiquidateTroves(borrowers, msg.sender);
    }

    /*
    * Attempt to liquidate a custom list of troves provided by the caller.
    */
    function batchLiquidateTroves(address[] memory _troveArray, address _liquidator) external override nonReentrant {
        troveManagerLiquidations.batchLiquidateTroves(_troveArray, _liquidator);
    }

    // --- Liquidation helper functions ---

    /*
    * This function is called only by TroveManagerLiquidations.sol during a liquidation in recovery mode where
    * the trove has TCR > ICR >= MCR. In this case, the liquidation occurs. 110% of the debt in
    * collateral is sent to the stability pool and any surplus is sent to the collateral surplus pool
    */
    function collSurplusUpdate(address _account, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        collSurplusPool.accountSurplus(_account, _tokens, _amounts);
    }

    // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
    function movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) external override {
        _requireCallerIsTML();
        _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, _YUSD, _tokens, _amounts, _borrower);
    }

    function _movePendingTroveRewardsToActivePool(IActivePool _activePool, IDefaultPool _defaultPool, uint _YUSD, address[] memory _tokens, uint[] memory _amounts, address _borrower) internal {
        _defaultPool.decreaseYUSDDebt(_YUSD);
        _activePool.increaseYUSDDebt(_YUSD);
        _defaultPool.sendCollsToActivePool(_tokens, _amounts, _borrower);
    }

    // Update position of given trove
    function _updateTrove(address _borrower, address _lowerHint, address _upperHint) internal {
        (uint debt, address[] memory tokens, uint[] memory amounts, , , ) = getEntireDebtAndColls(_borrower);

        newColls memory troveColl;
        troveColl.tokens = tokens;
        troveColl.amounts = amounts;

        uint ICR = _getICRColls(troveColl, debt);
        sortedTroves.reInsert(_borrower, ICR, _lowerHint, _upperHint);
    }

    // Update position for a set of troves using latest price data. This can be called by anyone.
    // Yeti Finance will also be running a bot to assist with keeping the list from becoming
    // too stale.
    function updateTroves(address[] calldata _borrowers, address[] calldata _lowerHints, address[] calldata _upperHints) external {
        uint lowerHintsLen = _lowerHints.length;
        require(_borrowers.length == lowerHintsLen, "TM: borrowers length mismatch");
        require(lowerHintsLen == _upperHints.length, "TM: hints length mismatch");

        for (uint256 i; i < lowerHintsLen; ++i) {
            _updateTrove(_borrowers[i], _lowerHints[i], _upperHints[i]);
        }
    }

    /* Send _YUSDamount YUSD to the system and redeem the corresponding amount of collateral from as many Troves as are needed to fill the redemption
    * request.  Applies pending rewards to a Trove before reducing its debt and coll.
    *
    * Note that if _amount is very large, this function can run out of gas, specially if traversed troves are small. This can be easily avoided by
    * splitting the total _amount in appropriate chunks and calling the function multiple times.
    *
    * Param `_maxIterations` can also be provided, so the loop through Troves is capped (if it’s zero, it will be ignored).This makes it easier to
    * avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough, without needing to know the “topology”
    * of the trove list. It also avoids the need to set the cap in stone in the contract, nor doing gas calculations, as both gas price and opcode
    * costs can vary.
    *
    * All Troves that are redeemed from -- with the likely exception of the last one -- will end up with no debt left, therefore they will be closed.
    * If the last Trove does have some remaining debt, it has a finite ICR, and the reinsertion could be anywhere in the list, therefore it requires a hint.
    * A frontend should use getRedemptionHints() to calculate what the ICR of this Trove will be after redemption, and pass a hint for its position
    * in the sortedTroves list along with the ICR value that the hint was found for.
    *
    * If another transaction modifies the list between calling getRedemptionHints() and passing the hints to redeemCollateral(), it
    * is very likely that the last (partially) redeemed Trove would end up with a different ICR than what the hint is for. In this case the
    * redemption will stop after the last completely redeemed Trove and the sender will keep the remaining YUSD amount, which they can attempt
    * to redeem later.
    */
    function redeemCollateral(
        uint _YUSDamount,
        uint _YUSDMaxFee,
        address _firstRedemptionHint,
        address _upperPartialRedemptionHint,
        address _lowerPartialRedemptionHint,
        uint _partialRedemptionHintICR,
        uint _maxIterations
    )
    external
    override
    nonReentrant
    {
        troveManagerRedemptions.redeemCollateral(
            _YUSDamount,
            _YUSDMaxFee,
            _firstRedemptionHint,
            _upperPartialRedemptionHint,
            _lowerPartialRedemptionHint,
            _partialRedemptionHintICR,
            _maxIterations,
            msg.sender);
    }

    // --- Helper functions ---

    // Return the current collateral ratio (ICR) of a given Trove.
    // Takes a trove's pending coll and debt rewards from redistributions into account.
    function getCurrentICR(address _borrower) external view override returns (uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);

        uint ICR = _getICRColls(colls, currentYUSDDebt);
        return ICR;
    }

    // Gets current trove state as colls and debt. 
    function _getCurrentTroveState(address _borrower) internal view
    returns (newColls memory colls, uint YUSDdebt) {
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        
        YUSDdebt = Troves[_borrower].debt.add(pendingYUSDDebtReward);
        colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function applyPendingRewards(address _borrower) external override {
        _requireCallerIsBOorTMR();
        return _applyPendingRewards(activePool, defaultPool, _borrower);
    }

    // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
    function _applyPendingRewards(IActivePool _activePool, IDefaultPool _defaultPool, address _borrower) internal {
        if (hasPendingRewards(_borrower)) {
            _requireTroveIsActive(_borrower);

            // Compute pending collateral rewards
            newColls memory pendingCollReward = _getPendingCollRewards(_borrower);
            uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);

            // Apply pending rewards to trove's state
            Troves[_borrower].colls = _sumColls(Troves[_borrower].colls, pendingCollReward);
            Troves[_borrower].debt = Troves[_borrower].debt.add(pendingYUSDDebtReward);

            _updateTroveRewardSnapshots(_borrower);

            // Transfer from DefaultPool to ActivePool
            _movePendingTroveRewardsToActivePool(_activePool, _defaultPool, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts, _borrower);

            emit TroveUpdated(
                _borrower,
                Troves[_borrower].debt,
                Troves[_borrower].colls.tokens,
                Troves[_borrower].colls.amounts,
                TroveManagerOperation.applyPendingRewards
            );
        }
    }

    // Update borrower's snapshots of L_Coll and L_YUSDDebt to reflect the current values
    function updateTroveRewardSnapshots(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        _updateTroveRewardSnapshots(_borrower);
    }

    function _updateTroveRewardSnapshots(address _borrower) internal {
        address[] memory allColls = whitelist.getValidCollateral();
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address asset = allColls[i];
            rewardSnapshots[_borrower].CollRewards[asset] = L_Coll[asset];
            rewardSnapshots[_borrower].YUSDDebts[asset] = L_YUSDDebt[asset];
        }
        emit TroveSnapshotsUpdated(block.timestamp);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // Returned tokens and amounts are the length of whitelist.getValidCollateral();;
    function getPendingCollRewards(address _borrower) override external view returns (address[] memory, uint[] memory) {
        newColls memory pendingCollRewards = _getPendingCollRewards(_borrower);
        return (pendingCollRewards.tokens, pendingCollRewards.amounts);
    }

    // Get the borrower's pending accumulated Coll rewards, earned by their stake
    // pendingCollRewards.token and pendingCollRewards.amounts are the length of whitelist.getValidCollateral();
    function _getPendingCollRewards(address _borrower) internal view returns (newColls memory pendingCollRewards) {
        if (Troves[_borrower].status != Status.active) {
            newColls memory emptyColls;
            return emptyColls;
        }

        address[] memory allColls = whitelist.getValidCollateral();
        pendingCollRewards.amounts = new uint[](allColls.length);
        pendingCollRewards.tokens = allColls;
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotCollReward = rewardSnapshots[_borrower].CollRewards[coll];
            uint rewardPerUnitStaked = L_Coll[coll].sub(snapshotCollReward);
            if ( rewardPerUnitStaked == 0) {
                pendingCollRewards.amounts[i] = 0;
                continue; }

            uint stake = Troves[_borrower].stakes[coll];
            uint dec = IERC20(coll).decimals();
            uint assetCollReward = stake.mul(rewardPerUnitStaked).div(10 ** dec);
            pendingCollRewards.amounts[i] = assetCollReward; // i is correct index here
        }
    }

    // Get the borrower's pending accumulated YUSD reward, earned by their stake
    function getPendingYUSDDebtReward(address _borrower) public view override returns (uint pendingYUSDDebtReward) {
        if (Troves[_borrower].status != Status.active) {
            return 0;
        }
        address[] memory allColls = whitelist.getValidCollateral();

        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address coll = allColls[i];
            uint snapshotYUSDDebt = rewardSnapshots[_borrower].YUSDDebts[coll];
            uint rewardPerUnitStaked = L_YUSDDebt[allColls[i]].sub(snapshotYUSDDebt);
            if ( rewardPerUnitStaked == 0) { continue; }

            uint stake =  Troves[_borrower].stakes[coll];

            uint assetYUSDDebtReward = stake.mul(rewardPerUnitStaked).div(DECIMAL_PRECISION);
            pendingYUSDDebtReward = pendingYUSDDebtReward.add(assetYUSDDebtReward);
        }
    }

    function hasPendingRewards(address _borrower) public view override returns (bool) {
        /*
        * A Trove has pending rewards if its snapshot is less than the current rewards per-unit-staked sum:
        * this indicates that rewards have occured since the snapshot was made, and the user therefore has
        * pending rewards
        */
        if (Troves[_borrower].status != Status.active) {return false;}
        address[] memory assets =  Troves[_borrower].colls.tokens;
        uint256 assetsLen = assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address token = assets[i];
            if (rewardSnapshots[_borrower].CollRewards[token] < L_Coll[token]) {
                return true;
            }
        }
        return false;
    }

    // Returns debt, collsTokens, collsAmounts, pendingYUSDDebtReward, pendingRewardTokens, pendingRewardAmouns
    function getEntireDebtAndColls(
        address _borrower
    )
    public
    view override
    returns (uint, address[] memory, uint[] memory, uint, address[] memory, uint[] memory)
    {
        uint debt = Troves[_borrower].debt;
        newColls memory colls = Troves[_borrower].colls;

        uint pendingYUSDDebtReward = getPendingYUSDDebtReward(_borrower);
        newColls memory pendingCollReward = _getPendingCollRewards(_borrower);

        debt = debt.add(pendingYUSDDebtReward);

        // add in pending rewards to colls
        colls = _sumColls(colls, pendingCollReward);

        return (debt, colls.tokens, colls.amounts, pendingYUSDDebtReward, pendingCollReward.tokens, pendingCollReward.amounts);
    }

    // Borrower operations remove stake sum. 
    function removeStake(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _removeStake(_borrower);
    }

    // Remove borrower's stake from the totalStakes sum, and set their stake to 0
    function _removeStake(address _borrower) internal {
        address[] memory borrowerColls = Troves[_borrower].colls.tokens;
        uint256 borrowerCollsLen = borrowerColls.length;
        for (uint256 i; i < borrowerCollsLen; ++i) {
            address coll = borrowerColls[i];
            uint stake = Troves[_borrower].stakes[coll];
            totalStakes[coll] = totalStakes[coll].sub(stake);
            Troves[_borrower].stakes[coll] = 0;
        }
    }

    // Update borrower's stake based on their latest collateral value
    // computed at time function is called based on current price of collateral
    function updateStakeAndTotalStakes(address _borrower) external override {
        _requireCallerIsBOorTMR();
        _updateStakeAndTotalStakes(_borrower);
    }

    function _updateStakeAndTotalStakes(address _borrower) internal {
        uint256 troveOwnerLen = Troves[_borrower].colls.tokens.length;
        for (uint256 i; i < troveOwnerLen; ++i) {
            address token = Troves[_borrower].colls.tokens[i];
            uint amount = Troves[_borrower].colls.amounts[i];

            uint newStake = _computeNewStake(token, amount);
            uint oldStake = Troves[_borrower].stakes[token];

            Troves[_borrower].stakes[token] = newStake;
            totalStakes[token] = totalStakes[token].sub(oldStake).add(newStake);

            emit TotalStakesUpdated(token, totalStakes[token]);
        }
    }

    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
    function _computeNewStake(address token, uint _coll) internal view returns (uint) {
        uint stake;
        if (totalCollateralSnapshot[token] == 0) {
            stake = _coll;
        } else {
            /*
            * The following assert() holds true because:
            * - The system always contains >= 1 trove
            * - When we close or liquidate a trove, we redistribute the pending rewards, so if all troves were closed/liquidated,
            * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
            */
            require(totalStakesSnapshot[token] != 0, "TM: stake must be > 0");
            stake = _coll.mul(totalStakesSnapshot[token]).div(totalCollateralSnapshot[token]);
        }
        return stake;
    }

    function redistributeDebtAndColl(IActivePool _activePool, IDefaultPool _defaultPool, uint _debt, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, "TM: len tokens amounts");
        if (_debt == 0) { return; }
        /*
        * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
        * error correction, to keep the cumulative error low in the running totals L_Coll and L_YUSDDebt:
        *
        * 1) Form numerators which compensate for the floor division errors that occurred the last time this
        * function was called.
        * 2) Calculate "per-unit-staked" ratios.
        * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
        * 4) Store these errors for use in the next correction when this function is called.
        * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
        */
        uint totalCollateralVC = _getVC(_tokens, _amounts); // total collateral value in VC terms

        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            uint amount = _amounts[i];
            // Prorate debt per collateral by dividing each collateral value by cumulative collateral value and multiply by outstanding debt
            uint collateralVC = whitelist.getValueVC(token, amount);
            uint proratedDebtForCollateral = collateralVC.mul(_debt).div(totalCollateralVC);
            uint dec = IERC20(token).decimals();
            uint CollNumerator = amount.mul(10 ** dec).add(lastCollError_Redistribution[token]);
            uint YUSDDebtNumerator = proratedDebtForCollateral.mul(DECIMAL_PRECISION).add(lastYUSDDebtError_Redistribution[token]);
            if (totalStakes[token] != 0) {
                // Get the per-unit-staked terms
                uint256 thisTotalStakes = totalStakes[token];
                uint CollRewardPerUnitStaked = CollNumerator.div(thisTotalStakes);
                uint YUSDDebtRewardPerUnitStaked = YUSDDebtNumerator.div(thisTotalStakes.mul(10 ** (18 - dec)));

                lastCollError_Redistribution[token] = CollNumerator.sub(CollRewardPerUnitStaked.mul(thisTotalStakes));
                lastYUSDDebtError_Redistribution[token] = YUSDDebtNumerator.sub(YUSDDebtRewardPerUnitStaked.mul(thisTotalStakes.mul(10 ** (18 - dec))));

                // Add per-unit-staked terms to the running totals
                L_Coll[token] = L_Coll[token].add(CollRewardPerUnitStaked);
                L_YUSDDebt[token] = L_YUSDDebt[token].add(YUSDDebtRewardPerUnitStaked);
                emit LTermsUpdated(token, L_Coll[token], L_YUSDDebt[token]);
            }
        }

        // Transfer coll and debt from ActivePool to DefaultPool
        _activePool.decreaseYUSDDebt(_debt);
        _defaultPool.increaseYUSDDebt(_debt);
        _activePool.sendCollaterals(address(_defaultPool), _tokens, _amounts);
    }

    function closeTrove(address _borrower) external override {
        _requireCallerIsBorrowerOperations();
        return _closeTrove(_borrower, Status.closedByOwner);
    }

    function closeTroveLiquidation(address _borrower) external override {
        _requireCallerIsTML();
        return _closeTrove(_borrower, Status.closedByLiquidation);
    }

    function closeTroveRedemption(address _borrower) external override {
        _requireCallerIsTMR();
        return _closeTrove(_borrower, Status.closedByRedemption);
    }

    function _closeTrove(address _borrower, Status closedStatus) internal {
        require(closedStatus != Status.nonExistent && closedStatus != Status.active, "Status must be active and exists");

        uint TroveOwnersArrayLength = TroveOwners.length;
        _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
        newColls memory emptyColls;

        Troves[_borrower].status = closedStatus;
        Troves[_borrower].colls = emptyColls;
        Troves[_borrower].debt = 0;

        address[] memory allColls = whitelist.getValidCollateral();
        uint allCollsLen = allColls.length;
        address thisAllColls;
        for (uint256 i; i < allCollsLen; ++i) {
            thisAllColls = allColls[i];
            rewardSnapshots[_borrower].CollRewards[thisAllColls] = 0;
            rewardSnapshots[_borrower].YUSDDebts[thisAllColls] = 0;
        }

        _removeTroveOwner(_borrower, TroveOwnersArrayLength);
        sortedTroves.remove(_borrower);
    }

    /*
    * Updates snapshots of system total stakes and total collateral, excluding a given collateral remainder from the calculation.
    * Used in a liquidation sequence.
    *
    * The calculation excludes a portion of collateral that is in the ActivePool:
    *
    * the total Coll gas compensation from the liquidation sequence
    *
    * The Coll as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
    */
    function updateSystemSnapshots_excludeCollRemainder(IActivePool _activePool, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsTML();
        uint256 tokensLen = _tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address token = _tokens[i];
            totalStakesSnapshot[token] = totalStakes[token];

            uint _tokenRemainder = _amounts[i];
            uint activeColl = _activePool.getCollateral(token);
            uint liquidatedColl = defaultPool.getCollateral(token);
            totalCollateralSnapshot[token] = activeColl.sub(_tokenRemainder).add(liquidatedColl);
        }
        emit SystemSnapshotsUpdated(block.timestamp);
    }

    // Push the owner's address to the Trove owners list, and record the corresponding array index on the Trove struct
    function addTroveOwnerToArray(address _borrower) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        return _addTroveOwnerToArray(_borrower);
    }

    function _addTroveOwnerToArray(address _borrower) internal returns (uint128 index) {
        /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum YUSD
        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 YUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
        // Push the Troveowner to the array
        TroveOwners.push(_borrower);

        // Record the index of the new Troveowner on their Trove struct
        index = uint128(TroveOwners.length.sub(1));
        Troves[_borrower].arrayIndex = index;
    }

    /*
    * Remove a Trove owner from the TroveOwners array, not preserving array order. Removing owner 'B' does the following:
    * [A B C D E] => [A E C D], and updates E's Trove struct to point to its new array index.
    */
    function _removeTroveOwner(address _borrower, uint TroveOwnersArrayLength) internal {
        Status troveStatus = Troves[_borrower].status;
        // It’s set in caller function `_closeTrove`
        require(troveStatus != Status.nonExistent && troveStatus != Status.active, "TM: trove !exists or !active");

        uint128 index = Troves[_borrower].arrayIndex;
        uint length = TroveOwnersArrayLength;
        uint idxLast = length.sub(1);

        require(index <= idxLast, "TM: index must be > last index");

        address addressToMove = TroveOwners[idxLast];

        TroveOwners[index] = addressToMove;
        Troves[addressToMove].arrayIndex = index;
        emit TroveIndexUpdated(addressToMove, index);

        TroveOwners.pop();
    }

    // --- Recovery Mode and TCR functions ---

    function getTCR() external view override returns (uint) {
        return _getTCR();
    }

    function checkRecoveryMode() external view override returns (bool) {
        return _checkRecoveryMode();
    }


    // --- Redemption fee functions ---

    function updateBaseRate(uint newBaseRate) external override {
        _requireCallerIsTMR();
        require(newBaseRate != 0, "TM: newBaseRate must be > 0");
        baseRate = newBaseRate;
        emit BaseRateUpdated(newBaseRate);
        _updateLastFeeOpTime();
    }

    function getRedemptionRate() public view override returns (uint) {
        return _calcRedemptionRate(baseRate);
    }

    function getRedemptionRateWithDecay() public view override returns (uint) {
        return _calcRedemptionRate(calcDecayedBaseRate());
    }

    function _calcRedemptionRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            REDEMPTION_FEE_FLOOR.add(_baseRate),
            DECIMAL_PRECISION // cap at a maximum of 100%
        );
    }

    function _getRedemptionFee(uint _YUSDRedeemed) internal view returns (uint) {
        return _calcRedemptionFee(getRedemptionRate(), _YUSDRedeemed);
    }

    function getRedemptionFeeWithDecay(uint _YUSDRedeemed) external view override returns (uint) {
        return _calcRedemptionFee(getRedemptionRateWithDecay(), _YUSDRedeemed);
    }

    function _calcRedemptionFee(uint _redemptionRate, uint _YUSDRedeemed) internal pure returns (uint) {
        uint redemptionFee = _redemptionRate.mul(_YUSDRedeemed).div(DECIMAL_PRECISION);
        require(redemptionFee < _YUSDRedeemed, "TM:Fee>returned colls");
        return redemptionFee;
    }


    // --- Borrowing fee functions ---

    function getBorrowingRate() public view override returns (uint) {
        return _calcBorrowingRate(baseRate);
    }

    function getBorrowingRateWithDecay() public view override returns (uint) {
        return _calcBorrowingRate(calcDecayedBaseRate());
    }

    function _calcBorrowingRate(uint _baseRate) internal pure returns (uint) {
        return LiquityMath._min(
            BORROWING_FEE_FLOOR.add(_baseRate),
            MAX_BORROWING_FEE
        );
    }

    function getBorrowingFee(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRate(), _YUSDDebt);
    }

    function getBorrowingFeeWithDecay(uint _YUSDDebt) external view override returns (uint) {
        return _calcBorrowingFee(getBorrowingRateWithDecay(), _YUSDDebt);
    }

    function _calcBorrowingFee(uint _borrowingRate, uint _YUSDDebt) internal pure returns (uint) {
        return _borrowingRate.mul(_YUSDDebt).div(DECIMAL_PRECISION);
    }


    // Updates the baseRate state variable based on time elapsed since the last redemption or YUSD borrowing operation.
    function decayBaseRateFromBorrowing() external override {
        _requireCallerIsBorrowerOperations();

        uint decayedBaseRate = calcDecayedBaseRate();
        require(decayedBaseRate <= DECIMAL_PRECISION, "TM: decayed base rate too small");  // The baseRate can decay to 0

        baseRate = decayedBaseRate;
        emit BaseRateUpdated(decayedBaseRate);

        _updateLastFeeOpTime();
    }


    // --- Internal fee functions ---

    // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
    function _updateLastFeeOpTime() internal {
        uint timePassed = block.timestamp.sub(lastFeeOperationTime);

        if (timePassed >= SECONDS_IN_ONE_MINUTE) {
            lastFeeOperationTime = block.timestamp;
            emit LastFeeOpTimeUpdated(block.timestamp);
        }
    }

    function calcDecayedBaseRate() public view override returns (uint) {
        uint minutesPassed = _minutesPassedSinceLastFeeOp();
        uint decayFactor = LiquityMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);

        return baseRate.mul(decayFactor).div(DECIMAL_PRECISION);
    }

    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
        return (block.timestamp.sub(lastFeeOperationTime)).div(SECONDS_IN_ONE_MINUTE);
    }

    // --- 'require' wrapper functions ---

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsBOorTMR() internal view {
        if (msg.sender != borrowerOperationsAddress && msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTMR() internal view {
        if (msg.sender != troveManagerRedemptionsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != troveManagerLiquidationsAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view{
        revert("TM: External caller not allowed");
    }

    function _requireTroveIsActive(address _borrower) internal view {
        require(Troves[_borrower].status == Status.active, "TM: trove must exist");
    }

    function _requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) internal view {
        require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() > 1, "TM: last trove");
    }

    // --- Trove property getters ---

    function getTroveStatus(address _borrower) external view override returns (uint) {
        return uint(Troves[_borrower].status);
    }

    function isTroveActive(address _borrower) external view override returns (bool) {
        return Troves[_borrower].status == Status.active;
    }

    function getTroveStake(address _borrower, address _token) external view override returns (uint) {
        return Troves[_borrower].stakes[_token];
    }

    function getTroveDebt(address _borrower) external view override returns (uint) {
        return Troves[_borrower].debt;
    }

    // -- Trove Manager State Variable Getters -- 

    function getTotalStake(address _token) external view override returns (uint) {
        return totalStakes[_token];
    }

    function getL_Coll(address _token) external view override returns (uint) {
        return L_Coll[_token];
    }

    function getL_YUSD(address _token) external view override returns (uint) {
        return L_YUSDDebt[_token];
    }

    function getRewardSnapshotColl(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].CollRewards[_token];
    }

    function getRewardSnapshotYUSD(address _borrower, address _token) external view override returns (uint) {
        return rewardSnapshots[_borrower].YUSDDebts[_token];
    }

    // recomputes VC given current prices and returns it
    function getTroveVC(address _borrower) external view override returns (uint) {
        return _getVCColls(Troves[_borrower].colls);
    }

    function getTroveColls(address _borrower) external view override returns (address[] memory, uint[] memory) {
        return (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts);
    }

    function getCurrentTroveState(address _borrower) external override view returns (address[] memory, uint[] memory, uint) {
        (newColls memory colls, uint currentYUSDDebt) = _getCurrentTroveState(_borrower);
        return (colls.tokens, colls.amounts, currentYUSDDebt);
    }

    // --- Called by TroveManagerRedemptions Only ---


    function updateTroveDebt(address _borrower, uint debt) external override {
        _requireCallerIsTMR();
        Troves[_borrower].debt = debt;
    }

    function updateTroveCollTMR(address  _borrower, address[] memory addresses, uint[] memory amounts) external override {
        _requireCallerIsTMR();
        (Troves[_borrower].colls.tokens, Troves[_borrower].colls.amounts) = (addresses, amounts);
    }

    function removeStakeTMR(address _borrower) external override {
        _requireCallerIsTMR();
        _removeStake(_borrower);
    }

    // --- Called by TroverManagerLiquidations Only ---

    function removeStakeTLR(address _borrower) external override {
        _requireCallerIsTML();
        _removeStake(_borrower);
    }

    // --- Trove property setters, called by BorrowerOperations ---

    function setTroveStatus(address _borrower, uint _num) external override {
        _requireCallerIsBorrowerOperations();
        Troves[_borrower].status = Status(_num);
    }

    function updateTroveColl(address _borrower, address[] memory _tokens, uint[] memory _amounts) external override {
        _requireCallerIsBorrowerOperations();
        require(_tokens.length == _amounts.length, "TM: length mismatch");
        Troves[_borrower].colls.tokens = _tokens;
        Troves[_borrower].colls.amounts = _amounts;
    }

    function increaseTroveDebt(address _borrower, uint _debtIncrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.add(_debtIncrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    function decreaseTroveDebt(address _borrower, uint _debtDecrease) external override returns (uint) {
        _requireCallerIsBorrowerOperations();
        uint newDebt = Troves[_borrower].debt.sub(_debtDecrease);
        Troves[_borrower].debt = newDebt;
        return newDebt;
    }

    // --- contract getters ---

    function stabilityPool() external view override returns (IStabilityPool) {
        return stabilityPoolContract;
    }

    function yusdToken() external view override returns (IYUSDToken) {
        return yusdTokenContract;
    }

    function yetiToken() external view override returns (IYETIToken) {
        return yetiTokenContract;
    }

    function sYETI() external view override returns (ISYETI) {
        return sYETIContract;
    }
 }".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

